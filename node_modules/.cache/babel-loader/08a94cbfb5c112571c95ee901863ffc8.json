{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst typeFields_1 = require('../../typeFields');\n\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {\n    throw new Error('Decode Error: could not decode partialSig with key 0x' + keyVal.key.toString('hex'));\n  }\n\n  if (!(keyVal.key.length === 34 || keyVal.key.length === 66) || ![2, 3, 4].includes(keyVal.key[1])) {\n    throw new Error('Decode Error: partialSig has invalid pubkey in key 0x' + keyVal.key.toString('hex'));\n  }\n\n  const pubkey = keyVal.key.slice(1);\n  return {\n    pubkey,\n    signature: keyVal.value\n  };\n}\n\nexports.decode = decode;\n\nfunction encode(pSig) {\n  const head = Buffer.from([typeFields_1.InputTypes.PARTIAL_SIG]);\n  return {\n    key: Buffer.concat([head, pSig.pubkey]),\n    value: pSig.signature\n  };\n}\n\nexports.encode = encode;\nexports.expected = '{ pubkey: Buffer; signature: Buffer; }';\n\nfunction check(data) {\n  return Buffer.isBuffer(data.pubkey) && Buffer.isBuffer(data.signature) && [33, 65].includes(data.pubkey.length) && [2, 3, 4].includes(data.pubkey[0]) && isDerSigWithSighash(data.signature);\n}\n\nexports.check = check;\n\nfunction isDerSigWithSighash(buf) {\n  if (!Buffer.isBuffer(buf) || buf.length < 9) return false;\n  if (buf[0] !== 0x30) return false;\n  if (buf.length !== buf[1] + 3) return false;\n  if (buf[2] !== 0x02) return false;\n  const rLen = buf[3];\n  if (rLen > 33 || rLen < 1) return false;\n  if (buf[3 + rLen + 1] !== 0x02) return false;\n  const sLen = buf[3 + rLen + 2];\n  if (sLen > 33 || sLen < 1) return false;\n  if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;\n  return true;\n}\n\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString = item.pubkey.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;\n}\n\nexports.canAddToArray = canAddToArray;","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/bip174/src/lib/converter/input/partialSig.js"],"names":["Object","defineProperty","exports","value","typeFields_1","require","decode","keyVal","key","InputTypes","PARTIAL_SIG","Error","toString","length","includes","pubkey","slice","signature","encode","pSig","head","Buffer","from","concat","expected","check","data","isBuffer","isDerSigWithSighash","buf","rLen","sLen","canAddToArray","array","item","dupeSet","dupeString","has","add","filter","v","equals"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {\n    throw new Error(\n      'Decode Error: could not decode partialSig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (\n    !(keyVal.key.length === 34 || keyVal.key.length === 66) ||\n    ![2, 3, 4].includes(keyVal.key[1])\n  ) {\n    throw new Error(\n      'Decode Error: partialSig has invalid pubkey in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const pubkey = keyVal.key.slice(1);\n  return {\n    pubkey,\n    signature: keyVal.value,\n  };\n}\nexports.decode = decode;\nfunction encode(pSig) {\n  const head = Buffer.from([typeFields_1.InputTypes.PARTIAL_SIG]);\n  return {\n    key: Buffer.concat([head, pSig.pubkey]),\n    value: pSig.signature,\n  };\n}\nexports.encode = encode;\nexports.expected = '{ pubkey: Buffer; signature: Buffer; }';\nfunction check(data) {\n  return (\n    Buffer.isBuffer(data.pubkey) &&\n    Buffer.isBuffer(data.signature) &&\n    [33, 65].includes(data.pubkey.length) &&\n    [2, 3, 4].includes(data.pubkey[0]) &&\n    isDerSigWithSighash(data.signature)\n  );\n}\nexports.check = check;\nfunction isDerSigWithSighash(buf) {\n  if (!Buffer.isBuffer(buf) || buf.length < 9) return false;\n  if (buf[0] !== 0x30) return false;\n  if (buf.length !== buf[1] + 3) return false;\n  if (buf[2] !== 0x02) return false;\n  const rLen = buf[3];\n  if (rLen > 33 || rLen < 1) return false;\n  if (buf[3 + rLen + 1] !== 0x02) return false;\n  const sLen = buf[3 + rLen + 2];\n  if (sLen > 33 || sLen < 1) return false;\n  if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;\n  return true;\n}\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString = item.pubkey.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;\n}\nexports.canAddToArray = canAddToArray;\n"]},"metadata":{},"sourceType":"script"}