{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst range = n => [...Array(n).keys()];\n\nfunction makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error('Decode Error: could not decode bip32Derivation with key 0x' + keyVal.key.toString('hex'));\n    }\n\n    if (!(keyVal.key.length === 34 || keyVal.key.length === 66) || ![2, 3, 4].includes(keyVal.key[1])) {\n      throw new Error('Decode Error: bip32Derivation has invalid pubkey in key 0x' + keyVal.key.toString('hex'));\n    }\n\n    if (keyVal.value.length / 4 % 1 !== 0) {\n      throw new Error('Decode Error: Input BIP32_DERIVATION value length should be multiple of 4');\n    }\n\n    const pubkey = keyVal.key.slice(1);\n    const data = {\n      masterFingerprint: keyVal.value.slice(0, 4),\n      pubkey,\n      path: 'm'\n    };\n\n    for (const i of range(keyVal.value.length / 4 - 1)) {\n      const val = keyVal.value.readUInt32LE(i * 4 + 4);\n      const isHard = !!(val & 0x80000000);\n      const idx = val & 0x7fffffff;\n      data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n    }\n\n    return data;\n  }\n\n  function encode(data) {\n    const head = Buffer.from([TYPE_BYTE]);\n    const key = Buffer.concat([head, data.pubkey]);\n    const splitPath = data.path.split('/');\n    const value = Buffer.allocUnsafe(splitPath.length * 4);\n    data.masterFingerprint.copy(value, 0);\n    let offset = 4;\n    splitPath.slice(1).forEach(level => {\n      const isHard = level.slice(-1) === \"'\";\n      let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n      if (isHard) num += 0x80000000;\n      value.writeUInt32LE(num, offset);\n      offset += 4;\n    });\n    return {\n      key,\n      value\n    };\n  }\n\n  const expected = '{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }';\n\n  function check(data) {\n    return Buffer.isBuffer(data.pubkey) && Buffer.isBuffer(data.masterFingerprint) && typeof data.path === 'string' && [33, 65].includes(data.pubkey.length) && [2, 3, 4].includes(data.pubkey[0]) && data.masterFingerprint.length === 4;\n  }\n\n  function canAddToArray(array, item, dupeSet) {\n    const dupeString = item.pubkey.toString('hex');\n    if (dupeSet.has(dupeString)) return false;\n    dupeSet.add(dupeString);\n    return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;\n  }\n\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAddToArray\n  };\n}\n\nexports.makeConverter = makeConverter;","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/bip174/src/lib/converter/shared/bip32Derivation.js"],"names":["Object","defineProperty","exports","value","range","n","Array","keys","makeConverter","TYPE_BYTE","decode","keyVal","key","Error","toString","length","includes","pubkey","slice","data","masterFingerprint","path","i","val","readUInt32LE","isHard","idx","encode","head","Buffer","from","concat","splitPath","split","allocUnsafe","copy","offset","forEach","level","num","parseInt","writeUInt32LE","expected","check","isBuffer","canAddToArray","array","item","dupeSet","dupeString","has","add","filter","v","equals"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst range = n => [...Array(n).keys()];\nfunction makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode bip32Derivation with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    if (\n      !(keyVal.key.length === 34 || keyVal.key.length === 66) ||\n      ![2, 3, 4].includes(keyVal.key[1])\n    ) {\n      throw new Error(\n        'Decode Error: bip32Derivation has invalid pubkey in key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    if ((keyVal.value.length / 4) % 1 !== 0) {\n      throw new Error(\n        'Decode Error: Input BIP32_DERIVATION value length should be multiple of 4',\n      );\n    }\n    const pubkey = keyVal.key.slice(1);\n    const data = {\n      masterFingerprint: keyVal.value.slice(0, 4),\n      pubkey,\n      path: 'm',\n    };\n    for (const i of range(keyVal.value.length / 4 - 1)) {\n      const val = keyVal.value.readUInt32LE(i * 4 + 4);\n      const isHard = !!(val & 0x80000000);\n      const idx = val & 0x7fffffff;\n      data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n    }\n    return data;\n  }\n  function encode(data) {\n    const head = Buffer.from([TYPE_BYTE]);\n    const key = Buffer.concat([head, data.pubkey]);\n    const splitPath = data.path.split('/');\n    const value = Buffer.allocUnsafe(splitPath.length * 4);\n    data.masterFingerprint.copy(value, 0);\n    let offset = 4;\n    splitPath.slice(1).forEach(level => {\n      const isHard = level.slice(-1) === \"'\";\n      let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n      if (isHard) num += 0x80000000;\n      value.writeUInt32LE(num, offset);\n      offset += 4;\n    });\n    return {\n      key,\n      value,\n    };\n  }\n  const expected =\n    '{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }';\n  function check(data) {\n    return (\n      Buffer.isBuffer(data.pubkey) &&\n      Buffer.isBuffer(data.masterFingerprint) &&\n      typeof data.path === 'string' &&\n      [33, 65].includes(data.pubkey.length) &&\n      [2, 3, 4].includes(data.pubkey[0]) &&\n      data.masterFingerprint.length === 4\n    );\n  }\n  function canAddToArray(array, item, dupeSet) {\n    const dupeString = item.pubkey.toString('hex');\n    if (dupeSet.has(dupeString)) return false;\n    dupeSet.add(dupeString);\n    return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAddToArray,\n  };\n}\nexports.makeConverter = makeConverter;\n"]},"metadata":{},"sourceType":"script"}