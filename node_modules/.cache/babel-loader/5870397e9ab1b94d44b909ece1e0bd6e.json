{"ast":null,"code":"import { getLocalUserIdentity } from \"./user\";\nexport async function getFileIndex(buckets, bucketKey) {\n  try {\n    const metadata = buckets.pullPath(bucketKey, 'index.json');\n    const {\n      value\n    } = await metadata.next();\n    let str = \"\";\n\n    for (let i = 0; i < value.length; i++) {\n      str += String.fromCharCode(parseInt(String(value[i])));\n    }\n\n    const index = JSON.parse(str);\n    return index;\n  } catch (error) {\n    const index = await initIndex(buckets, bucketKey);\n    return index;\n  }\n}\n\nasync function initIndex(buckets, bucketKey) {\n  const identity = await getLocalUserIdentity();\n\n  if (!identity) {\n    console.error('Identity not set'); // @ts-ignore\n\n    return null;\n  }\n\n  const index = {\n    author: identity.public.toString(),\n    counts: 0,\n    paths: []\n  };\n  await storeIndex(index, buckets, bucketKey);\n  return index;\n}\n\nasync function storeIndex(index, buckets, bucketKey) {\n  const buf = Buffer.from(JSON.stringify(index, null, 2));\n  const path = `index.json`;\n  await buckets.pushPath(bucketKey, path, buf);\n}","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/src/common/FileIndex.ts"],"names":["getLocalUserIdentity","getFileIndex","buckets","bucketKey","metadata","pullPath","value","next","str","i","length","String","fromCharCode","parseInt","index","JSON","parse","error","initIndex","identity","console","author","public","toString","counts","paths","storeIndex","buf","Buffer","from","stringify","path","pushPath"],"mappings":"AAEA,SAAQA,oBAAR,QAAmC,QAAnC;AAEC,OAAO,eAAeC,YAAf,CAA4BC,OAA5B,EAA4CC,SAA5C,EAAiF;AACrF,MAAI;AACA,UAAMC,QAAQ,GAAGF,OAAO,CAACG,QAAR,CAAiBF,SAAjB,EAA4B,YAA5B,CAAjB;AACA,UAAM;AAAEG,MAAAA;AAAF,QAAY,MAAMF,QAAQ,CAACG,IAAT,EAAxB;AACA,QAAIC,GAAG,GAAG,EAAV;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,KAAK,CAACI,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACnCD,MAAAA,GAAG,IAAIG,MAAM,CAACC,YAAP,CAAoBC,QAAQ,CAACF,MAAM,CAACL,KAAK,CAACG,CAAD,CAAN,CAAP,CAA5B,CAAP;AACH;;AACD,UAAMK,KAAgB,GAAGC,IAAI,CAACC,KAAL,CAAWR,GAAX,CAAzB;AACA,WAAOM,KAAP;AACH,GATD,CASE,OAAOG,KAAP,EAAc;AACZ,UAAMH,KAAK,GAAG,MAAMI,SAAS,CAAChB,OAAD,EAASC,SAAT,CAA7B;AACA,WAAOW,KAAP;AACH;AACJ;;AAED,eAAgBI,SAAhB,CAA0BhB,OAA1B,EAA0CC,SAA1C,EAAgF;AAC5E,QAAMgB,QAAQ,GAAG,MAAMnB,oBAAoB,EAA3C;;AACA,MAAI,CAACmB,QAAL,EAAe;AACXC,IAAAA,OAAO,CAACH,KAAR,CAAc,kBAAd,EADW,CAEX;;AACA,WAAO,IAAP;AACH;;AACD,QAAMH,KAAK,GAAG;AACVO,IAAAA,MAAM,EAAEF,QAAQ,CAACG,MAAT,CAAgBC,QAAhB,EADE;AAEVC,IAAAA,MAAM,EAAE,CAFE;AAGVC,IAAAA,KAAK,EAAE;AAHG,GAAd;AAKA,QAAMC,UAAU,CAACZ,KAAD,EAAOZ,OAAP,EAAeC,SAAf,CAAhB;AACA,SAAOW,KAAP;AACH;;AAED,eAAgBY,UAAhB,CAA2BZ,KAA3B,EAA4CZ,OAA5C,EAA4DC,SAA5D,EAA8E;AAC1E,QAAMwB,GAAG,GAAGC,MAAM,CAACC,IAAP,CAAYd,IAAI,CAACe,SAAL,CAAehB,KAAf,EAAsB,IAAtB,EAA4B,CAA5B,CAAZ,CAAZ;AACA,QAAMiB,IAAI,GAAI,YAAd;AACA,QAAM7B,OAAO,CAAC8B,QAAR,CAAiB7B,SAAjB,EAA4B4B,IAA5B,EAAkCJ,GAAlC,CAAN;AACH","sourcesContent":["import {FileIndex} from \"./Types\";\nimport { Buckets} from '@textile/hub'\nimport {getLocalUserIdentity} from \"./user\";\n\n export async function getFileIndex(buckets:Buckets,bucketKey:string) :Promise<FileIndex>{\n    try {\n        const metadata = buckets.pullPath(bucketKey ,'index.json');\n        const { value } = await metadata.next();\n        let str = \"\";\n        for (let i = 0; i < value.length; i++) {\n            str += String.fromCharCode(parseInt(String(value[i])));\n        }\n        const index: FileIndex = JSON.parse(str);\n        return index\n    } catch (error) {\n        const index = await initIndex(buckets,bucketKey);\n        return index\n    }\n}\n\nasync function  initIndex(buckets:Buckets,bucketKey:string) :Promise<FileIndex> {\n    const identity = await getLocalUserIdentity();\n    if (!identity) {\n        console.error('Identity not set');\n        // @ts-ignore\n        return null;\n    }\n    const index = {\n        author: identity.public.toString(),\n        counts: 0,\n        paths: []\n    };\n    await storeIndex(index,buckets,bucketKey);\n    return index\n}\n\nasync function  storeIndex(index: FileIndex,buckets:Buckets,bucketKey:string) {\n    const buf = Buffer.from(JSON.stringify(index, null, 2))\n    const path = `index.json`;\n    await buckets.pushPath(bucketKey, path, buf)\n}\n"]},"metadata":{},"sourceType":"module"}