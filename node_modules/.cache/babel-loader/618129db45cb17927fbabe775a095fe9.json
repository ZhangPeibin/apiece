{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst bufferutils_1 = require('./bufferutils');\n\nconst bcrypto = require('./crypto');\n\nconst transaction_1 = require('./transaction');\n\nconst types = require('./types');\n\nconst fastMerkleRoot = require('merkle-lib/fastRoot');\n\nconst typeforce = require('typeforce');\n\nconst varuint = require('varuint-bitcoin');\n\nconst errorMerkleNoTxes = new TypeError('Cannot compute merkle root for zero transactions');\nconst errorWitnessNotSegwit = new TypeError('Cannot compute witness commit for non-segwit block');\n\nclass Block {\n  constructor() {\n    this.version = 1;\n    this.prevHash = undefined;\n    this.merkleRoot = undefined;\n    this.timestamp = 0;\n    this.witnessCommit = undefined;\n    this.bits = 0;\n    this.nonce = 0;\n    this.transactions = undefined;\n  }\n\n  static fromBuffer(buffer) {\n    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const block = new Block();\n    block.version = bufferReader.readInt32();\n    block.prevHash = bufferReader.readSlice(32);\n    block.merkleRoot = bufferReader.readSlice(32);\n    block.timestamp = bufferReader.readUInt32();\n    block.bits = bufferReader.readUInt32();\n    block.nonce = bufferReader.readUInt32();\n    if (buffer.length === 80) return block;\n\n    const readTransaction = () => {\n      const tx = transaction_1.Transaction.fromBuffer(bufferReader.buffer.slice(bufferReader.offset), true);\n      bufferReader.offset += tx.byteLength();\n      return tx;\n    };\n\n    const nTransactions = bufferReader.readVarInt();\n    block.transactions = [];\n\n    for (let i = 0; i < nTransactions; ++i) {\n      const tx = readTransaction();\n      block.transactions.push(tx);\n    }\n\n    const witnessCommit = block.getWitnessCommit(); // This Block contains a witness commit\n\n    if (witnessCommit) block.witnessCommit = witnessCommit;\n    return block;\n  }\n\n  static fromHex(hex) {\n    return Block.fromBuffer(Buffer.from(hex, 'hex'));\n  }\n\n  static calculateTarget(bits) {\n    const exponent = ((bits & 0xff000000) >> 24) - 3;\n    const mantissa = bits & 0x007fffff;\n    const target = Buffer.alloc(32, 0);\n    target.writeUIntBE(mantissa, 29 - exponent, 3);\n    return target;\n  }\n\n  static calculateMerkleRoot(transactions, forWitness) {\n    typeforce([{\n      getHash: types.Function\n    }], transactions);\n    if (transactions.length === 0) throw errorMerkleNoTxes;\n    if (forWitness && !txesHaveWitnessCommit(transactions)) throw errorWitnessNotSegwit;\n    const hashes = transactions.map(transaction => transaction.getHash(forWitness));\n    const rootHash = fastMerkleRoot(hashes, bcrypto.hash256);\n    return forWitness ? bcrypto.hash256(Buffer.concat([rootHash, transactions[0].ins[0].witness[0]])) : rootHash;\n  }\n\n  getWitnessCommit() {\n    if (!txesHaveWitnessCommit(this.transactions)) return null; // The merkle root for the witness data is in an OP_RETURN output.\n    // There is no rule for the index of the output, so use filter to find it.\n    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed\n    // If multiple commits are found, the output with highest index is assumed.\n\n    const witnessCommits = this.transactions[0].outs.filter(out => out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex'))).map(out => out.script.slice(6, 38));\n    if (witnessCommits.length === 0) return null; // Use the commit with the highest output (should only be one though)\n\n    const result = witnessCommits[witnessCommits.length - 1];\n    if (!(result instanceof Buffer && result.length === 32)) return null;\n    return result;\n  }\n\n  hasWitnessCommit() {\n    if (this.witnessCommit instanceof Buffer && this.witnessCommit.length === 32) return true;\n    if (this.getWitnessCommit() !== null) return true;\n    return false;\n  }\n\n  hasWitness() {\n    return anyTxHasWitness(this.transactions);\n  }\n\n  weight() {\n    const base = this.byteLength(false, false);\n    const total = this.byteLength(false, true);\n    return base * 3 + total;\n  }\n\n  byteLength(headersOnly, allowWitness = true) {\n    if (headersOnly || !this.transactions) return 80;\n    return 80 + varuint.encodingLength(this.transactions.length) + this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0);\n  }\n\n  getHash() {\n    return bcrypto.hash256(this.toBuffer(true));\n  }\n\n  getId() {\n    return bufferutils_1.reverseBuffer(this.getHash()).toString('hex');\n  }\n\n  getUTCDate() {\n    const date = new Date(0); // epoch\n\n    date.setUTCSeconds(this.timestamp);\n    return date;\n  } // TODO: buffer, offset compatibility\n\n\n  toBuffer(headersOnly) {\n    const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n    const bufferWriter = new bufferutils_1.BufferWriter(buffer);\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(this.prevHash);\n    bufferWriter.writeSlice(this.merkleRoot);\n    bufferWriter.writeUInt32(this.timestamp);\n    bufferWriter.writeUInt32(this.bits);\n    bufferWriter.writeUInt32(this.nonce);\n    if (headersOnly || !this.transactions) return buffer;\n    varuint.encode(this.transactions.length, buffer, bufferWriter.offset);\n    bufferWriter.offset += varuint.encode.bytes;\n    this.transactions.forEach(tx => {\n      const txSize = tx.byteLength(); // TODO: extract from toBuffer?\n\n      tx.toBuffer(buffer, bufferWriter.offset);\n      bufferWriter.offset += txSize;\n    });\n    return buffer;\n  }\n\n  toHex(headersOnly) {\n    return this.toBuffer(headersOnly).toString('hex');\n  }\n\n  checkTxRoots() {\n    // If the Block has segwit transactions but no witness commit,\n    // there's no way it can be valid, so fail the check.\n    const hasWitnessCommit = this.hasWitnessCommit();\n    if (!hasWitnessCommit && this.hasWitness()) return false;\n    return this.__checkMerkleRoot() && (hasWitnessCommit ? this.__checkWitnessCommit() : true);\n  }\n\n  checkProofOfWork() {\n    const hash = bufferutils_1.reverseBuffer(this.getHash());\n    const target = Block.calculateTarget(this.bits);\n    return hash.compare(target) <= 0;\n  }\n\n  __checkMerkleRoot() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n    return this.merkleRoot.compare(actualMerkleRoot) === 0;\n  }\n\n  __checkWitnessCommit() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;\n    const actualWitnessCommit = Block.calculateMerkleRoot(this.transactions, true);\n    return this.witnessCommit.compare(actualWitnessCommit) === 0;\n  }\n\n}\n\nexports.Block = Block;\n\nfunction txesHaveWitnessCommit(transactions) {\n  return transactions instanceof Array && transactions[0] && transactions[0].ins && transactions[0].ins instanceof Array && transactions[0].ins[0] && transactions[0].ins[0].witness && transactions[0].ins[0].witness instanceof Array && transactions[0].ins[0].witness.length > 0;\n}\n\nfunction anyTxHasWitness(transactions) {\n  return transactions instanceof Array && transactions.some(tx => typeof tx === 'object' && tx.ins instanceof Array && tx.ins.some(input => typeof input === 'object' && input.witness instanceof Array && input.witness.length > 0));\n}","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/bitcoinjs-lib/src/block.js"],"names":["Object","defineProperty","exports","value","bufferutils_1","require","bcrypto","transaction_1","types","fastMerkleRoot","typeforce","varuint","errorMerkleNoTxes","TypeError","errorWitnessNotSegwit","Block","constructor","version","prevHash","undefined","merkleRoot","timestamp","witnessCommit","bits","nonce","transactions","fromBuffer","buffer","length","Error","bufferReader","BufferReader","block","readInt32","readSlice","readUInt32","readTransaction","tx","Transaction","slice","offset","byteLength","nTransactions","readVarInt","i","push","getWitnessCommit","fromHex","hex","Buffer","from","calculateTarget","exponent","mantissa","target","alloc","writeUIntBE","calculateMerkleRoot","forWitness","getHash","Function","txesHaveWitnessCommit","hashes","map","transaction","rootHash","hash256","concat","ins","witness","witnessCommits","outs","filter","out","script","equals","result","hasWitnessCommit","hasWitness","anyTxHasWitness","weight","base","total","headersOnly","allowWitness","encodingLength","reduce","a","x","toBuffer","getId","reverseBuffer","toString","getUTCDate","date","Date","setUTCSeconds","allocUnsafe","bufferWriter","BufferWriter","writeInt32","writeSlice","writeUInt32","encode","bytes","forEach","txSize","toHex","checkTxRoots","__checkMerkleRoot","__checkWitnessCommit","checkProofOfWork","hash","compare","actualMerkleRoot","actualWitnessCommit","Array","some","input"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst transaction_1 = require('./transaction');\nconst types = require('./types');\nconst fastMerkleRoot = require('merkle-lib/fastRoot');\nconst typeforce = require('typeforce');\nconst varuint = require('varuint-bitcoin');\nconst errorMerkleNoTxes = new TypeError(\n  'Cannot compute merkle root for zero transactions',\n);\nconst errorWitnessNotSegwit = new TypeError(\n  'Cannot compute witness commit for non-segwit block',\n);\nclass Block {\n  constructor() {\n    this.version = 1;\n    this.prevHash = undefined;\n    this.merkleRoot = undefined;\n    this.timestamp = 0;\n    this.witnessCommit = undefined;\n    this.bits = 0;\n    this.nonce = 0;\n    this.transactions = undefined;\n  }\n  static fromBuffer(buffer) {\n    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const block = new Block();\n    block.version = bufferReader.readInt32();\n    block.prevHash = bufferReader.readSlice(32);\n    block.merkleRoot = bufferReader.readSlice(32);\n    block.timestamp = bufferReader.readUInt32();\n    block.bits = bufferReader.readUInt32();\n    block.nonce = bufferReader.readUInt32();\n    if (buffer.length === 80) return block;\n    const readTransaction = () => {\n      const tx = transaction_1.Transaction.fromBuffer(\n        bufferReader.buffer.slice(bufferReader.offset),\n        true,\n      );\n      bufferReader.offset += tx.byteLength();\n      return tx;\n    };\n    const nTransactions = bufferReader.readVarInt();\n    block.transactions = [];\n    for (let i = 0; i < nTransactions; ++i) {\n      const tx = readTransaction();\n      block.transactions.push(tx);\n    }\n    const witnessCommit = block.getWitnessCommit();\n    // This Block contains a witness commit\n    if (witnessCommit) block.witnessCommit = witnessCommit;\n    return block;\n  }\n  static fromHex(hex) {\n    return Block.fromBuffer(Buffer.from(hex, 'hex'));\n  }\n  static calculateTarget(bits) {\n    const exponent = ((bits & 0xff000000) >> 24) - 3;\n    const mantissa = bits & 0x007fffff;\n    const target = Buffer.alloc(32, 0);\n    target.writeUIntBE(mantissa, 29 - exponent, 3);\n    return target;\n  }\n  static calculateMerkleRoot(transactions, forWitness) {\n    typeforce([{ getHash: types.Function }], transactions);\n    if (transactions.length === 0) throw errorMerkleNoTxes;\n    if (forWitness && !txesHaveWitnessCommit(transactions))\n      throw errorWitnessNotSegwit;\n    const hashes = transactions.map(transaction =>\n      transaction.getHash(forWitness),\n    );\n    const rootHash = fastMerkleRoot(hashes, bcrypto.hash256);\n    return forWitness\n      ? bcrypto.hash256(\n          Buffer.concat([rootHash, transactions[0].ins[0].witness[0]]),\n        )\n      : rootHash;\n  }\n  getWitnessCommit() {\n    if (!txesHaveWitnessCommit(this.transactions)) return null;\n    // The merkle root for the witness data is in an OP_RETURN output.\n    // There is no rule for the index of the output, so use filter to find it.\n    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed\n    // If multiple commits are found, the output with highest index is assumed.\n    const witnessCommits = this.transactions[0].outs\n      .filter(out =>\n        out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex')),\n      )\n      .map(out => out.script.slice(6, 38));\n    if (witnessCommits.length === 0) return null;\n    // Use the commit with the highest output (should only be one though)\n    const result = witnessCommits[witnessCommits.length - 1];\n    if (!(result instanceof Buffer && result.length === 32)) return null;\n    return result;\n  }\n  hasWitnessCommit() {\n    if (\n      this.witnessCommit instanceof Buffer &&\n      this.witnessCommit.length === 32\n    )\n      return true;\n    if (this.getWitnessCommit() !== null) return true;\n    return false;\n  }\n  hasWitness() {\n    return anyTxHasWitness(this.transactions);\n  }\n  weight() {\n    const base = this.byteLength(false, false);\n    const total = this.byteLength(false, true);\n    return base * 3 + total;\n  }\n  byteLength(headersOnly, allowWitness = true) {\n    if (headersOnly || !this.transactions) return 80;\n    return (\n      80 +\n      varuint.encodingLength(this.transactions.length) +\n      this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)\n    );\n  }\n  getHash() {\n    return bcrypto.hash256(this.toBuffer(true));\n  }\n  getId() {\n    return bufferutils_1.reverseBuffer(this.getHash()).toString('hex');\n  }\n  getUTCDate() {\n    const date = new Date(0); // epoch\n    date.setUTCSeconds(this.timestamp);\n    return date;\n  }\n  // TODO: buffer, offset compatibility\n  toBuffer(headersOnly) {\n    const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n    const bufferWriter = new bufferutils_1.BufferWriter(buffer);\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(this.prevHash);\n    bufferWriter.writeSlice(this.merkleRoot);\n    bufferWriter.writeUInt32(this.timestamp);\n    bufferWriter.writeUInt32(this.bits);\n    bufferWriter.writeUInt32(this.nonce);\n    if (headersOnly || !this.transactions) return buffer;\n    varuint.encode(this.transactions.length, buffer, bufferWriter.offset);\n    bufferWriter.offset += varuint.encode.bytes;\n    this.transactions.forEach(tx => {\n      const txSize = tx.byteLength(); // TODO: extract from toBuffer?\n      tx.toBuffer(buffer, bufferWriter.offset);\n      bufferWriter.offset += txSize;\n    });\n    return buffer;\n  }\n  toHex(headersOnly) {\n    return this.toBuffer(headersOnly).toString('hex');\n  }\n  checkTxRoots() {\n    // If the Block has segwit transactions but no witness commit,\n    // there's no way it can be valid, so fail the check.\n    const hasWitnessCommit = this.hasWitnessCommit();\n    if (!hasWitnessCommit && this.hasWitness()) return false;\n    return (\n      this.__checkMerkleRoot() &&\n      (hasWitnessCommit ? this.__checkWitnessCommit() : true)\n    );\n  }\n  checkProofOfWork() {\n    const hash = bufferutils_1.reverseBuffer(this.getHash());\n    const target = Block.calculateTarget(this.bits);\n    return hash.compare(target) <= 0;\n  }\n  __checkMerkleRoot() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n    return this.merkleRoot.compare(actualMerkleRoot) === 0;\n  }\n  __checkWitnessCommit() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;\n    const actualWitnessCommit = Block.calculateMerkleRoot(\n      this.transactions,\n      true,\n    );\n    return this.witnessCommit.compare(actualWitnessCommit) === 0;\n  }\n}\nexports.Block = Block;\nfunction txesHaveWitnessCommit(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions[0] &&\n    transactions[0].ins &&\n    transactions[0].ins instanceof Array &&\n    transactions[0].ins[0] &&\n    transactions[0].ins[0].witness &&\n    transactions[0].ins[0].witness instanceof Array &&\n    transactions[0].ins[0].witness.length > 0\n  );\n}\nfunction anyTxHasWitness(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions.some(\n      tx =>\n        typeof tx === 'object' &&\n        tx.ins instanceof Array &&\n        tx.ins.some(\n          input =>\n            typeof input === 'object' &&\n            input.witness instanceof Array &&\n            input.witness.length > 0,\n        ),\n    )\n  );\n}\n"]},"metadata":{},"sourceType":"script"}