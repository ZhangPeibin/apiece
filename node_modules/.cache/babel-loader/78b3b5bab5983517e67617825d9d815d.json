{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst convert = require('../converter');\n\nconst tools_1 = require('../converter/tools');\n\nfunction psbtToBuffer({\n  globalMap,\n  inputs,\n  outputs\n}) {\n  const {\n    globalKeyVals,\n    inputKeyVals,\n    outputKeyVals\n  } = psbtToKeyVals({\n    globalMap,\n    inputs,\n    outputs\n  });\n  const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);\n\n  const keyValsOrEmptyToBuffer = keyVals => keyVals.length === 0 ? [Buffer.from([0])] : keyVals.map(tools_1.keyValsToBuffer);\n\n  const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);\n  const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);\n  const header = Buffer.allocUnsafe(5);\n  header.writeUIntBE(0x70736274ff, 0, 5);\n  return Buffer.concat([header, globalBuffer].concat(inputBuffers, outputBuffers));\n}\n\nexports.psbtToBuffer = psbtToBuffer;\n\nconst sortKeyVals = (a, b) => {\n  return a.key.compare(b.key);\n};\n\nfunction keyValsFromMap(keyValMap, converterFactory) {\n  const keyHexSet = new Set();\n  const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {\n    if (key === 'unknownKeyVals') return result; // We are checking for undefined anyways. So ignore TS error\n    // @ts-ignore\n\n    const converter = converterFactory[key];\n    if (converter === undefined) return result;\n    const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(converter.encode);\n    const keyHexes = encodedKeyVals.map(kv => kv.key.toString('hex'));\n    keyHexes.forEach(hex => {\n      if (keyHexSet.has(hex)) throw new Error('Serialize Error: Duplicate key: ' + hex);\n      keyHexSet.add(hex);\n    });\n    return result.concat(encodedKeyVals);\n  }, []); // Get other keyVals that have not yet been gotten\n\n  const otherKeyVals = keyValMap.unknownKeyVals ? keyValMap.unknownKeyVals.filter(keyVal => {\n    return !keyHexSet.has(keyVal.key.toString('hex'));\n  }) : [];\n  return keyVals.concat(otherKeyVals).sort(sortKeyVals);\n}\n\nfunction psbtToKeyVals({\n  globalMap,\n  inputs,\n  outputs\n}) {\n  // First parse the global keyVals\n  // Get any extra keyvals to pass along\n  return {\n    globalKeyVals: keyValsFromMap(globalMap, convert.globals),\n    inputKeyVals: inputs.map(i => keyValsFromMap(i, convert.inputs)),\n    outputKeyVals: outputs.map(o => keyValsFromMap(o, convert.outputs))\n  };\n}\n\nexports.psbtToKeyVals = psbtToKeyVals;","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/bip174/src/lib/parser/toBuffer.js"],"names":["Object","defineProperty","exports","value","convert","require","tools_1","psbtToBuffer","globalMap","inputs","outputs","globalKeyVals","inputKeyVals","outputKeyVals","psbtToKeyVals","globalBuffer","keyValsToBuffer","keyValsOrEmptyToBuffer","keyVals","length","Buffer","from","map","inputBuffers","outputBuffers","header","allocUnsafe","writeUIntBE","concat","sortKeyVals","a","b","key","compare","keyValsFromMap","keyValMap","converterFactory","keyHexSet","Set","entries","reduce","result","converter","undefined","encodedKeyVals","Array","isArray","encode","keyHexes","kv","toString","forEach","hex","has","Error","add","otherKeyVals","unknownKeyVals","filter","keyVal","sort","globals","i","o"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst convert = require('../converter');\nconst tools_1 = require('../converter/tools');\nfunction psbtToBuffer({ globalMap, inputs, outputs }) {\n  const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({\n    globalMap,\n    inputs,\n    outputs,\n  });\n  const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);\n  const keyValsOrEmptyToBuffer = keyVals =>\n    keyVals.length === 0\n      ? [Buffer.from([0])]\n      : keyVals.map(tools_1.keyValsToBuffer);\n  const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);\n  const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);\n  const header = Buffer.allocUnsafe(5);\n  header.writeUIntBE(0x70736274ff, 0, 5);\n  return Buffer.concat(\n    [header, globalBuffer].concat(inputBuffers, outputBuffers),\n  );\n}\nexports.psbtToBuffer = psbtToBuffer;\nconst sortKeyVals = (a, b) => {\n  return a.key.compare(b.key);\n};\nfunction keyValsFromMap(keyValMap, converterFactory) {\n  const keyHexSet = new Set();\n  const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {\n    if (key === 'unknownKeyVals') return result;\n    // We are checking for undefined anyways. So ignore TS error\n    // @ts-ignore\n    const converter = converterFactory[key];\n    if (converter === undefined) return result;\n    const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(\n      converter.encode,\n    );\n    const keyHexes = encodedKeyVals.map(kv => kv.key.toString('hex'));\n    keyHexes.forEach(hex => {\n      if (keyHexSet.has(hex))\n        throw new Error('Serialize Error: Duplicate key: ' + hex);\n      keyHexSet.add(hex);\n    });\n    return result.concat(encodedKeyVals);\n  }, []);\n  // Get other keyVals that have not yet been gotten\n  const otherKeyVals = keyValMap.unknownKeyVals\n    ? keyValMap.unknownKeyVals.filter(keyVal => {\n        return !keyHexSet.has(keyVal.key.toString('hex'));\n      })\n    : [];\n  return keyVals.concat(otherKeyVals).sort(sortKeyVals);\n}\nfunction psbtToKeyVals({ globalMap, inputs, outputs }) {\n  // First parse the global keyVals\n  // Get any extra keyvals to pass along\n  return {\n    globalKeyVals: keyValsFromMap(globalMap, convert.globals),\n    inputKeyVals: inputs.map(i => keyValsFromMap(i, convert.inputs)),\n    outputKeyVals: outputs.map(o => keyValsFromMap(o, convert.outputs)),\n  };\n}\nexports.psbtToKeyVals = psbtToKeyVals;\n"]},"metadata":{},"sourceType":"script"}