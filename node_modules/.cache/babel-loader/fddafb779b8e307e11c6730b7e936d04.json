{"ast":null,"code":"export async function onDropToUpload(acceptedFiles, buckets, bucketKey, callback) {\n  for (const accepted of acceptedFiles) {\n    await handleNewFile(accepted, buckets, bucketKey, callback);\n  }\n}\n\nasync function handleNewFile(file, buckets, bucketKey, callback) {\n  const fileSchema = {};\n  const now = new Date().getTime();\n  fileSchema['date'] = now;\n  fileSchema['name'] = `${file.name}`;\n  const filename = `${file.name}`;\n  const location = `${'/'}${filename}`;\n\n  if (!buckets || !bucketKey) {\n    throw new Error('No bucket client or root key');\n  }\n\n  const reader = new FileReader(); // reader.onabort = () => {\n  //     return reject(`file reading was aborted`);\n  // }\n  // reader.onerror = () => reject('file reading has failed')\n\n  reader.onload = () => {\n    const binaryStr = reader.result; // Finally, push the full file to the bucket\n\n    buckets.pushPath(bucketKey, location, binaryStr).then(raw => {\n      const metadata = {\n        cid: raw.path.cid.toString(),\n        name: filename,\n        path: location,\n        size: file.size,\n        date: new Date().toLocaleString()\n      };\n      callback(metadata);\n    });\n  };\n\n  reader.readAsArrayBuffer(file);\n}","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/src/common/upload.ts"],"names":["onDropToUpload","acceptedFiles","buckets","bucketKey","callback","accepted","handleNewFile","file","fileSchema","now","Date","getTime","name","filename","location","Error","reader","FileReader","onload","binaryStr","result","pushPath","then","raw","metadata","cid","path","toString","size","date","toLocaleString","readAsArrayBuffer"],"mappings":"AAEA,OAAO,eAAeA,cAAf,CAA8BC,aAA9B,EAAqDC,OAArD,EAAuEC,SAAvE,EAA0FC,QAA1F,EAA8G;AACjH,OAAK,MAAMC,QAAX,IAAuBJ,aAAvB,EAAsC;AAClC,UAAMK,aAAa,CAACD,QAAD,EAAWH,OAAX,EAAoBC,SAApB,EAA+BC,QAA/B,CAAnB;AACH;AACJ;;AAED,eAAeE,aAAf,CAA6BC,IAA7B,EAAyCL,OAAzC,EAA2DC,SAA3D,EAA8EC,QAA9E,EAAkG;AAC9F,QAAMI,UAAkC,GAAG,EAA3C;AACA,QAAMC,GAAG,GAAG,IAAIC,IAAJ,GAAWC,OAAX,EAAZ;AACAH,EAAAA,UAAU,CAAC,MAAD,CAAV,GAAqBC,GAArB;AACAD,EAAAA,UAAU,CAAC,MAAD,CAAV,GAAsB,GAAED,IAAI,CAACK,IAAK,EAAlC;AACA,QAAMC,QAAQ,GAAI,GAAEN,IAAI,CAACK,IAAK,EAA9B;AACA,QAAME,QAAQ,GAAI,GAAE,GAAI,GAAED,QAAS,EAAnC;;AAEA,MAAI,CAACX,OAAD,IAAY,CAACC,SAAjB,EAA4B;AACxB,UAAM,IAAIY,KAAJ,CAAU,8BAAV,CAAN;AACH;;AAED,QAAMC,MAAM,GAAG,IAAIC,UAAJ,EAAf,CAZ8F,CAa9F;AACA;AACA;AACA;;AACAD,EAAAA,MAAM,CAACE,MAAP,GAAgB,MAAM;AAClB,UAAMC,SAAS,GAAGH,MAAM,CAACI,MAAzB,CADkB,CAElB;;AACAlB,IAAAA,OAAO,CAACmB,QAAR,CAAiBlB,SAAjB,EAA4BW,QAA5B,EAAsCK,SAAtC,EAAiDG,IAAjD,CAAuDC,GAAD,IAAS;AAC3D,YAAMC,QAAQ,GAAG;AACbC,QAAAA,GAAG,EAAEF,GAAG,CAACG,IAAJ,CAASD,GAAT,CAAaE,QAAb,EADQ;AAEbf,QAAAA,IAAI,EAAEC,QAFO;AAGba,QAAAA,IAAI,EAAEZ,QAHO;AAIbc,QAAAA,IAAI,EAAErB,IAAI,CAACqB,IAJE;AAKbC,QAAAA,IAAI,EAAG,IAAInB,IAAJ,EAAD,CAAaoB,cAAb;AALO,OAAjB;AAOA1B,MAAAA,QAAQ,CAACoB,QAAD,CAAR;AACH,KATD;AAUH,GAbD;;AAcAR,EAAAA,MAAM,CAACe,iBAAP,CAAyBxB,IAAzB;AACH","sourcesContent":["import {Buckets} from '@textile/hub'\n\nexport async function onDropToUpload(acceptedFiles: File[], buckets: Buckets, bucketKey: string, callback: Function) {\n    for (const accepted of acceptedFiles) {\n        await handleNewFile(accepted, buckets, bucketKey, callback)\n    }\n}\n\nasync function handleNewFile(file: File, buckets: Buckets, bucketKey: string, callback: Function) {\n    const fileSchema: { [key: string]: any } = {};\n    const now = new Date().getTime();\n    fileSchema['date'] = now;\n    fileSchema['name'] = `${file.name}`;\n    const filename = `${file.name}`;\n    const location = `${'/'}${filename}`;\n\n    if (!buckets || !bucketKey) {\n        throw new Error('No bucket client or root key')\n    }\n\n    const reader = new FileReader();\n    // reader.onabort = () => {\n    //     return reject(`file reading was aborted`);\n    // }\n    // reader.onerror = () => reject('file reading has failed')\n    reader.onload = () => {\n        const binaryStr = reader.result;\n        // Finally, push the full file to the bucket\n        buckets.pushPath(bucketKey, location, binaryStr).then((raw) => {\n            const metadata = {\n                cid: raw.path.cid.toString(),\n                name: filename,\n                path: location,\n                size: file.size,\n                date: (new Date()).toLocaleString()\n            };\n            callback(metadata);\n        })\n    };\n    reader.readAsArrayBuffer(file)\n}\n\n"]},"metadata":{},"sourceType":"module"}