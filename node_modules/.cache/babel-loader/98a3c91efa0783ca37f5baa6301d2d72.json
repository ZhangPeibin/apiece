{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst crypto = require(\"crypto\");\n\nconst SortableSet = require(\"../util/SortableSet\");\n\nconst GraphHelpers = require(\"../GraphHelpers\");\n\nconst {\n  isSubset\n} = require(\"../util/SetHelpers\");\n\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\n\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\n\nconst contextify = require(\"../util/identifier\").contextify;\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n\n\nconst deterministicGroupingForModules =\n/** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */\ndeterministicGrouping;\n\nconst hashFilename = name => {\n  return crypto.createHash(\"md4\").update(name).digest(\"hex\").slice(0, 8);\n};\n\nconst sortByIdentifier = (a, b) => {\n  if (a.identifier() > b.identifier()) return 1;\n  if (a.identifier() < b.identifier()) return -1;\n  return 0;\n};\n\nconst getRequests = chunk => {\n  let requests = 0;\n\n  for (const chunkGroup of chunk.groupsIterable) {\n    requests = Math.max(requests, chunkGroup.chunks.length);\n  }\n\n  return requests;\n};\n\nconst getModulesSize = modules => {\n  let sum = 0;\n\n  for (const m of modules) {\n    sum += m.size();\n  }\n\n  return sum;\n};\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\n\n\nconst isOverlap = (a, b) => {\n  for (const item of a) {\n    if (b.has(item)) return true;\n  }\n\n  return false;\n};\n\nconst compareEntries = (a, b) => {\n  // 1. by priority\n  const diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n  if (diffPriority) return diffPriority; // 2. by number of chunks\n\n  const diffCount = a.chunks.size - b.chunks.size;\n  if (diffCount) return diffCount; // 3. by size reduction\n\n  const aSizeReduce = a.size * (a.chunks.size - 1);\n  const bSizeReduce = b.size * (b.chunks.size - 1);\n  const diffSizeReduce = aSizeReduce - bSizeReduce;\n  if (diffSizeReduce) return diffSizeReduce; // 4. by cache group index\n\n  const indexDiff = a.cacheGroupIndex - b.cacheGroupIndex;\n  if (indexDiff) return indexDiff; // 5. by number of modules (to be able to compare by identifier)\n\n  const modulesA = a.modules;\n  const modulesB = b.modules;\n  const diff = modulesA.size - modulesB.size;\n  if (diff) return diff; // 6. by module identifiers\n\n  modulesA.sort();\n  modulesB.sort();\n  const aI = modulesA[Symbol.iterator]();\n  const bI = modulesB[Symbol.iterator](); // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    const aItem = aI.next();\n    const bItem = bI.next();\n    if (aItem.done) return 0;\n    const aModuleIdentifier = aItem.value.identifier();\n    const bModuleIdentifier = bItem.value.identifier();\n    if (aModuleIdentifier > bModuleIdentifier) return -1;\n    if (aModuleIdentifier < bModuleIdentifier) return 1;\n  }\n};\n\nconst compareNumbers = (a, b) => a - b;\n\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\n\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\n\nconst ALL_CHUNK_FILTER = chunk => true;\n\nmodule.exports = class SplitChunksPlugin {\n  constructor(options) {\n    this.options = SplitChunksPlugin.normalizeOptions(options);\n  }\n\n  static normalizeOptions(options = {}) {\n    return {\n      chunksFilter: SplitChunksPlugin.normalizeChunksFilter(options.chunks || \"all\"),\n      minSize: options.minSize || 0,\n      enforceSizeThreshold: options.enforceSizeThreshold || 0,\n      maxSize: options.maxSize || 0,\n      minChunks: options.minChunks || 1,\n      maxAsyncRequests: options.maxAsyncRequests || 1,\n      maxInitialRequests: options.maxInitialRequests || 1,\n      hidePathInfo: options.hidePathInfo || false,\n      filename: options.filename || undefined,\n      getCacheGroups: SplitChunksPlugin.normalizeCacheGroups({\n        cacheGroups: options.cacheGroups,\n        name: options.name,\n        automaticNameDelimiter: options.automaticNameDelimiter,\n        automaticNameMaxLength: options.automaticNameMaxLength\n      }),\n      automaticNameDelimiter: options.automaticNameDelimiter,\n      automaticNameMaxLength: options.automaticNameMaxLength || 109,\n      fallbackCacheGroup: SplitChunksPlugin.normalizeFallbackCacheGroup(options.fallbackCacheGroup || {}, options)\n    };\n  }\n\n  static normalizeName({\n    name,\n    automaticNameDelimiter,\n    automaticNamePrefix,\n    automaticNameMaxLength\n  }) {\n    if (name === true) {\n      /** @type {WeakMap<Chunk[], Record<string, string>>} */\n      const cache = new WeakMap();\n\n      const fn = (module, chunks, cacheGroup) => {\n        let cacheEntry = cache.get(chunks);\n\n        if (cacheEntry === undefined) {\n          cacheEntry = {};\n          cache.set(chunks, cacheEntry);\n        } else if (cacheGroup in cacheEntry) {\n          return cacheEntry[cacheGroup];\n        }\n\n        const names = chunks.map(c => c.name);\n\n        if (!names.every(Boolean)) {\n          cacheEntry[cacheGroup] = undefined;\n          return;\n        }\n\n        names.sort();\n        const prefix = typeof automaticNamePrefix === \"string\" ? automaticNamePrefix : cacheGroup;\n        const namePrefix = prefix ? prefix + automaticNameDelimiter : \"\";\n        let name = namePrefix + names.join(automaticNameDelimiter); // Filenames and paths can't be too long otherwise an\n        // ENAMETOOLONG error is raised. If the generated name if too\n        // long, it is truncated and a hash is appended. The limit has\n        // been set to 109 to prevent `[name].[chunkhash].[ext]` from\n        // generating a 256+ character string.\n\n        if (name.length > automaticNameMaxLength) {\n          const hashedFilename = hashFilename(name);\n          const sliceLength = automaticNameMaxLength - (automaticNameDelimiter.length + hashedFilename.length);\n          name = name.slice(0, sliceLength) + automaticNameDelimiter + hashedFilename;\n        }\n\n        cacheEntry[cacheGroup] = name;\n        return name;\n      };\n\n      return fn;\n    }\n\n    if (typeof name === \"string\") {\n      const fn = () => {\n        return name;\n      };\n\n      return fn;\n    }\n\n    if (typeof name === \"function\") return name;\n  }\n\n  static normalizeChunksFilter(chunks) {\n    if (chunks === \"initial\") {\n      return INITIAL_CHUNK_FILTER;\n    }\n\n    if (chunks === \"async\") {\n      return ASYNC_CHUNK_FILTER;\n    }\n\n    if (chunks === \"all\") {\n      return ALL_CHUNK_FILTER;\n    }\n\n    if (typeof chunks === \"function\") return chunks;\n  }\n\n  static normalizeFallbackCacheGroup({\n    minSize = undefined,\n    maxSize = undefined,\n    automaticNameDelimiter = undefined\n  }, {\n    minSize: defaultMinSize = undefined,\n    maxSize: defaultMaxSize = undefined,\n    automaticNameDelimiter: defaultAutomaticNameDelimiter = undefined\n  }) {\n    return {\n      minSize: typeof minSize === \"number\" ? minSize : defaultMinSize || 0,\n      maxSize: typeof maxSize === \"number\" ? maxSize : defaultMaxSize || 0,\n      automaticNameDelimiter: automaticNameDelimiter || defaultAutomaticNameDelimiter || \"~\"\n    };\n  }\n\n  static normalizeCacheGroups({\n    cacheGroups,\n    name,\n    automaticNameDelimiter,\n    automaticNameMaxLength\n  }) {\n    if (typeof cacheGroups === \"function\") {\n      // TODO webpack 5 remove this\n      if (cacheGroups.length !== 1) {\n        return module => cacheGroups(module, module.getChunks());\n      }\n\n      return cacheGroups;\n    }\n\n    if (cacheGroups && typeof cacheGroups === \"object\") {\n      const fn = module => {\n        let results;\n\n        for (const key of Object.keys(cacheGroups)) {\n          let option = cacheGroups[key];\n          if (option === false) continue;\n\n          if (option instanceof RegExp || typeof option === \"string\") {\n            option = {\n              test: option\n            };\n          }\n\n          if (typeof option === \"function\") {\n            let result = option(module);\n\n            if (result) {\n              if (results === undefined) results = [];\n\n              for (const r of Array.isArray(result) ? result : [result]) {\n                const result = Object.assign({\n                  key\n                }, r);\n                if (result.name) result.getName = () => result.name;\n\n                if (result.chunks) {\n                  result.chunksFilter = SplitChunksPlugin.normalizeChunksFilter(result.chunks);\n                }\n\n                results.push(result);\n              }\n            }\n          } else if (SplitChunksPlugin.checkTest(option.test, module)) {\n            if (results === undefined) results = [];\n            results.push({\n              key: key,\n              priority: option.priority,\n              getName: SplitChunksPlugin.normalizeName({\n                name: option.name || name,\n                automaticNameDelimiter: typeof option.automaticNameDelimiter === \"string\" ? option.automaticNameDelimiter : automaticNameDelimiter,\n                automaticNamePrefix: option.automaticNamePrefix,\n                automaticNameMaxLength: option.automaticNameMaxLength || automaticNameMaxLength\n              }) || (() => {}),\n              chunksFilter: SplitChunksPlugin.normalizeChunksFilter(option.chunks),\n              enforce: option.enforce,\n              minSize: option.minSize,\n              enforceSizeThreshold: option.enforceSizeThreshold,\n              maxSize: option.maxSize,\n              minChunks: option.minChunks,\n              maxAsyncRequests: option.maxAsyncRequests,\n              maxInitialRequests: option.maxInitialRequests,\n              filename: option.filename,\n              reuseExistingChunk: option.reuseExistingChunk\n            });\n          }\n        }\n\n        return results;\n      };\n\n      return fn;\n    }\n\n    const fn = () => {};\n\n    return fn;\n  }\n\n  static checkTest(test, module) {\n    if (test === undefined) return true;\n\n    if (typeof test === \"function\") {\n      if (test.length !== 1) {\n        return test(module, module.getChunks());\n      }\n\n      return test(module);\n    }\n\n    if (typeof test === \"boolean\") return test;\n\n    if (typeof test === \"string\") {\n      if (module.nameForCondition && module.nameForCondition().startsWith(test)) {\n        return true;\n      }\n\n      for (const chunk of module.chunksIterable) {\n        if (chunk.name && chunk.name.startsWith(test)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    if (test instanceof RegExp) {\n      if (module.nameForCondition && test.test(module.nameForCondition())) {\n        return true;\n      }\n\n      for (const chunk of module.chunksIterable) {\n        if (chunk.name && test.test(chunk.name)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    return false;\n  }\n  /**\n   * @param {Compiler} compiler webpack compiler\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\n      let alreadyOptimized = false;\n      compilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\n        alreadyOptimized = false;\n      });\n      compilation.hooks.optimizeChunksAdvanced.tap(\"SplitChunksPlugin\", chunks => {\n        if (alreadyOptimized) return;\n        alreadyOptimized = true; // Give each selected chunk an index (to create strings from chunks)\n\n        const indexMap = new Map();\n        let index = 1;\n\n        for (const chunk of chunks) {\n          indexMap.set(chunk, index++);\n        }\n\n        const getKey = chunks => {\n          return Array.from(chunks, c => indexMap.get(c)).sort(compareNumbers).join();\n        };\n        /** @type {Map<string, Set<Chunk>>} */\n\n\n        const chunkSetsInGraph = new Map();\n\n        for (const module of compilation.modules) {\n          const chunksKey = getKey(module.chunksIterable);\n\n          if (!chunkSetsInGraph.has(chunksKey)) {\n            chunkSetsInGraph.set(chunksKey, new Set(module.chunksIterable));\n          }\n        } // group these set of chunks by count\n        // to allow to check less sets via isSubset\n        // (only smaller sets can be subset)\n\n        /** @type {Map<number, Array<Set<Chunk>>>} */\n\n\n        const chunkSetsByCount = new Map();\n\n        for (const chunksSet of chunkSetsInGraph.values()) {\n          const count = chunksSet.size;\n          let array = chunkSetsByCount.get(count);\n\n          if (array === undefined) {\n            array = [];\n            chunkSetsByCount.set(count, array);\n          }\n\n          array.push(chunksSet);\n        } // Create a list of possible combinations\n\n\n        const combinationsCache = new Map(); // Map<string, Set<Chunk>[]>\n\n        const getCombinations = key => {\n          const chunksSet = chunkSetsInGraph.get(key);\n          var array = [chunksSet];\n\n          if (chunksSet.size > 1) {\n            for (const [count, setArray] of chunkSetsByCount) {\n              // \"equal\" is not needed because they would have been merge in the first step\n              if (count < chunksSet.size) {\n                for (const set of setArray) {\n                  if (isSubset(chunksSet, set)) {\n                    array.push(set);\n                  }\n                }\n              }\n            }\n          }\n\n          return array;\n        };\n        /**\n         * @typedef {Object} SelectedChunksResult\n         * @property {Chunk[]} chunks the list of chunks\n         * @property {string} key a key of the list\n         */\n\n        /**\n         * @typedef {function(Chunk): boolean} ChunkFilterFunction\n         */\n\n        /** @type {WeakMap<Set<Chunk>, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\n\n        const selectedChunksCacheByChunksSet = new WeakMap();\n        /**\n         * get list and key by applying the filter function to the list\n         * It is cached for performance reasons\n         * @param {Set<Chunk>} chunks list of chunks\n         * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n         * @returns {SelectedChunksResult} list and key\n         */\n\n        const getSelectedChunks = (chunks, chunkFilter) => {\n          let entry = selectedChunksCacheByChunksSet.get(chunks);\n\n          if (entry === undefined) {\n            entry = new WeakMap();\n            selectedChunksCacheByChunksSet.set(chunks, entry);\n          }\n          /** @type {SelectedChunksResult} */\n\n\n          let entry2 = entry.get(chunkFilter);\n\n          if (entry2 === undefined) {\n            /** @type {Chunk[]} */\n            const selectedChunks = [];\n\n            for (const chunk of chunks) {\n              if (chunkFilter(chunk)) selectedChunks.push(chunk);\n            }\n\n            entry2 = {\n              chunks: selectedChunks,\n              key: getKey(selectedChunks)\n            };\n            entry.set(chunkFilter, entry2);\n          }\n\n          return entry2;\n        };\n        /**\n         * @typedef {Object} ChunksInfoItem\n         * @property {SortableSet} modules\n         * @property {TODO} cacheGroup\n         * @property {number} cacheGroupIndex\n         * @property {string} name\n         * @property {number} size\n         * @property {Set<Chunk>} chunks\n         * @property {Set<Chunk>} reuseableChunks\n         * @property {Set<string>} chunksKeys\n         */\n        // Map a list of chunks to a list of modules\n        // For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\n        /** @type {Map<string, ChunksInfoItem>} */\n\n\n        const chunksInfoMap = new Map();\n        /**\n         * @param {TODO} cacheGroup the current cache group\n         * @param {number} cacheGroupIndex the index of the cache group of ordering\n         * @param {Chunk[]} selectedChunks chunks selected for this module\n         * @param {string} selectedChunksKey a key of selectedChunks\n         * @param {Module} module the current module\n         * @returns {void}\n         */\n\n        const addModuleToChunksInfoMap = (cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module) => {\n          // Break if minimum number of chunks is not reached\n          if (selectedChunks.length < cacheGroup.minChunks) return; // Determine name for split chunk\n\n          const name = cacheGroup.getName(module, selectedChunks, cacheGroup.key); // Create key for maps\n          // When it has a name we use the name as key\n          // Elsewise we create the key from chunks and cache group key\n          // This automatically merges equal names\n\n          const key = cacheGroup.key + (name ? ` name:${name}` : ` chunks:${selectedChunksKey}`); // Add module to maps\n\n          let info = chunksInfoMap.get(key);\n\n          if (info === undefined) {\n            chunksInfoMap.set(key, info = {\n              modules: new SortableSet(undefined, sortByIdentifier),\n              cacheGroup,\n              cacheGroupIndex,\n              name,\n              size: 0,\n              chunks: new Set(),\n              reuseableChunks: new Set(),\n              chunksKeys: new Set()\n            });\n          }\n\n          info.modules.add(module);\n          info.size += module.size();\n\n          if (!info.chunksKeys.has(selectedChunksKey)) {\n            info.chunksKeys.add(selectedChunksKey);\n\n            for (const chunk of selectedChunks) {\n              info.chunks.add(chunk);\n            }\n          }\n        }; // Walk through all modules\n\n\n        for (const module of compilation.modules) {\n          // Get cache group\n          let cacheGroups = this.options.getCacheGroups(module);\n\n          if (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n            continue;\n          } // Prepare some values\n\n\n          const chunksKey = getKey(module.chunksIterable);\n          let combs = combinationsCache.get(chunksKey);\n\n          if (combs === undefined) {\n            combs = getCombinations(chunksKey);\n            combinationsCache.set(chunksKey, combs);\n          }\n\n          let cacheGroupIndex = 0;\n\n          for (const cacheGroupSource of cacheGroups) {\n            const minSize = cacheGroupSource.minSize !== undefined ? cacheGroupSource.minSize : cacheGroupSource.enforce ? 0 : this.options.minSize;\n            const enforceSizeThreshold = cacheGroupSource.enforceSizeThreshold !== undefined ? cacheGroupSource.enforceSizeThreshold : cacheGroupSource.enforce ? 0 : this.options.enforceSizeThreshold;\n            const cacheGroup = {\n              key: cacheGroupSource.key,\n              priority: cacheGroupSource.priority || 0,\n              chunksFilter: cacheGroupSource.chunksFilter || this.options.chunksFilter,\n              minSize,\n              minSizeForMaxSize: cacheGroupSource.minSize !== undefined ? cacheGroupSource.minSize : this.options.minSize,\n              enforceSizeThreshold,\n              maxSize: cacheGroupSource.maxSize !== undefined ? cacheGroupSource.maxSize : cacheGroupSource.enforce ? 0 : this.options.maxSize,\n              minChunks: cacheGroupSource.minChunks !== undefined ? cacheGroupSource.minChunks : cacheGroupSource.enforce ? 1 : this.options.minChunks,\n              maxAsyncRequests: cacheGroupSource.maxAsyncRequests !== undefined ? cacheGroupSource.maxAsyncRequests : cacheGroupSource.enforce ? Infinity : this.options.maxAsyncRequests,\n              maxInitialRequests: cacheGroupSource.maxInitialRequests !== undefined ? cacheGroupSource.maxInitialRequests : cacheGroupSource.enforce ? Infinity : this.options.maxInitialRequests,\n              getName: cacheGroupSource.getName !== undefined ? cacheGroupSource.getName : this.options.getName,\n              filename: cacheGroupSource.filename !== undefined ? cacheGroupSource.filename : this.options.filename,\n              automaticNameDelimiter: cacheGroupSource.automaticNameDelimiter !== undefined ? cacheGroupSource.automaticNameDelimiter : this.options.automaticNameDelimiter,\n              reuseExistingChunk: cacheGroupSource.reuseExistingChunk,\n              _validateSize: minSize > 0,\n              _conditionalEnforce: enforceSizeThreshold > 0\n            }; // For all combination of chunk selection\n\n            for (const chunkCombination of combs) {\n              // Break if minimum number of chunks is not reached\n              if (chunkCombination.size < cacheGroup.minChunks) continue; // Select chunks by configuration\n\n              const {\n                chunks: selectedChunks,\n                key: selectedChunksKey\n              } = getSelectedChunks(chunkCombination, cacheGroup.chunksFilter);\n              addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module);\n            }\n\n            cacheGroupIndex++;\n          }\n        } // Filter items were size < minSize\n\n\n        for (const pair of chunksInfoMap) {\n          const info = pair[1];\n\n          if (info.cacheGroup._validateSize && info.size < info.cacheGroup.minSize) {\n            chunksInfoMap.delete(pair[0]);\n          }\n        }\n        /** @type {Map<Chunk, {minSize: number, maxSize: number, automaticNameDelimiter: string, keys: string[]}>} */\n\n\n        const maxSizeQueueMap = new Map();\n\n        while (chunksInfoMap.size > 0) {\n          // Find best matching entry\n          let bestEntryKey;\n          let bestEntry;\n\n          for (const pair of chunksInfoMap) {\n            const key = pair[0];\n            const info = pair[1];\n\n            if (bestEntry === undefined) {\n              bestEntry = info;\n              bestEntryKey = key;\n            } else if (compareEntries(bestEntry, info) < 0) {\n              bestEntry = info;\n              bestEntryKey = key;\n            }\n          }\n\n          const item = bestEntry;\n          chunksInfoMap.delete(bestEntryKey);\n          let chunkName = item.name; // Variable for the new chunk (lazy created)\n\n          /** @type {Chunk} */\n\n          let newChunk; // When no chunk name, check if we can reuse a chunk instead of creating a new one\n\n          let isReused = false;\n\n          if (item.cacheGroup.reuseExistingChunk) {\n            outer: for (const chunk of item.chunks) {\n              if (chunk.getNumberOfModules() !== item.modules.size) continue;\n              if (chunk.hasEntryModule()) continue;\n\n              for (const module of item.modules) {\n                if (!chunk.containsModule(module)) continue outer;\n              }\n\n              if (!newChunk || !newChunk.name) {\n                newChunk = chunk;\n              } else if (chunk.name && chunk.name.length < newChunk.name.length) {\n                newChunk = chunk;\n              } else if (chunk.name && chunk.name.length === newChunk.name.length && chunk.name < newChunk.name) {\n                newChunk = chunk;\n              }\n\n              chunkName = undefined;\n              isReused = true;\n            }\n          } // Check if maxRequests condition can be fulfilled\n\n\n          const selectedChunks = Array.from(item.chunks).filter(chunk => {\n            // skip if we address ourself\n            return (!chunkName || chunk.name !== chunkName) && chunk !== newChunk;\n          });\n          const enforced = item.cacheGroup._conditionalEnforce && item.size >= item.cacheGroup.enforceSizeThreshold; // Skip when no chunk selected\n\n          if (selectedChunks.length === 0) continue;\n          const usedChunks = new Set(selectedChunks); // Check if maxRequests condition can be fulfilled\n\n          if (!enforced && (Number.isFinite(item.cacheGroup.maxInitialRequests) || Number.isFinite(item.cacheGroup.maxAsyncRequests))) {\n            for (const chunk of usedChunks) {\n              // respect max requests\n              const maxRequests = chunk.isOnlyInitial() ? item.cacheGroup.maxInitialRequests : chunk.canBeInitial() ? Math.min(item.cacheGroup.maxInitialRequests, item.cacheGroup.maxAsyncRequests) : item.cacheGroup.maxAsyncRequests;\n\n              if (isFinite(maxRequests) && getRequests(chunk) >= maxRequests) {\n                usedChunks.delete(chunk);\n              }\n            }\n          }\n\n          outer: for (const chunk of usedChunks) {\n            for (const module of item.modules) {\n              if (chunk.containsModule(module)) continue outer;\n            }\n\n            usedChunks.delete(chunk);\n          } // Were some (invalid) chunks removed from usedChunks?\n          // => readd all modules to the queue, as things could have been changed\n\n\n          if (usedChunks.size < selectedChunks.length) {\n            if (usedChunks.size >= item.cacheGroup.minChunks) {\n              const chunksArr = Array.from(usedChunks);\n\n              for (const module of item.modules) {\n                addModuleToChunksInfoMap(item.cacheGroup, item.cacheGroupIndex, chunksArr, getKey(usedChunks), module);\n              }\n            }\n\n            continue;\n          } // Create the new chunk if not reusing one\n\n\n          if (!isReused) {\n            newChunk = compilation.addChunk(chunkName);\n          } // Walk through all chunks\n\n\n          for (const chunk of usedChunks) {\n            // Add graph connections for splitted chunk\n            chunk.split(newChunk);\n          } // Add a note to the chunk\n\n\n          newChunk.chunkReason = isReused ? \"reused as split chunk\" : \"split chunk\";\n\n          if (item.cacheGroup.key) {\n            newChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\n          }\n\n          if (chunkName) {\n            newChunk.chunkReason += ` (name: ${chunkName})`; // If the chosen name is already an entry point we remove the entry point\n\n            const entrypoint = compilation.entrypoints.get(chunkName);\n\n            if (entrypoint) {\n              compilation.entrypoints.delete(chunkName);\n              entrypoint.remove();\n              newChunk.entryModule = undefined;\n            }\n          }\n\n          if (item.cacheGroup.filename) {\n            if (!newChunk.isOnlyInitial()) {\n              throw new Error(\"SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. \" + \"The runtime can only handle loading of chunks which match the chunkFilename schema. \" + \"Using a custom filename would fail at runtime. \" + `(cache group: ${item.cacheGroup.key})`);\n            }\n\n            newChunk.filenameTemplate = item.cacheGroup.filename;\n          }\n\n          if (!isReused) {\n            // Add all modules to the new chunk\n            for (const module of item.modules) {\n              if (typeof module.chunkCondition === \"function\") {\n                if (!module.chunkCondition(newChunk)) continue;\n              } // Add module to new chunk\n\n\n              GraphHelpers.connectChunkAndModule(newChunk, module); // Remove module from used chunks\n\n              for (const chunk of usedChunks) {\n                chunk.removeModule(module);\n                module.rewriteChunkInReasons(chunk, [newChunk]);\n              }\n            }\n          } else {\n            // Remove all modules from used chunks\n            for (const module of item.modules) {\n              for (const chunk of usedChunks) {\n                chunk.removeModule(module);\n                module.rewriteChunkInReasons(chunk, [newChunk]);\n              }\n            }\n          }\n\n          if (item.cacheGroup.maxSize > 0) {\n            const oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n            maxSizeQueueMap.set(newChunk, {\n              minSize: Math.max(oldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0, item.cacheGroup.minSizeForMaxSize),\n              maxSize: Math.min(oldMaxSizeSettings ? oldMaxSizeSettings.maxSize : Infinity, item.cacheGroup.maxSize),\n              automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n              keys: oldMaxSizeSettings ? oldMaxSizeSettings.keys.concat(item.cacheGroup.key) : [item.cacheGroup.key]\n            });\n          } // remove all modules from other entries and update size\n\n\n          for (const [key, info] of chunksInfoMap) {\n            if (isOverlap(info.chunks, usedChunks)) {\n              // update modules and total size\n              // may remove it from the map when < minSize\n              const oldSize = info.modules.size;\n\n              for (const module of item.modules) {\n                info.modules.delete(module);\n              }\n\n              if (info.modules.size !== oldSize) {\n                if (info.modules.size === 0) {\n                  chunksInfoMap.delete(key);\n                  continue;\n                }\n\n                info.size = getModulesSize(info.modules);\n\n                if (info.cacheGroup._validateSize && info.size < info.cacheGroup.minSize) {\n                  chunksInfoMap.delete(key);\n                }\n\n                if (info.modules.size === 0) {\n                  chunksInfoMap.delete(key);\n                }\n              }\n            }\n          }\n        }\n\n        const incorrectMinMaxSizeSet = new Set(); // Make sure that maxSize is fulfilled\n\n        for (const chunk of compilation.chunks.slice()) {\n          const {\n            minSize,\n            maxSize,\n            automaticNameDelimiter,\n            keys\n          } = maxSizeQueueMap.get(chunk) || this.options.fallbackCacheGroup;\n          if (!maxSize) continue;\n\n          if (minSize > maxSize) {\n            const warningKey = `${keys && keys.join()} ${minSize} ${maxSize}`;\n\n            if (!incorrectMinMaxSizeSet.has(warningKey)) {\n              incorrectMinMaxSizeSet.add(warningKey);\n              compilation.warnings.push(new MinMaxSizeWarning(keys, minSize, maxSize));\n            }\n          }\n\n          const results = deterministicGroupingForModules({\n            maxSize: Math.max(minSize, maxSize),\n            minSize,\n            items: chunk.modulesIterable,\n\n            getKey(module) {\n              const ident = contextify(compilation.options.context, module.identifier());\n              const name = module.nameForCondition ? contextify(compilation.options.context, module.nameForCondition()) : ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n              const fullKey = name + automaticNameDelimiter + hashFilename(ident);\n              return fullKey.replace(/[\\\\/?]/g, \"_\");\n            },\n\n            getSize(module) {\n              return module.size();\n            }\n\n          });\n          results.sort((a, b) => {\n            if (a.key < b.key) return -1;\n            if (a.key > b.key) return 1;\n            return 0;\n          });\n\n          for (let i = 0; i < results.length; i++) {\n            const group = results[i];\n            const key = this.options.hidePathInfo ? hashFilename(group.key) : group.key;\n            let name = chunk.name ? chunk.name + automaticNameDelimiter + key : null;\n\n            if (name && name.length > 100) {\n              name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name);\n            }\n\n            let newPart;\n\n            if (i !== results.length - 1) {\n              newPart = compilation.addChunk(name);\n              chunk.split(newPart);\n              newPart.chunkReason = chunk.chunkReason; // Add all modules to the new chunk\n\n              for (const module of group.items) {\n                if (typeof module.chunkCondition === \"function\") {\n                  if (!module.chunkCondition(newPart)) continue;\n                } // Add module to new chunk\n\n\n                GraphHelpers.connectChunkAndModule(newPart, module); // Remove module from used chunks\n\n                chunk.removeModule(module);\n                module.rewriteChunkInReasons(chunk, [newPart]);\n              }\n            } else {\n              // change the chunk to be a part\n              newPart = chunk;\n              chunk.name = name;\n            }\n          }\n        }\n      });\n    });\n  }\n\n};","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/webpack/lib/optimize/SplitChunksPlugin.js"],"names":["crypto","require","SortableSet","GraphHelpers","isSubset","deterministicGrouping","MinMaxSizeWarning","contextify","deterministicGroupingForModules","hashFilename","name","createHash","update","digest","slice","sortByIdentifier","a","b","identifier","getRequests","chunk","requests","chunkGroup","groupsIterable","Math","max","chunks","length","getModulesSize","modules","sum","m","size","isOverlap","item","has","compareEntries","diffPriority","cacheGroup","priority","diffCount","aSizeReduce","bSizeReduce","diffSizeReduce","indexDiff","cacheGroupIndex","modulesA","modulesB","diff","sort","aI","Symbol","iterator","bI","aItem","next","bItem","done","aModuleIdentifier","value","bModuleIdentifier","compareNumbers","INITIAL_CHUNK_FILTER","canBeInitial","ASYNC_CHUNK_FILTER","ALL_CHUNK_FILTER","module","exports","SplitChunksPlugin","constructor","options","normalizeOptions","chunksFilter","normalizeChunksFilter","minSize","enforceSizeThreshold","maxSize","minChunks","maxAsyncRequests","maxInitialRequests","hidePathInfo","filename","undefined","getCacheGroups","normalizeCacheGroups","cacheGroups","automaticNameDelimiter","automaticNameMaxLength","fallbackCacheGroup","normalizeFallbackCacheGroup","normalizeName","automaticNamePrefix","cache","WeakMap","fn","cacheEntry","get","set","names","map","c","every","Boolean","prefix","namePrefix","join","hashedFilename","sliceLength","defaultMinSize","defaultMaxSize","defaultAutomaticNameDelimiter","getChunks","results","key","Object","keys","option","RegExp","test","result","r","Array","isArray","assign","getName","push","checkTest","enforce","reuseExistingChunk","nameForCondition","startsWith","chunksIterable","apply","compiler","hooks","thisCompilation","tap","compilation","alreadyOptimized","unseal","optimizeChunksAdvanced","indexMap","Map","index","getKey","from","chunkSetsInGraph","chunksKey","Set","chunkSetsByCount","chunksSet","values","count","array","combinationsCache","getCombinations","setArray","selectedChunksCacheByChunksSet","getSelectedChunks","chunkFilter","entry","entry2","selectedChunks","chunksInfoMap","addModuleToChunksInfoMap","selectedChunksKey","info","reuseableChunks","chunksKeys","add","combs","cacheGroupSource","minSizeForMaxSize","Infinity","_validateSize","_conditionalEnforce","chunkCombination","pair","delete","maxSizeQueueMap","bestEntryKey","bestEntry","chunkName","newChunk","isReused","outer","getNumberOfModules","hasEntryModule","containsModule","filter","enforced","usedChunks","Number","isFinite","maxRequests","isOnlyInitial","min","chunksArr","addChunk","split","chunkReason","entrypoint","entrypoints","remove","entryModule","Error","filenameTemplate","chunkCondition","connectChunkAndModule","removeModule","rewriteChunkInReasons","oldMaxSizeSettings","concat","oldSize","incorrectMinMaxSizeSet","warningKey","warnings","items","modulesIterable","ident","context","replace","fullKey","getSize","i","group","newPart"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst crypto = require(\"crypto\");\nconst SortableSet = require(\"../util/SortableSet\");\nconst GraphHelpers = require(\"../GraphHelpers\");\nconst { isSubset } = require(\"../util/SetHelpers\");\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\nconst contextify = require(\"../util/identifier\").contextify;\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n\nconst deterministicGroupingForModules = /** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */ (deterministicGrouping);\n\nconst hashFilename = name => {\n\treturn crypto\n\t\t.createHash(\"md4\")\n\t\t.update(name)\n\t\t.digest(\"hex\")\n\t\t.slice(0, 8);\n};\n\nconst sortByIdentifier = (a, b) => {\n\tif (a.identifier() > b.identifier()) return 1;\n\tif (a.identifier() < b.identifier()) return -1;\n\treturn 0;\n};\n\nconst getRequests = chunk => {\n\tlet requests = 0;\n\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\trequests = Math.max(requests, chunkGroup.chunks.length);\n\t}\n\treturn requests;\n};\n\nconst getModulesSize = modules => {\n\tlet sum = 0;\n\tfor (const m of modules) {\n\t\tsum += m.size();\n\t}\n\treturn sum;\n};\n\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\nconst isOverlap = (a, b) => {\n\tfor (const item of a) {\n\t\tif (b.has(item)) return true;\n\t}\n\treturn false;\n};\n\nconst compareEntries = (a, b) => {\n\t// 1. by priority\n\tconst diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n\tif (diffPriority) return diffPriority;\n\t// 2. by number of chunks\n\tconst diffCount = a.chunks.size - b.chunks.size;\n\tif (diffCount) return diffCount;\n\t// 3. by size reduction\n\tconst aSizeReduce = a.size * (a.chunks.size - 1);\n\tconst bSizeReduce = b.size * (b.chunks.size - 1);\n\tconst diffSizeReduce = aSizeReduce - bSizeReduce;\n\tif (diffSizeReduce) return diffSizeReduce;\n\t// 4. by cache group index\n\tconst indexDiff = a.cacheGroupIndex - b.cacheGroupIndex;\n\tif (indexDiff) return indexDiff;\n\t// 5. by number of modules (to be able to compare by identifier)\n\tconst modulesA = a.modules;\n\tconst modulesB = b.modules;\n\tconst diff = modulesA.size - modulesB.size;\n\tif (diff) return diff;\n\t// 6. by module identifiers\n\tmodulesA.sort();\n\tmodulesB.sort();\n\tconst aI = modulesA[Symbol.iterator]();\n\tconst bI = modulesB[Symbol.iterator]();\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tconst aItem = aI.next();\n\t\tconst bItem = bI.next();\n\t\tif (aItem.done) return 0;\n\t\tconst aModuleIdentifier = aItem.value.identifier();\n\t\tconst bModuleIdentifier = bItem.value.identifier();\n\t\tif (aModuleIdentifier > bModuleIdentifier) return -1;\n\t\tif (aModuleIdentifier < bModuleIdentifier) return 1;\n\t}\n};\n\nconst compareNumbers = (a, b) => a - b;\n\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\nconst ALL_CHUNK_FILTER = chunk => true;\n\nmodule.exports = class SplitChunksPlugin {\n\tconstructor(options) {\n\t\tthis.options = SplitChunksPlugin.normalizeOptions(options);\n\t}\n\n\tstatic normalizeOptions(options = {}) {\n\t\treturn {\n\t\t\tchunksFilter: SplitChunksPlugin.normalizeChunksFilter(\n\t\t\t\toptions.chunks || \"all\"\n\t\t\t),\n\t\t\tminSize: options.minSize || 0,\n\t\t\tenforceSizeThreshold: options.enforceSizeThreshold || 0,\n\t\t\tmaxSize: options.maxSize || 0,\n\t\t\tminChunks: options.minChunks || 1,\n\t\t\tmaxAsyncRequests: options.maxAsyncRequests || 1,\n\t\t\tmaxInitialRequests: options.maxInitialRequests || 1,\n\t\t\thidePathInfo: options.hidePathInfo || false,\n\t\t\tfilename: options.filename || undefined,\n\t\t\tgetCacheGroups: SplitChunksPlugin.normalizeCacheGroups({\n\t\t\t\tcacheGroups: options.cacheGroups,\n\t\t\t\tname: options.name,\n\t\t\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\t\t\tautomaticNameMaxLength: options.automaticNameMaxLength\n\t\t\t}),\n\t\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\t\tautomaticNameMaxLength: options.automaticNameMaxLength || 109,\n\t\t\tfallbackCacheGroup: SplitChunksPlugin.normalizeFallbackCacheGroup(\n\t\t\t\toptions.fallbackCacheGroup || {},\n\t\t\t\toptions\n\t\t\t)\n\t\t};\n\t}\n\n\tstatic normalizeName({\n\t\tname,\n\t\tautomaticNameDelimiter,\n\t\tautomaticNamePrefix,\n\t\tautomaticNameMaxLength\n\t}) {\n\t\tif (name === true) {\n\t\t\t/** @type {WeakMap<Chunk[], Record<string, string>>} */\n\t\t\tconst cache = new WeakMap();\n\t\t\tconst fn = (module, chunks, cacheGroup) => {\n\t\t\t\tlet cacheEntry = cache.get(chunks);\n\t\t\t\tif (cacheEntry === undefined) {\n\t\t\t\t\tcacheEntry = {};\n\t\t\t\t\tcache.set(chunks, cacheEntry);\n\t\t\t\t} else if (cacheGroup in cacheEntry) {\n\t\t\t\t\treturn cacheEntry[cacheGroup];\n\t\t\t\t}\n\t\t\t\tconst names = chunks.map(c => c.name);\n\t\t\t\tif (!names.every(Boolean)) {\n\t\t\t\t\tcacheEntry[cacheGroup] = undefined;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tnames.sort();\n\t\t\t\tconst prefix =\n\t\t\t\t\ttypeof automaticNamePrefix === \"string\"\n\t\t\t\t\t\t? automaticNamePrefix\n\t\t\t\t\t\t: cacheGroup;\n\t\t\t\tconst namePrefix = prefix ? prefix + automaticNameDelimiter : \"\";\n\t\t\t\tlet name = namePrefix + names.join(automaticNameDelimiter);\n\t\t\t\t// Filenames and paths can't be too long otherwise an\n\t\t\t\t// ENAMETOOLONG error is raised. If the generated name if too\n\t\t\t\t// long, it is truncated and a hash is appended. The limit has\n\t\t\t\t// been set to 109 to prevent `[name].[chunkhash].[ext]` from\n\t\t\t\t// generating a 256+ character string.\n\t\t\t\tif (name.length > automaticNameMaxLength) {\n\t\t\t\t\tconst hashedFilename = hashFilename(name);\n\t\t\t\t\tconst sliceLength =\n\t\t\t\t\t\tautomaticNameMaxLength -\n\t\t\t\t\t\t(automaticNameDelimiter.length + hashedFilename.length);\n\t\t\t\t\tname =\n\t\t\t\t\t\tname.slice(0, sliceLength) +\n\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\thashedFilename;\n\t\t\t\t}\n\t\t\t\tcacheEntry[cacheGroup] = name;\n\t\t\t\treturn name;\n\t\t\t};\n\t\t\treturn fn;\n\t\t}\n\t\tif (typeof name === \"string\") {\n\t\t\tconst fn = () => {\n\t\t\t\treturn name;\n\t\t\t};\n\t\t\treturn fn;\n\t\t}\n\t\tif (typeof name === \"function\") return name;\n\t}\n\n\tstatic normalizeChunksFilter(chunks) {\n\t\tif (chunks === \"initial\") {\n\t\t\treturn INITIAL_CHUNK_FILTER;\n\t\t}\n\t\tif (chunks === \"async\") {\n\t\t\treturn ASYNC_CHUNK_FILTER;\n\t\t}\n\t\tif (chunks === \"all\") {\n\t\t\treturn ALL_CHUNK_FILTER;\n\t\t}\n\t\tif (typeof chunks === \"function\") return chunks;\n\t}\n\n\tstatic normalizeFallbackCacheGroup(\n\t\t{\n\t\t\tminSize = undefined,\n\t\t\tmaxSize = undefined,\n\t\t\tautomaticNameDelimiter = undefined\n\t\t},\n\t\t{\n\t\t\tminSize: defaultMinSize = undefined,\n\t\t\tmaxSize: defaultMaxSize = undefined,\n\t\t\tautomaticNameDelimiter: defaultAutomaticNameDelimiter = undefined\n\t\t}\n\t) {\n\t\treturn {\n\t\t\tminSize: typeof minSize === \"number\" ? minSize : defaultMinSize || 0,\n\t\t\tmaxSize: typeof maxSize === \"number\" ? maxSize : defaultMaxSize || 0,\n\t\t\tautomaticNameDelimiter:\n\t\t\t\tautomaticNameDelimiter || defaultAutomaticNameDelimiter || \"~\"\n\t\t};\n\t}\n\n\tstatic normalizeCacheGroups({\n\t\tcacheGroups,\n\t\tname,\n\t\tautomaticNameDelimiter,\n\t\tautomaticNameMaxLength\n\t}) {\n\t\tif (typeof cacheGroups === \"function\") {\n\t\t\t// TODO webpack 5 remove this\n\t\t\tif (cacheGroups.length !== 1) {\n\t\t\t\treturn module => cacheGroups(module, module.getChunks());\n\t\t\t}\n\t\t\treturn cacheGroups;\n\t\t}\n\t\tif (cacheGroups && typeof cacheGroups === \"object\") {\n\t\t\tconst fn = module => {\n\t\t\t\tlet results;\n\t\t\t\tfor (const key of Object.keys(cacheGroups)) {\n\t\t\t\t\tlet option = cacheGroups[key];\n\t\t\t\t\tif (option === false) continue;\n\t\t\t\t\tif (option instanceof RegExp || typeof option === \"string\") {\n\t\t\t\t\t\toption = {\n\t\t\t\t\t\t\ttest: option\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof option === \"function\") {\n\t\t\t\t\t\tlet result = option(module);\n\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\tif (results === undefined) results = [];\n\t\t\t\t\t\t\tfor (const r of Array.isArray(result) ? result : [result]) {\n\t\t\t\t\t\t\t\tconst result = Object.assign({ key }, r);\n\t\t\t\t\t\t\t\tif (result.name) result.getName = () => result.name;\n\t\t\t\t\t\t\t\tif (result.chunks) {\n\t\t\t\t\t\t\t\t\tresult.chunksFilter = SplitChunksPlugin.normalizeChunksFilter(\n\t\t\t\t\t\t\t\t\t\tresult.chunks\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tresults.push(result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (SplitChunksPlugin.checkTest(option.test, module)) {\n\t\t\t\t\t\tif (results === undefined) results = [];\n\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\tkey: key,\n\t\t\t\t\t\t\tpriority: option.priority,\n\t\t\t\t\t\t\tgetName:\n\t\t\t\t\t\t\t\tSplitChunksPlugin.normalizeName({\n\t\t\t\t\t\t\t\t\tname: option.name || name,\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter:\n\t\t\t\t\t\t\t\t\t\ttypeof option.automaticNameDelimiter === \"string\"\n\t\t\t\t\t\t\t\t\t\t\t? option.automaticNameDelimiter\n\t\t\t\t\t\t\t\t\t\t\t: automaticNameDelimiter,\n\t\t\t\t\t\t\t\t\tautomaticNamePrefix: option.automaticNamePrefix,\n\t\t\t\t\t\t\t\t\tautomaticNameMaxLength:\n\t\t\t\t\t\t\t\t\t\toption.automaticNameMaxLength || automaticNameMaxLength\n\t\t\t\t\t\t\t\t}) || (() => {}),\n\t\t\t\t\t\t\tchunksFilter: SplitChunksPlugin.normalizeChunksFilter(\n\t\t\t\t\t\t\t\toption.chunks\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tenforce: option.enforce,\n\t\t\t\t\t\t\tminSize: option.minSize,\n\t\t\t\t\t\t\tenforceSizeThreshold: option.enforceSizeThreshold,\n\t\t\t\t\t\t\tmaxSize: option.maxSize,\n\t\t\t\t\t\t\tminChunks: option.minChunks,\n\t\t\t\t\t\t\tmaxAsyncRequests: option.maxAsyncRequests,\n\t\t\t\t\t\t\tmaxInitialRequests: option.maxInitialRequests,\n\t\t\t\t\t\t\tfilename: option.filename,\n\t\t\t\t\t\t\treuseExistingChunk: option.reuseExistingChunk\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t};\n\t\t\treturn fn;\n\t\t}\n\t\tconst fn = () => {};\n\t\treturn fn;\n\t}\n\n\tstatic checkTest(test, module) {\n\t\tif (test === undefined) return true;\n\t\tif (typeof test === \"function\") {\n\t\t\tif (test.length !== 1) {\n\t\t\t\treturn test(module, module.getChunks());\n\t\t\t}\n\t\t\treturn test(module);\n\t\t}\n\t\tif (typeof test === \"boolean\") return test;\n\t\tif (typeof test === \"string\") {\n\t\t\tif (\n\t\t\t\tmodule.nameForCondition &&\n\t\t\t\tmodule.nameForCondition().startsWith(test)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (const chunk of module.chunksIterable) {\n\t\t\t\tif (chunk.name && chunk.name.startsWith(test)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (test instanceof RegExp) {\n\t\t\tif (module.nameForCondition && test.test(module.nameForCondition())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (const chunk of module.chunksIterable) {\n\t\t\t\tif (chunk.name && test.test(chunk.name)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Compiler} compiler webpack compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\n\t\t\tlet alreadyOptimized = false;\n\t\t\tcompilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\n\t\t\t\talreadyOptimized = false;\n\t\t\t});\n\t\t\tcompilation.hooks.optimizeChunksAdvanced.tap(\n\t\t\t\t\"SplitChunksPlugin\",\n\t\t\t\tchunks => {\n\t\t\t\t\tif (alreadyOptimized) return;\n\t\t\t\t\talreadyOptimized = true;\n\t\t\t\t\t// Give each selected chunk an index (to create strings from chunks)\n\t\t\t\t\tconst indexMap = new Map();\n\t\t\t\t\tlet index = 1;\n\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\tindexMap.set(chunk, index++);\n\t\t\t\t\t}\n\t\t\t\t\tconst getKey = chunks => {\n\t\t\t\t\t\treturn Array.from(chunks, c => indexMap.get(c))\n\t\t\t\t\t\t\t.sort(compareNumbers)\n\t\t\t\t\t\t\t.join();\n\t\t\t\t\t};\n\t\t\t\t\t/** @type {Map<string, Set<Chunk>>} */\n\t\t\t\t\tconst chunkSetsInGraph = new Map();\n\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\tconst chunksKey = getKey(module.chunksIterable);\n\t\t\t\t\t\tif (!chunkSetsInGraph.has(chunksKey)) {\n\t\t\t\t\t\t\tchunkSetsInGraph.set(chunksKey, new Set(module.chunksIterable));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// group these set of chunks by count\n\t\t\t\t\t// to allow to check less sets via isSubset\n\t\t\t\t\t// (only smaller sets can be subset)\n\t\t\t\t\t/** @type {Map<number, Array<Set<Chunk>>>} */\n\t\t\t\t\tconst chunkSetsByCount = new Map();\n\t\t\t\t\tfor (const chunksSet of chunkSetsInGraph.values()) {\n\t\t\t\t\t\tconst count = chunksSet.size;\n\t\t\t\t\t\tlet array = chunkSetsByCount.get(count);\n\t\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\t\tchunkSetsByCount.set(count, array);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tarray.push(chunksSet);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create a list of possible combinations\n\t\t\t\t\tconst combinationsCache = new Map(); // Map<string, Set<Chunk>[]>\n\n\t\t\t\t\tconst getCombinations = key => {\n\t\t\t\t\t\tconst chunksSet = chunkSetsInGraph.get(key);\n\t\t\t\t\t\tvar array = [chunksSet];\n\t\t\t\t\t\tif (chunksSet.size > 1) {\n\t\t\t\t\t\t\tfor (const [count, setArray] of chunkSetsByCount) {\n\t\t\t\t\t\t\t\t// \"equal\" is not needed because they would have been merge in the first step\n\t\t\t\t\t\t\t\tif (count < chunksSet.size) {\n\t\t\t\t\t\t\t\t\tfor (const set of setArray) {\n\t\t\t\t\t\t\t\t\t\tif (isSubset(chunksSet, set)) {\n\t\t\t\t\t\t\t\t\t\t\tarray.push(set);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn array;\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} SelectedChunksResult\n\t\t\t\t\t * @property {Chunk[]} chunks the list of chunks\n\t\t\t\t\t * @property {string} key a key of the list\n\t\t\t\t\t */\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {function(Chunk): boolean} ChunkFilterFunction\n\t\t\t\t\t */\n\n\t\t\t\t\t/** @type {WeakMap<Set<Chunk>, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\t\t\t\t\tconst selectedChunksCacheByChunksSet = new WeakMap();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * get list and key by applying the filter function to the list\n\t\t\t\t\t * It is cached for performance reasons\n\t\t\t\t\t * @param {Set<Chunk>} chunks list of chunks\n\t\t\t\t\t * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n\t\t\t\t\t * @returns {SelectedChunksResult} list and key\n\t\t\t\t\t */\n\t\t\t\t\tconst getSelectedChunks = (chunks, chunkFilter) => {\n\t\t\t\t\t\tlet entry = selectedChunksCacheByChunksSet.get(chunks);\n\t\t\t\t\t\tif (entry === undefined) {\n\t\t\t\t\t\t\tentry = new WeakMap();\n\t\t\t\t\t\t\tselectedChunksCacheByChunksSet.set(chunks, entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/** @type {SelectedChunksResult} */\n\t\t\t\t\t\tlet entry2 = entry.get(chunkFilter);\n\t\t\t\t\t\tif (entry2 === undefined) {\n\t\t\t\t\t\t\t/** @type {Chunk[]} */\n\t\t\t\t\t\t\tconst selectedChunks = [];\n\t\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\t\tif (chunkFilter(chunk)) selectedChunks.push(chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry2 = {\n\t\t\t\t\t\t\t\tchunks: selectedChunks,\n\t\t\t\t\t\t\t\tkey: getKey(selectedChunks)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tentry.set(chunkFilter, entry2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn entry2;\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} ChunksInfoItem\n\t\t\t\t\t * @property {SortableSet} modules\n\t\t\t\t\t * @property {TODO} cacheGroup\n\t\t\t\t\t * @property {number} cacheGroupIndex\n\t\t\t\t\t * @property {string} name\n\t\t\t\t\t * @property {number} size\n\t\t\t\t\t * @property {Set<Chunk>} chunks\n\t\t\t\t\t * @property {Set<Chunk>} reuseableChunks\n\t\t\t\t\t * @property {Set<string>} chunksKeys\n\t\t\t\t\t */\n\n\t\t\t\t\t// Map a list of chunks to a list of modules\n\t\t\t\t\t// For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\t\t\t\t\t/** @type {Map<string, ChunksInfoItem>} */\n\t\t\t\t\tconst chunksInfoMap = new Map();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {TODO} cacheGroup the current cache group\n\t\t\t\t\t * @param {number} cacheGroupIndex the index of the cache group of ordering\n\t\t\t\t\t * @param {Chunk[]} selectedChunks chunks selected for this module\n\t\t\t\t\t * @param {string} selectedChunksKey a key of selectedChunks\n\t\t\t\t\t * @param {Module} module the current module\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst addModuleToChunksInfoMap = (\n\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\tmodule\n\t\t\t\t\t) => {\n\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\tif (selectedChunks.length < cacheGroup.minChunks) return;\n\t\t\t\t\t\t// Determine name for split chunk\n\t\t\t\t\t\tconst name = cacheGroup.getName(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\tcacheGroup.key\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Create key for maps\n\t\t\t\t\t\t// When it has a name we use the name as key\n\t\t\t\t\t\t// Elsewise we create the key from chunks and cache group key\n\t\t\t\t\t\t// This automatically merges equal names\n\t\t\t\t\t\tconst key =\n\t\t\t\t\t\t\tcacheGroup.key +\n\t\t\t\t\t\t\t(name ? ` name:${name}` : ` chunks:${selectedChunksKey}`);\n\t\t\t\t\t\t// Add module to maps\n\t\t\t\t\t\tlet info = chunksInfoMap.get(key);\n\t\t\t\t\t\tif (info === undefined) {\n\t\t\t\t\t\t\tchunksInfoMap.set(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t(info = {\n\t\t\t\t\t\t\t\t\tmodules: new SortableSet(undefined, sortByIdentifier),\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\tsize: 0,\n\t\t\t\t\t\t\t\t\tchunks: new Set(),\n\t\t\t\t\t\t\t\t\treuseableChunks: new Set(),\n\t\t\t\t\t\t\t\t\tchunksKeys: new Set()\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinfo.modules.add(module);\n\t\t\t\t\t\tinfo.size += module.size();\n\t\t\t\t\t\tif (!info.chunksKeys.has(selectedChunksKey)) {\n\t\t\t\t\t\t\tinfo.chunksKeys.add(selectedChunksKey);\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tinfo.chunks.add(chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// Walk through all modules\n\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t// Get cache group\n\t\t\t\t\t\tlet cacheGroups = this.options.getCacheGroups(module);\n\t\t\t\t\t\tif (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prepare some values\n\t\t\t\t\t\tconst chunksKey = getKey(module.chunksIterable);\n\t\t\t\t\t\tlet combs = combinationsCache.get(chunksKey);\n\t\t\t\t\t\tif (combs === undefined) {\n\t\t\t\t\t\t\tcombs = getCombinations(chunksKey);\n\t\t\t\t\t\t\tcombinationsCache.set(chunksKey, combs);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet cacheGroupIndex = 0;\n\t\t\t\t\t\tfor (const cacheGroupSource of cacheGroups) {\n\t\t\t\t\t\t\tconst minSize =\n\t\t\t\t\t\t\t\tcacheGroupSource.minSize !== undefined\n\t\t\t\t\t\t\t\t\t? cacheGroupSource.minSize\n\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t\t: this.options.minSize;\n\t\t\t\t\t\t\tconst enforceSizeThreshold =\n\t\t\t\t\t\t\t\tcacheGroupSource.enforceSizeThreshold !== undefined\n\t\t\t\t\t\t\t\t\t? cacheGroupSource.enforceSizeThreshold\n\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t\t: this.options.enforceSizeThreshold;\n\t\t\t\t\t\t\tconst cacheGroup = {\n\t\t\t\t\t\t\t\tkey: cacheGroupSource.key,\n\t\t\t\t\t\t\t\tpriority: cacheGroupSource.priority || 0,\n\t\t\t\t\t\t\t\tchunksFilter:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.chunksFilter || this.options.chunksFilter,\n\t\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\t\tminSizeForMaxSize:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.minSize !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.minSize\n\t\t\t\t\t\t\t\t\t\t: this.options.minSize,\n\t\t\t\t\t\t\t\tenforceSizeThreshold,\n\t\t\t\t\t\t\t\tmaxSize:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.maxSize !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.maxSize\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t\t\t: this.options.maxSize,\n\t\t\t\t\t\t\t\tminChunks:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.minChunks !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.minChunks\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? 1\n\t\t\t\t\t\t\t\t\t\t: this.options.minChunks,\n\t\t\t\t\t\t\t\tmaxAsyncRequests:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.maxAsyncRequests !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.maxAsyncRequests\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? Infinity\n\t\t\t\t\t\t\t\t\t\t: this.options.maxAsyncRequests,\n\t\t\t\t\t\t\t\tmaxInitialRequests:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.maxInitialRequests !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.maxInitialRequests\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? Infinity\n\t\t\t\t\t\t\t\t\t\t: this.options.maxInitialRequests,\n\t\t\t\t\t\t\t\tgetName:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.getName !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.getName\n\t\t\t\t\t\t\t\t\t\t: this.options.getName,\n\t\t\t\t\t\t\t\tfilename:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.filename !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.filename\n\t\t\t\t\t\t\t\t\t\t: this.options.filename,\n\t\t\t\t\t\t\t\tautomaticNameDelimiter:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.automaticNameDelimiter !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.automaticNameDelimiter\n\t\t\t\t\t\t\t\t\t\t: this.options.automaticNameDelimiter,\n\t\t\t\t\t\t\t\treuseExistingChunk: cacheGroupSource.reuseExistingChunk,\n\t\t\t\t\t\t\t\t_validateSize: minSize > 0,\n\t\t\t\t\t\t\t\t_conditionalEnforce: enforceSizeThreshold > 0\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t// For all combination of chunk selection\n\t\t\t\t\t\t\tfor (const chunkCombination of combs) {\n\t\t\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\t\t\tif (chunkCombination.size < cacheGroup.minChunks) continue;\n\t\t\t\t\t\t\t\t// Select chunks by configuration\n\t\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\t\tchunks: selectedChunks,\n\t\t\t\t\t\t\t\t\tkey: selectedChunksKey\n\t\t\t\t\t\t\t\t} = getSelectedChunks(\n\t\t\t\t\t\t\t\t\tchunkCombination,\n\t\t\t\t\t\t\t\t\tcacheGroup.chunksFilter\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcacheGroupIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Filter items were size < minSize\n\t\t\t\t\tfor (const pair of chunksInfoMap) {\n\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tinfo.cacheGroup._validateSize &&\n\t\t\t\t\t\t\tinfo.size < info.cacheGroup.minSize\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tchunksInfoMap.delete(pair[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/** @type {Map<Chunk, {minSize: number, maxSize: number, automaticNameDelimiter: string, keys: string[]}>} */\n\t\t\t\t\tconst maxSizeQueueMap = new Map();\n\n\t\t\t\t\twhile (chunksInfoMap.size > 0) {\n\t\t\t\t\t\t// Find best matching entry\n\t\t\t\t\t\tlet bestEntryKey;\n\t\t\t\t\t\tlet bestEntry;\n\t\t\t\t\t\tfor (const pair of chunksInfoMap) {\n\t\t\t\t\t\t\tconst key = pair[0];\n\t\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\t\tif (bestEntry === undefined) {\n\t\t\t\t\t\t\t\tbestEntry = info;\n\t\t\t\t\t\t\t\tbestEntryKey = key;\n\t\t\t\t\t\t\t} else if (compareEntries(bestEntry, info) < 0) {\n\t\t\t\t\t\t\t\tbestEntry = info;\n\t\t\t\t\t\t\t\tbestEntryKey = key;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst item = bestEntry;\n\t\t\t\t\t\tchunksInfoMap.delete(bestEntryKey);\n\n\t\t\t\t\t\tlet chunkName = item.name;\n\t\t\t\t\t\t// Variable for the new chunk (lazy created)\n\t\t\t\t\t\t/** @type {Chunk} */\n\t\t\t\t\t\tlet newChunk;\n\t\t\t\t\t\t// When no chunk name, check if we can reuse a chunk instead of creating a new one\n\t\t\t\t\t\tlet isReused = false;\n\t\t\t\t\t\tif (item.cacheGroup.reuseExistingChunk) {\n\t\t\t\t\t\t\touter: for (const chunk of item.chunks) {\n\t\t\t\t\t\t\t\tif (chunk.getNumberOfModules() !== item.modules.size) continue;\n\t\t\t\t\t\t\t\tif (chunk.hasEntryModule()) continue;\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tif (!chunk.containsModule(module)) continue outer;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!newChunk || !newChunk.name) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length < newChunk.name.length\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length === newChunk.name.length &&\n\t\t\t\t\t\t\t\t\tchunk.name < newChunk.name\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchunkName = undefined;\n\t\t\t\t\t\t\t\tisReused = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Check if maxRequests condition can be fulfilled\n\n\t\t\t\t\t\tconst selectedChunks = Array.from(item.chunks).filter(chunk => {\n\t\t\t\t\t\t\t// skip if we address ourself\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t(!chunkName || chunk.name !== chunkName) && chunk !== newChunk\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst enforced =\n\t\t\t\t\t\t\titem.cacheGroup._conditionalEnforce &&\n\t\t\t\t\t\t\titem.size >= item.cacheGroup.enforceSizeThreshold;\n\n\t\t\t\t\t\t// Skip when no chunk selected\n\t\t\t\t\t\tif (selectedChunks.length === 0) continue;\n\n\t\t\t\t\t\tconst usedChunks = new Set(selectedChunks);\n\n\t\t\t\t\t\t// Check if maxRequests condition can be fulfilled\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!enforced &&\n\t\t\t\t\t\t\t(Number.isFinite(item.cacheGroup.maxInitialRequests) ||\n\t\t\t\t\t\t\t\tNumber.isFinite(item.cacheGroup.maxAsyncRequests))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t// respect max requests\n\t\t\t\t\t\t\t\tconst maxRequests = chunk.isOnlyInitial()\n\t\t\t\t\t\t\t\t\t? item.cacheGroup.maxInitialRequests\n\t\t\t\t\t\t\t\t\t: chunk.canBeInitial()\n\t\t\t\t\t\t\t\t\t? Math.min(\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxInitialRequests,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxAsyncRequests\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxAsyncRequests;\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tisFinite(maxRequests) &&\n\t\t\t\t\t\t\t\t\tgetRequests(chunk) >= maxRequests\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tusedChunks.delete(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\touter: for (const chunk of usedChunks) {\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (chunk.containsModule(module)) continue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tusedChunks.delete(chunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Were some (invalid) chunks removed from usedChunks?\n\t\t\t\t\t\t// => readd all modules to the queue, as things could have been changed\n\t\t\t\t\t\tif (usedChunks.size < selectedChunks.length) {\n\t\t\t\t\t\t\tif (usedChunks.size >= item.cacheGroup.minChunks) {\n\t\t\t\t\t\t\t\tconst chunksArr = Array.from(usedChunks);\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\t\titem.cacheGroup,\n\t\t\t\t\t\t\t\t\t\titem.cacheGroupIndex,\n\t\t\t\t\t\t\t\t\t\tchunksArr,\n\t\t\t\t\t\t\t\t\t\tgetKey(usedChunks),\n\t\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Create the new chunk if not reusing one\n\t\t\t\t\t\tif (!isReused) {\n\t\t\t\t\t\t\tnewChunk = compilation.addChunk(chunkName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Walk through all chunks\n\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t// Add graph connections for splitted chunk\n\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add a note to the chunk\n\t\t\t\t\t\tnewChunk.chunkReason = isReused\n\t\t\t\t\t\t\t? \"reused as split chunk\"\n\t\t\t\t\t\t\t: \"split chunk\";\n\t\t\t\t\t\tif (item.cacheGroup.key) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (name: ${chunkName})`;\n\t\t\t\t\t\t\t// If the chosen name is already an entry point we remove the entry point\n\t\t\t\t\t\t\tconst entrypoint = compilation.entrypoints.get(chunkName);\n\t\t\t\t\t\t\tif (entrypoint) {\n\t\t\t\t\t\t\t\tcompilation.entrypoints.delete(chunkName);\n\t\t\t\t\t\t\t\tentrypoint.remove();\n\t\t\t\t\t\t\t\tnewChunk.entryModule = undefined;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (item.cacheGroup.filename) {\n\t\t\t\t\t\t\tif (!newChunk.isOnlyInitial()) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\"SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. \" +\n\t\t\t\t\t\t\t\t\t\t\"The runtime can only handle loading of chunks which match the chunkFilename schema. \" +\n\t\t\t\t\t\t\t\t\t\t\"Using a custom filename would fail at runtime. \" +\n\t\t\t\t\t\t\t\t\t\t`(cache group: ${item.cacheGroup.key})`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnewChunk.filenameTemplate = item.cacheGroup.filename;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!isReused) {\n\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (typeof module.chunkCondition === \"function\") {\n\t\t\t\t\t\t\t\t\tif (!module.chunkCondition(newChunk)) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\tGraphHelpers.connectChunkAndModule(newChunk, module);\n\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t\t\t\t\tmodule.rewriteChunkInReasons(chunk, [newChunk]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Remove all modules from used chunks\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t\t\t\t\tmodule.rewriteChunkInReasons(chunk, [newChunk]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (item.cacheGroup.maxSize > 0) {\n\t\t\t\t\t\t\tconst oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n\t\t\t\t\t\t\tmaxSizeQueueMap.set(newChunk, {\n\t\t\t\t\t\t\t\tminSize: Math.max(\n\t\t\t\t\t\t\t\t\toldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0,\n\t\t\t\t\t\t\t\t\titem.cacheGroup.minSizeForMaxSize\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tmaxSize: Math.min(\n\t\t\t\t\t\t\t\t\toldMaxSizeSettings ? oldMaxSizeSettings.maxSize : Infinity,\n\t\t\t\t\t\t\t\t\titem.cacheGroup.maxSize\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tautomaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n\t\t\t\t\t\t\t\tkeys: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? oldMaxSizeSettings.keys.concat(item.cacheGroup.key)\n\t\t\t\t\t\t\t\t\t: [item.cacheGroup.key]\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// remove all modules from other entries and update size\n\t\t\t\t\t\tfor (const [key, info] of chunksInfoMap) {\n\t\t\t\t\t\t\tif (isOverlap(info.chunks, usedChunks)) {\n\t\t\t\t\t\t\t\t// update modules and total size\n\t\t\t\t\t\t\t\t// may remove it from the map when < minSize\n\t\t\t\t\t\t\t\tconst oldSize = info.modules.size;\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tinfo.modules.delete(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (info.modules.size !== oldSize) {\n\t\t\t\t\t\t\t\t\tif (info.modules.size === 0) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tinfo.size = getModulesSize(info.modules);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tinfo.cacheGroup._validateSize &&\n\t\t\t\t\t\t\t\t\t\tinfo.size < info.cacheGroup.minSize\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (info.modules.size === 0) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst incorrectMinMaxSizeSet = new Set();\n\n\t\t\t\t\t// Make sure that maxSize is fulfilled\n\t\t\t\t\tfor (const chunk of compilation.chunks.slice()) {\n\t\t\t\t\t\tconst { minSize, maxSize, automaticNameDelimiter, keys } =\n\t\t\t\t\t\t\tmaxSizeQueueMap.get(chunk) || this.options.fallbackCacheGroup;\n\t\t\t\t\t\tif (!maxSize) continue;\n\t\t\t\t\t\tif (minSize > maxSize) {\n\t\t\t\t\t\t\tconst warningKey = `${keys && keys.join()} ${minSize} ${maxSize}`;\n\t\t\t\t\t\t\tif (!incorrectMinMaxSizeSet.has(warningKey)) {\n\t\t\t\t\t\t\t\tincorrectMinMaxSizeSet.add(warningKey);\n\t\t\t\t\t\t\t\tcompilation.warnings.push(\n\t\t\t\t\t\t\t\t\tnew MinMaxSizeWarning(keys, minSize, maxSize)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst results = deterministicGroupingForModules({\n\t\t\t\t\t\t\tmaxSize: Math.max(minSize, maxSize),\n\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\titems: chunk.modulesIterable,\n\t\t\t\t\t\t\tgetKey(module) {\n\t\t\t\t\t\t\t\tconst ident = contextify(\n\t\t\t\t\t\t\t\t\tcompilation.options.context,\n\t\t\t\t\t\t\t\t\tmodule.identifier()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst name = module.nameForCondition\n\t\t\t\t\t\t\t\t\t? contextify(\n\t\t\t\t\t\t\t\t\t\t\tcompilation.options.context,\n\t\t\t\t\t\t\t\t\t\t\tmodule.nameForCondition()\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n\t\t\t\t\t\t\t\tconst fullKey =\n\t\t\t\t\t\t\t\t\tname + automaticNameDelimiter + hashFilename(ident);\n\t\t\t\t\t\t\t\treturn fullKey.replace(/[\\\\/?]/g, \"_\");\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgetSize(module) {\n\t\t\t\t\t\t\t\treturn module.size();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresults.sort((a, b) => {\n\t\t\t\t\t\t\tif (a.key < b.key) return -1;\n\t\t\t\t\t\t\tif (a.key > b.key) return 1;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\t\t\t\t\tconst group = results[i];\n\t\t\t\t\t\t\tconst key = this.options.hidePathInfo\n\t\t\t\t\t\t\t\t? hashFilename(group.key)\n\t\t\t\t\t\t\t\t: group.key;\n\t\t\t\t\t\t\tlet name = chunk.name\n\t\t\t\t\t\t\t\t? chunk.name + automaticNameDelimiter + key\n\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\tif (name && name.length > 100) {\n\t\t\t\t\t\t\t\tname =\n\t\t\t\t\t\t\t\t\tname.slice(0, 100) +\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\t\t\t\thashFilename(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet newPart;\n\t\t\t\t\t\t\tif (i !== results.length - 1) {\n\t\t\t\t\t\t\t\tnewPart = compilation.addChunk(name);\n\t\t\t\t\t\t\t\tchunk.split(newPart);\n\t\t\t\t\t\t\t\tnewPart.chunkReason = chunk.chunkReason;\n\t\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\t\tfor (const module of group.items) {\n\t\t\t\t\t\t\t\t\tif (typeof module.chunkCondition === \"function\") {\n\t\t\t\t\t\t\t\t\t\tif (!module.chunkCondition(newPart)) continue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\t\tGraphHelpers.connectChunkAndModule(newPart, module);\n\t\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t\t\t\t\tmodule.rewriteChunkInReasons(chunk, [newPart]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// change the chunk to be a part\n\t\t\t\t\t\t\t\tnewPart = chunk;\n\t\t\t\t\t\t\t\tchunk.name = name;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}