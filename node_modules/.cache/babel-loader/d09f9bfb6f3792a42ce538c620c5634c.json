{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst types = require('./types');\n\nconst bip66 = require('bip66');\n\nconst typeforce = require('typeforce');\n\nconst ZERO = Buffer.alloc(1, 0);\n\nfunction toDER(x) {\n  let i = 0;\n\n  while (x[i] === 0) ++i;\n\n  if (i === x.length) return ZERO;\n  x = x.slice(i);\n  if (x[0] & 0x80) return Buffer.concat([ZERO, x], 1 + x.length);\n  return x;\n}\n\nfunction fromDER(x) {\n  if (x[0] === 0x00) x = x.slice(1);\n  const buffer = Buffer.alloc(32, 0);\n  const bstart = Math.max(0, 32 - x.length);\n  x.copy(buffer, bstart);\n  return buffer;\n} // BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\n\n\nfunction decode(buffer) {\n  const hashType = buffer.readUInt8(buffer.length - 1);\n  const hashTypeMod = hashType & ~0x80;\n  if (hashTypeMod <= 0 || hashTypeMod >= 4) throw new Error('Invalid hashType ' + hashType);\n  const decoded = bip66.decode(buffer.slice(0, -1));\n  const r = fromDER(decoded.r);\n  const s = fromDER(decoded.s);\n  const signature = Buffer.concat([r, s], 64);\n  return {\n    signature,\n    hashType\n  };\n}\n\nexports.decode = decode;\n\nfunction encode(signature, hashType) {\n  typeforce({\n    signature: types.BufferN(64),\n    hashType: types.UInt8\n  }, {\n    signature,\n    hashType\n  });\n  const hashTypeMod = hashType & ~0x80;\n  if (hashTypeMod <= 0 || hashTypeMod >= 4) throw new Error('Invalid hashType ' + hashType);\n  const hashTypeBuffer = Buffer.allocUnsafe(1);\n  hashTypeBuffer.writeUInt8(hashType, 0);\n  const r = toDER(signature.slice(0, 32));\n  const s = toDER(signature.slice(32, 64));\n  return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);\n}\n\nexports.encode = encode;","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/bitcoinjs-lib/src/script_signature.js"],"names":["Object","defineProperty","exports","value","types","require","bip66","typeforce","ZERO","Buffer","alloc","toDER","x","i","length","slice","concat","fromDER","buffer","bstart","Math","max","copy","decode","hashType","readUInt8","hashTypeMod","Error","decoded","r","s","signature","encode","BufferN","UInt8","hashTypeBuffer","allocUnsafe","writeUInt8"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst types = require('./types');\nconst bip66 = require('bip66');\nconst typeforce = require('typeforce');\nconst ZERO = Buffer.alloc(1, 0);\nfunction toDER(x) {\n  let i = 0;\n  while (x[i] === 0) ++i;\n  if (i === x.length) return ZERO;\n  x = x.slice(i);\n  if (x[0] & 0x80) return Buffer.concat([ZERO, x], 1 + x.length);\n  return x;\n}\nfunction fromDER(x) {\n  if (x[0] === 0x00) x = x.slice(1);\n  const buffer = Buffer.alloc(32, 0);\n  const bstart = Math.max(0, 32 - x.length);\n  x.copy(buffer, bstart);\n  return buffer;\n}\n// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\nfunction decode(buffer) {\n  const hashType = buffer.readUInt8(buffer.length - 1);\n  const hashTypeMod = hashType & ~0x80;\n  if (hashTypeMod <= 0 || hashTypeMod >= 4)\n    throw new Error('Invalid hashType ' + hashType);\n  const decoded = bip66.decode(buffer.slice(0, -1));\n  const r = fromDER(decoded.r);\n  const s = fromDER(decoded.s);\n  const signature = Buffer.concat([r, s], 64);\n  return { signature, hashType };\n}\nexports.decode = decode;\nfunction encode(signature, hashType) {\n  typeforce(\n    {\n      signature: types.BufferN(64),\n      hashType: types.UInt8,\n    },\n    { signature, hashType },\n  );\n  const hashTypeMod = hashType & ~0x80;\n  if (hashTypeMod <= 0 || hashTypeMod >= 4)\n    throw new Error('Invalid hashType ' + hashType);\n  const hashTypeBuffer = Buffer.allocUnsafe(1);\n  hashTypeBuffer.writeUInt8(hashType, 0);\n  const r = toDER(signature.slice(0, 32));\n  const s = toDER(signature.slice(32, 64));\n  return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);\n}\nexports.encode = encode;\n"]},"metadata":{},"sourceType":"script"}