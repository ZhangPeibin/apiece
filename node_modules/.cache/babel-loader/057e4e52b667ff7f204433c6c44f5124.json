{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst bufferutils_1 = require('./bufferutils');\n\nconst bcrypto = require('./crypto');\n\nconst bscript = require('./script');\n\nconst script_1 = require('./script');\n\nconst types = require('./types');\n\nconst typeforce = require('typeforce');\n\nconst varuint = require('varuint-bitcoin');\n\nfunction varSliceSize(someScript) {\n  const length = someScript.length;\n  return varuint.encodingLength(length) + length;\n}\n\nfunction vectorSize(someVector) {\n  const length = someVector.length;\n  return varuint.encodingLength(length) + someVector.reduce((sum, witness) => {\n    return sum + varSliceSize(witness);\n  }, 0);\n}\n\nconst EMPTY_SCRIPT = Buffer.allocUnsafe(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex');\nconst ONE = Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex');\nconst VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nconst BLANK_OUTPUT = {\n  script: EMPTY_SCRIPT,\n  valueBuffer: VALUE_UINT64_MAX\n};\n\nfunction isOutput(out) {\n  return out.value !== undefined;\n}\n\nclass Transaction {\n  constructor() {\n    this.version = 1;\n    this.locktime = 0;\n    this.ins = [];\n    this.outs = [];\n  }\n\n  static fromBuffer(buffer, _NO_STRICT) {\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const tx = new Transaction();\n    tx.version = bufferReader.readInt32();\n    const marker = bufferReader.readUInt8();\n    const flag = bufferReader.readUInt8();\n    let hasWitnesses = false;\n\n    if (marker === Transaction.ADVANCED_TRANSACTION_MARKER && flag === Transaction.ADVANCED_TRANSACTION_FLAG) {\n      hasWitnesses = true;\n    } else {\n      bufferReader.offset -= 2;\n    }\n\n    const vinLen = bufferReader.readVarInt();\n\n    for (let i = 0; i < vinLen; ++i) {\n      tx.ins.push({\n        hash: bufferReader.readSlice(32),\n        index: bufferReader.readUInt32(),\n        script: bufferReader.readVarSlice(),\n        sequence: bufferReader.readUInt32(),\n        witness: EMPTY_WITNESS\n      });\n    }\n\n    const voutLen = bufferReader.readVarInt();\n\n    for (let i = 0; i < voutLen; ++i) {\n      tx.outs.push({\n        value: bufferReader.readUInt64(),\n        script: bufferReader.readVarSlice()\n      });\n    }\n\n    if (hasWitnesses) {\n      for (let i = 0; i < vinLen; ++i) {\n        tx.ins[i].witness = bufferReader.readVector();\n      } // was this pointless?\n\n\n      if (!tx.hasWitnesses()) throw new Error('Transaction has superfluous witness data');\n    }\n\n    tx.locktime = bufferReader.readUInt32();\n    if (_NO_STRICT) return tx;\n    if (bufferReader.offset !== buffer.length) throw new Error('Transaction has unexpected data');\n    return tx;\n  }\n\n  static fromHex(hex) {\n    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);\n  }\n\n  static isCoinbaseHash(buffer) {\n    typeforce(types.Hash256bit, buffer);\n\n    for (let i = 0; i < 32; ++i) {\n      if (buffer[i] !== 0) return false;\n    }\n\n    return true;\n  }\n\n  isCoinbase() {\n    return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);\n  }\n\n  addInput(hash, index, sequence, scriptSig) {\n    typeforce(types.tuple(types.Hash256bit, types.UInt32, types.maybe(types.UInt32), types.maybe(types.Buffer)), arguments);\n\n    if (types.Null(sequence)) {\n      sequence = Transaction.DEFAULT_SEQUENCE;\n    } // Add the input and return the input's index\n\n\n    return this.ins.push({\n      hash,\n      index,\n      script: scriptSig || EMPTY_SCRIPT,\n      sequence: sequence,\n      witness: EMPTY_WITNESS\n    }) - 1;\n  }\n\n  addOutput(scriptPubKey, value) {\n    typeforce(types.tuple(types.Buffer, types.Satoshi), arguments); // Add the output and return the output's index\n\n    return this.outs.push({\n      script: scriptPubKey,\n      value\n    }) - 1;\n  }\n\n  hasWitnesses() {\n    return this.ins.some(x => {\n      return x.witness.length !== 0;\n    });\n  }\n\n  weight() {\n    const base = this.byteLength(false);\n    const total = this.byteLength(true);\n    return base * 3 + total;\n  }\n\n  virtualSize() {\n    return Math.ceil(this.weight() / 4);\n  }\n\n  byteLength(_ALLOW_WITNESS = true) {\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n\n    return (hasWitnesses ? 10 : 8) + varuint.encodingLength(this.ins.length) + varuint.encodingLength(this.outs.length) + this.ins.reduce((sum, input) => {\n      return sum + 40 + varSliceSize(input.script);\n    }, 0) + this.outs.reduce((sum, output) => {\n      return sum + 8 + varSliceSize(output.script);\n    }, 0) + (hasWitnesses ? this.ins.reduce((sum, input) => {\n      return sum + vectorSize(input.witness);\n    }, 0) : 0);\n  }\n\n  clone() {\n    const newTx = new Transaction();\n    newTx.version = this.version;\n    newTx.locktime = this.locktime;\n    newTx.ins = this.ins.map(txIn => {\n      return {\n        hash: txIn.hash,\n        index: txIn.index,\n        script: txIn.script,\n        sequence: txIn.sequence,\n        witness: txIn.witness\n      };\n    });\n    newTx.outs = this.outs.map(txOut => {\n      return {\n        script: txOut.script,\n        value: txOut.value\n      };\n    });\n    return newTx;\n  }\n  /**\n   * Hash transaction for signing a specific input.\n   *\n   * Bitcoin uses a different hash for each signed transaction input.\n   * This method copies the transaction, makes the necessary changes based on the\n   * hashType, and then hashes the result.\n   * This hash can then be used to sign the provided transaction input.\n   */\n\n\n  hashForSignature(inIndex, prevOutScript, hashType) {\n    typeforce(types.tuple(types.UInt32, types.Buffer,\n    /* types.UInt8 */\n    types.Number), arguments); // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n\n    if (inIndex >= this.ins.length) return ONE; // ignore OP_CODESEPARATOR\n\n    const ourScript = bscript.compile(bscript.decompile(prevOutScript).filter(x => {\n      return x !== script_1.OPS.OP_CODESEPARATOR;\n    }));\n    const txTmp = this.clone(); // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n\n    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n      txTmp.outs = []; // ignore sequence numbers (except at inIndex)\n\n      txTmp.ins.forEach((input, i) => {\n        if (i === inIndex) return;\n        input.sequence = 0;\n      }); // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n      if (inIndex >= this.outs.length) return ONE; // truncate outputs after\n\n      txTmp.outs.length = inIndex + 1; // \"blank\" outputs before\n\n      for (let i = 0; i < inIndex; i++) {\n        txTmp.outs[i] = BLANK_OUTPUT;\n      } // ignore sequence numbers (except at inIndex)\n\n\n      txTmp.ins.forEach((input, y) => {\n        if (y === inIndex) return;\n        input.sequence = 0;\n      });\n    } // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n\n\n    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n      txTmp.ins = [txTmp.ins[inIndex]];\n      txTmp.ins[0].script = ourScript; // SIGHASH_ALL: only ignore input scripts\n    } else {\n      // \"blank\" others input scripts\n      txTmp.ins.forEach(input => {\n        input.script = EMPTY_SCRIPT;\n      });\n      txTmp.ins[inIndex].script = ourScript;\n    } // serialize and hash\n\n\n    const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);\n    buffer.writeInt32LE(hashType, buffer.length - 4);\n\n    txTmp.__toBuffer(buffer, 0, false);\n\n    return bcrypto.hash256(buffer);\n  }\n\n  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {\n    typeforce(types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32), arguments);\n    let tbuffer = Buffer.from([]);\n    let bufferWriter;\n    let hashOutputs = ZERO;\n    let hashPrevouts = ZERO;\n    let hashSequence = ZERO;\n\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n      tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.hash256(tbuffer);\n    }\n\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY) && (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n      tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeUInt32(txIn.sequence);\n      });\n      hashSequence = bcrypto.hash256(tbuffer);\n    }\n\n    if ((hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n      const txOutsSize = this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0);\n      tbuffer = Buffer.allocUnsafe(txOutsSize);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.hash256(tbuffer);\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {\n      const output = this.outs[inIndex];\n      tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.hash256(tbuffer);\n    }\n\n    tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));\n    bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n    const input = this.ins[inIndex];\n    bufferWriter.writeUInt32(this.version);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(input.hash);\n    bufferWriter.writeUInt32(input.index);\n    bufferWriter.writeVarSlice(prevOutScript);\n    bufferWriter.writeUInt64(value);\n    bufferWriter.writeUInt32(input.sequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(hashType);\n    return bcrypto.hash256(tbuffer);\n  }\n\n  getHash(forWitness) {\n    // wtxid for coinbase is always 32 bytes of 0x00\n    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);\n    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));\n  }\n\n  getId() {\n    // transaction hash's are displayed in reverse order\n    return bufferutils_1.reverseBuffer(this.getHash(false)).toString('hex');\n  }\n\n  toBuffer(buffer, initialOffset) {\n    return this.__toBuffer(buffer, initialOffset, true);\n  }\n\n  toHex() {\n    return this.toBuffer(undefined, undefined).toString('hex');\n  }\n\n  setInputScript(index, scriptSig) {\n    typeforce(types.tuple(types.Number, types.Buffer), arguments);\n    this.ins[index].script = scriptSig;\n  }\n\n  setWitness(index, witness) {\n    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n    this.ins[index].witness = witness;\n  }\n\n  __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {\n    if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));\n    const bufferWriter = new bufferutils_1.BufferWriter(buffer, initialOffset || 0);\n    bufferWriter.writeInt32(this.version);\n\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n\n    if (hasWitnesses) {\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n    }\n\n    bufferWriter.writeVarInt(this.ins.length);\n    this.ins.forEach(txIn => {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n      bufferWriter.writeVarSlice(txIn.script);\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n    bufferWriter.writeVarInt(this.outs.length);\n    this.outs.forEach(txOut => {\n      if (isOutput(txOut)) {\n        bufferWriter.writeUInt64(txOut.value);\n      } else {\n        bufferWriter.writeSlice(txOut.valueBuffer);\n      }\n\n      bufferWriter.writeVarSlice(txOut.script);\n    });\n\n    if (hasWitnesses) {\n      this.ins.forEach(input => {\n        bufferWriter.writeVector(input.witness);\n      });\n    }\n\n    bufferWriter.writeUInt32(this.locktime); // avoid slicing unless necessary\n\n    if (initialOffset !== undefined) return buffer.slice(initialOffset, bufferWriter.offset);\n    return buffer;\n  }\n\n}\n\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\nexports.Transaction = Transaction;","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/bitcoinjs-lib/src/transaction.js"],"names":["Object","defineProperty","exports","value","bufferutils_1","require","bcrypto","bscript","script_1","types","typeforce","varuint","varSliceSize","someScript","length","encodingLength","vectorSize","someVector","reduce","sum","witness","EMPTY_SCRIPT","Buffer","allocUnsafe","EMPTY_WITNESS","ZERO","from","ONE","VALUE_UINT64_MAX","BLANK_OUTPUT","script","valueBuffer","isOutput","out","undefined","Transaction","constructor","version","locktime","ins","outs","fromBuffer","buffer","_NO_STRICT","bufferReader","BufferReader","tx","readInt32","marker","readUInt8","flag","hasWitnesses","ADVANCED_TRANSACTION_MARKER","ADVANCED_TRANSACTION_FLAG","offset","vinLen","readVarInt","i","push","hash","readSlice","index","readUInt32","readVarSlice","sequence","voutLen","readUInt64","readVector","Error","fromHex","hex","isCoinbaseHash","Hash256bit","isCoinbase","addInput","scriptSig","tuple","UInt32","maybe","arguments","Null","DEFAULT_SEQUENCE","addOutput","scriptPubKey","Satoshi","some","x","weight","base","byteLength","total","virtualSize","Math","ceil","_ALLOW_WITNESS","input","output","clone","newTx","map","txIn","txOut","hashForSignature","inIndex","prevOutScript","hashType","Number","ourScript","compile","decompile","filter","OPS","OP_CODESEPARATOR","txTmp","SIGHASH_NONE","forEach","SIGHASH_SINGLE","y","SIGHASH_ANYONECANPAY","writeInt32LE","__toBuffer","hash256","hashForWitnessV0","tbuffer","bufferWriter","hashOutputs","hashPrevouts","hashSequence","BufferWriter","writeSlice","writeUInt32","txOutsSize","writeUInt64","writeVarSlice","getHash","forWitness","alloc","getId","reverseBuffer","toString","toBuffer","initialOffset","toHex","setInputScript","setWitness","writeInt32","writeUInt8","writeVarInt","writeVector","slice","SIGHASH_ALL"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst bscript = require('./script');\nconst script_1 = require('./script');\nconst types = require('./types');\nconst typeforce = require('typeforce');\nconst varuint = require('varuint-bitcoin');\nfunction varSliceSize(someScript) {\n  const length = someScript.length;\n  return varuint.encodingLength(length) + length;\n}\nfunction vectorSize(someVector) {\n  const length = someVector.length;\n  return (\n    varuint.encodingLength(length) +\n    someVector.reduce((sum, witness) => {\n      return sum + varSliceSize(witness);\n    }, 0)\n  );\n}\nconst EMPTY_SCRIPT = Buffer.allocUnsafe(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'hex',\n);\nconst ONE = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000001',\n  'hex',\n);\nconst VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nconst BLANK_OUTPUT = {\n  script: EMPTY_SCRIPT,\n  valueBuffer: VALUE_UINT64_MAX,\n};\nfunction isOutput(out) {\n  return out.value !== undefined;\n}\nclass Transaction {\n  constructor() {\n    this.version = 1;\n    this.locktime = 0;\n    this.ins = [];\n    this.outs = [];\n  }\n  static fromBuffer(buffer, _NO_STRICT) {\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const tx = new Transaction();\n    tx.version = bufferReader.readInt32();\n    const marker = bufferReader.readUInt8();\n    const flag = bufferReader.readUInt8();\n    let hasWitnesses = false;\n    if (\n      marker === Transaction.ADVANCED_TRANSACTION_MARKER &&\n      flag === Transaction.ADVANCED_TRANSACTION_FLAG\n    ) {\n      hasWitnesses = true;\n    } else {\n      bufferReader.offset -= 2;\n    }\n    const vinLen = bufferReader.readVarInt();\n    for (let i = 0; i < vinLen; ++i) {\n      tx.ins.push({\n        hash: bufferReader.readSlice(32),\n        index: bufferReader.readUInt32(),\n        script: bufferReader.readVarSlice(),\n        sequence: bufferReader.readUInt32(),\n        witness: EMPTY_WITNESS,\n      });\n    }\n    const voutLen = bufferReader.readVarInt();\n    for (let i = 0; i < voutLen; ++i) {\n      tx.outs.push({\n        value: bufferReader.readUInt64(),\n        script: bufferReader.readVarSlice(),\n      });\n    }\n    if (hasWitnesses) {\n      for (let i = 0; i < vinLen; ++i) {\n        tx.ins[i].witness = bufferReader.readVector();\n      }\n      // was this pointless?\n      if (!tx.hasWitnesses())\n        throw new Error('Transaction has superfluous witness data');\n    }\n    tx.locktime = bufferReader.readUInt32();\n    if (_NO_STRICT) return tx;\n    if (bufferReader.offset !== buffer.length)\n      throw new Error('Transaction has unexpected data');\n    return tx;\n  }\n  static fromHex(hex) {\n    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);\n  }\n  static isCoinbaseHash(buffer) {\n    typeforce(types.Hash256bit, buffer);\n    for (let i = 0; i < 32; ++i) {\n      if (buffer[i] !== 0) return false;\n    }\n    return true;\n  }\n  isCoinbase() {\n    return (\n      this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)\n    );\n  }\n  addInput(hash, index, sequence, scriptSig) {\n    typeforce(\n      types.tuple(\n        types.Hash256bit,\n        types.UInt32,\n        types.maybe(types.UInt32),\n        types.maybe(types.Buffer),\n      ),\n      arguments,\n    );\n    if (types.Null(sequence)) {\n      sequence = Transaction.DEFAULT_SEQUENCE;\n    }\n    // Add the input and return the input's index\n    return (\n      this.ins.push({\n        hash,\n        index,\n        script: scriptSig || EMPTY_SCRIPT,\n        sequence: sequence,\n        witness: EMPTY_WITNESS,\n      }) - 1\n    );\n  }\n  addOutput(scriptPubKey, value) {\n    typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);\n    // Add the output and return the output's index\n    return (\n      this.outs.push({\n        script: scriptPubKey,\n        value,\n      }) - 1\n    );\n  }\n  hasWitnesses() {\n    return this.ins.some(x => {\n      return x.witness.length !== 0;\n    });\n  }\n  weight() {\n    const base = this.byteLength(false);\n    const total = this.byteLength(true);\n    return base * 3 + total;\n  }\n  virtualSize() {\n    return Math.ceil(this.weight() / 4);\n  }\n  byteLength(_ALLOW_WITNESS = true) {\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    return (\n      (hasWitnesses ? 10 : 8) +\n      varuint.encodingLength(this.ins.length) +\n      varuint.encodingLength(this.outs.length) +\n      this.ins.reduce((sum, input) => {\n        return sum + 40 + varSliceSize(input.script);\n      }, 0) +\n      this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0) +\n      (hasWitnesses\n        ? this.ins.reduce((sum, input) => {\n            return sum + vectorSize(input.witness);\n          }, 0)\n        : 0)\n    );\n  }\n  clone() {\n    const newTx = new Transaction();\n    newTx.version = this.version;\n    newTx.locktime = this.locktime;\n    newTx.ins = this.ins.map(txIn => {\n      return {\n        hash: txIn.hash,\n        index: txIn.index,\n        script: txIn.script,\n        sequence: txIn.sequence,\n        witness: txIn.witness,\n      };\n    });\n    newTx.outs = this.outs.map(txOut => {\n      return {\n        script: txOut.script,\n        value: txOut.value,\n      };\n    });\n    return newTx;\n  }\n  /**\n   * Hash transaction for signing a specific input.\n   *\n   * Bitcoin uses a different hash for each signed transaction input.\n   * This method copies the transaction, makes the necessary changes based on the\n   * hashType, and then hashes the result.\n   * This hash can then be used to sign the provided transaction input.\n   */\n  hashForSignature(inIndex, prevOutScript, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number),\n      arguments,\n    );\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n    if (inIndex >= this.ins.length) return ONE;\n    // ignore OP_CODESEPARATOR\n    const ourScript = bscript.compile(\n      bscript.decompile(prevOutScript).filter(x => {\n        return x !== script_1.OPS.OP_CODESEPARATOR;\n      }),\n    );\n    const txTmp = this.clone();\n    // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n      txTmp.outs = [];\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, i) => {\n        if (i === inIndex) return;\n        input.sequence = 0;\n      });\n      // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n      if (inIndex >= this.outs.length) return ONE;\n      // truncate outputs after\n      txTmp.outs.length = inIndex + 1;\n      // \"blank\" outputs before\n      for (let i = 0; i < inIndex; i++) {\n        txTmp.outs[i] = BLANK_OUTPUT;\n      }\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, y) => {\n        if (y === inIndex) return;\n        input.sequence = 0;\n      });\n    }\n    // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n      txTmp.ins = [txTmp.ins[inIndex]];\n      txTmp.ins[0].script = ourScript;\n      // SIGHASH_ALL: only ignore input scripts\n    } else {\n      // \"blank\" others input scripts\n      txTmp.ins.forEach(input => {\n        input.script = EMPTY_SCRIPT;\n      });\n      txTmp.ins[inIndex].script = ourScript;\n    }\n    // serialize and hash\n    const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);\n    buffer.writeInt32LE(hashType, buffer.length - 4);\n    txTmp.__toBuffer(buffer, 0, false);\n    return bcrypto.hash256(buffer);\n  }\n  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),\n      arguments,\n    );\n    let tbuffer = Buffer.from([]);\n    let bufferWriter;\n    let hashOutputs = ZERO;\n    let hashPrevouts = ZERO;\n    let hashSequence = ZERO;\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n      tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.hash256(tbuffer);\n    }\n    if (\n      !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeUInt32(txIn.sequence);\n      });\n      hashSequence = bcrypto.hash256(tbuffer);\n    }\n    if (\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      const txOutsSize = this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0);\n      tbuffer = Buffer.allocUnsafe(txOutsSize);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.hash256(tbuffer);\n    } else if (\n      (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&\n      inIndex < this.outs.length\n    ) {\n      const output = this.outs[inIndex];\n      tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.hash256(tbuffer);\n    }\n    tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));\n    bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n    const input = this.ins[inIndex];\n    bufferWriter.writeUInt32(this.version);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(input.hash);\n    bufferWriter.writeUInt32(input.index);\n    bufferWriter.writeVarSlice(prevOutScript);\n    bufferWriter.writeUInt64(value);\n    bufferWriter.writeUInt32(input.sequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(hashType);\n    return bcrypto.hash256(tbuffer);\n  }\n  getHash(forWitness) {\n    // wtxid for coinbase is always 32 bytes of 0x00\n    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);\n    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));\n  }\n  getId() {\n    // transaction hash's are displayed in reverse order\n    return bufferutils_1.reverseBuffer(this.getHash(false)).toString('hex');\n  }\n  toBuffer(buffer, initialOffset) {\n    return this.__toBuffer(buffer, initialOffset, true);\n  }\n  toHex() {\n    return this.toBuffer(undefined, undefined).toString('hex');\n  }\n  setInputScript(index, scriptSig) {\n    typeforce(types.tuple(types.Number, types.Buffer), arguments);\n    this.ins[index].script = scriptSig;\n  }\n  setWitness(index, witness) {\n    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n    this.ins[index].witness = witness;\n  }\n  __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {\n    if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));\n    const bufferWriter = new bufferutils_1.BufferWriter(\n      buffer,\n      initialOffset || 0,\n    );\n    bufferWriter.writeInt32(this.version);\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    if (hasWitnesses) {\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n    }\n    bufferWriter.writeVarInt(this.ins.length);\n    this.ins.forEach(txIn => {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n      bufferWriter.writeVarSlice(txIn.script);\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n    bufferWriter.writeVarInt(this.outs.length);\n    this.outs.forEach(txOut => {\n      if (isOutput(txOut)) {\n        bufferWriter.writeUInt64(txOut.value);\n      } else {\n        bufferWriter.writeSlice(txOut.valueBuffer);\n      }\n      bufferWriter.writeVarSlice(txOut.script);\n    });\n    if (hasWitnesses) {\n      this.ins.forEach(input => {\n        bufferWriter.writeVector(input.witness);\n      });\n    }\n    bufferWriter.writeUInt32(this.locktime);\n    // avoid slicing unless necessary\n    if (initialOffset !== undefined)\n      return buffer.slice(initialOffset, bufferWriter.offset);\n    return buffer;\n  }\n}\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\nexports.Transaction = Transaction;\n"]},"metadata":{},"sourceType":"script"}