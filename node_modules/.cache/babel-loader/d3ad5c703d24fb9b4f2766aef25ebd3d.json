{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst scriptNumber = require('./script_number');\n\nconst scriptSignature = require('./script_signature');\n\nconst types = require('./types');\n\nconst bip66 = require('bip66');\n\nconst ecc = require('tiny-secp256k1');\n\nconst pushdata = require('pushdata-bitcoin');\n\nconst typeforce = require('typeforce');\n\nexports.OPS = require('bitcoin-ops');\n\nconst REVERSE_OPS = require('bitcoin-ops/map');\n\nconst OP_INT_BASE = exports.OPS.OP_RESERVED; // OP_1 - 1\n\nfunction isOPInt(value) {\n  return types.Number(value) && (value === exports.OPS.OP_0 || value >= exports.OPS.OP_1 && value <= exports.OPS.OP_16 || value === exports.OPS.OP_1NEGATE);\n}\n\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\n\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n}\n\nexports.isPushOnly = isPushOnly;\n\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return exports.OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return exports.OPS.OP_1NEGATE;\n}\n\nfunction chunksIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\n\nfunction chunksIsArray(buf) {\n  return types.Array(buf);\n}\n\nfunction singleChunkIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\n\nfunction compile(chunks) {\n  // TODO: remove me\n  if (chunksIsBuffer(chunks)) return chunks;\n  typeforce(types.Array, chunks);\n  const bufferSize = chunks.reduce((accum, chunk) => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    } // opcode\n\n\n    return accum + 1;\n  }, 0.0);\n  const buffer = Buffer.allocUnsafe(bufferSize);\n  let offset = 0;\n  chunks.forEach(chunk => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      const opcode = asMinimalOP(chunk);\n\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length; // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\n\nexports.compile = compile;\n\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (chunksIsArray(buffer)) return buffer;\n  typeforce(types.Buffer, buffer);\n  const chunks = [];\n  let i = 0;\n\n  while (i < buffer.length) {\n    const opcode = buffer[i]; // data chunk\n\n    if (opcode > exports.OPS.OP_0 && opcode <= exports.OPS.OP_PUSHDATA4) {\n      const d = pushdata.decode(buffer, i); // did reading a pushDataInt fail?\n\n      if (d === null) return null;\n      i += d.size; // attempt to read too much data?\n\n      if (i + d.number > buffer.length) return null;\n      const data = buffer.slice(i, i + d.number);\n      i += d.number; // decompile minimally\n\n      const op = asMinimalOP(data);\n\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      } // opcode\n\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n\n  return chunks;\n}\n\nexports.decompile = decompile;\n\nfunction toASM(chunks) {\n  if (chunksIsBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n\n  return chunks.map(chunk => {\n    // data?\n    if (singleChunkIsBuffer(chunk)) {\n      const op = asMinimalOP(chunk);\n      if (op === undefined) return chunk.toString('hex');\n      chunk = op;\n    } // opcode!\n\n\n    return REVERSE_OPS[chunk];\n  }).join(' ');\n}\n\nexports.toASM = toASM;\n\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n  return compile(asm.split(' ').map(chunkStr => {\n    // opcode?\n    if (exports.OPS[chunkStr] !== undefined) return exports.OPS[chunkStr];\n    typeforce(types.Hex, chunkStr); // data!\n\n    return Buffer.from(chunkStr, 'hex');\n  }));\n}\n\nexports.fromASM = fromASM;\n\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n  return chunks.map(op => {\n    if (singleChunkIsBuffer(op)) return op;\n    if (op === exports.OPS.OP_0) return Buffer.allocUnsafe(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\n\nexports.toStack = toStack;\n\nfunction isCanonicalPubKey(buffer) {\n  return ecc.isPoint(buffer);\n}\n\nexports.isCanonicalPubKey = isCanonicalPubKey;\n\nfunction isDefinedHashType(hashType) {\n  const hashTypeMod = hashType & ~0x80; // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\n\nexports.isDefinedHashType = isDefinedHashType;\n\nfunction isCanonicalScriptSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  return bip66.check(buffer.slice(0, -1));\n}\n\nexports.isCanonicalScriptSignature = isCanonicalScriptSignature; // tslint:disable-next-line variable-name\n\nexports.number = scriptNumber;\nexports.signature = scriptSignature;","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/bitcoinjs-lib/src/script.js"],"names":["Object","defineProperty","exports","value","scriptNumber","require","scriptSignature","types","bip66","ecc","pushdata","typeforce","OPS","REVERSE_OPS","OP_INT_BASE","OP_RESERVED","isOPInt","Number","OP_0","OP_1","OP_16","OP_1NEGATE","isPushOnlyChunk","Buffer","isPushOnly","Array","every","asMinimalOP","buffer","length","chunksIsBuffer","buf","isBuffer","chunksIsArray","singleChunkIsBuffer","compile","chunks","bufferSize","reduce","accum","chunk","undefined","encodingLength","allocUnsafe","offset","forEach","opcode","writeUInt8","encode","copy","Error","decompile","i","OP_PUSHDATA4","d","decode","size","number","data","slice","op","push","toASM","map","toString","join","fromASM","asm","String","split","chunkStr","Hex","from","toStack","isCanonicalPubKey","isPoint","isDefinedHashType","hashType","hashTypeMod","isCanonicalScriptSignature","check","signature"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst scriptNumber = require('./script_number');\nconst scriptSignature = require('./script_signature');\nconst types = require('./types');\nconst bip66 = require('bip66');\nconst ecc = require('tiny-secp256k1');\nconst pushdata = require('pushdata-bitcoin');\nconst typeforce = require('typeforce');\nexports.OPS = require('bitcoin-ops');\nconst REVERSE_OPS = require('bitcoin-ops/map');\nconst OP_INT_BASE = exports.OPS.OP_RESERVED; // OP_1 - 1\nfunction isOPInt(value) {\n  return (\n    types.Number(value) &&\n    (value === exports.OPS.OP_0 ||\n      (value >= exports.OPS.OP_1 && value <= exports.OPS.OP_16) ||\n      value === exports.OPS.OP_1NEGATE)\n  );\n}\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n}\nexports.isPushOnly = isPushOnly;\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return exports.OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return exports.OPS.OP_1NEGATE;\n}\nfunction chunksIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction chunksIsArray(buf) {\n  return types.Array(buf);\n}\nfunction singleChunkIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction compile(chunks) {\n  // TODO: remove me\n  if (chunksIsBuffer(chunks)) return chunks;\n  typeforce(types.Array, chunks);\n  const bufferSize = chunks.reduce((accum, chunk) => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    }\n    // opcode\n    return accum + 1;\n  }, 0.0);\n  const buffer = Buffer.allocUnsafe(bufferSize);\n  let offset = 0;\n  chunks.forEach(chunk => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      const opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length;\n      // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\nexports.compile = compile;\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (chunksIsArray(buffer)) return buffer;\n  typeforce(types.Buffer, buffer);\n  const chunks = [];\n  let i = 0;\n  while (i < buffer.length) {\n    const opcode = buffer[i];\n    // data chunk\n    if (opcode > exports.OPS.OP_0 && opcode <= exports.OPS.OP_PUSHDATA4) {\n      const d = pushdata.decode(buffer, i);\n      // did reading a pushDataInt fail?\n      if (d === null) return null;\n      i += d.size;\n      // attempt to read too much data?\n      if (i + d.number > buffer.length) return null;\n      const data = buffer.slice(i, i + d.number);\n      i += d.number;\n      // decompile minimally\n      const op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n      // opcode\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n  return chunks;\n}\nexports.decompile = decompile;\nfunction toASM(chunks) {\n  if (chunksIsBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n  return chunks\n    .map(chunk => {\n      // data?\n      if (singleChunkIsBuffer(chunk)) {\n        const op = asMinimalOP(chunk);\n        if (op === undefined) return chunk.toString('hex');\n        chunk = op;\n      }\n      // opcode!\n      return REVERSE_OPS[chunk];\n    })\n    .join(' ');\n}\nexports.toASM = toASM;\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n  return compile(\n    asm.split(' ').map(chunkStr => {\n      // opcode?\n      if (exports.OPS[chunkStr] !== undefined) return exports.OPS[chunkStr];\n      typeforce(types.Hex, chunkStr);\n      // data!\n      return Buffer.from(chunkStr, 'hex');\n    }),\n  );\n}\nexports.fromASM = fromASM;\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n  return chunks.map(op => {\n    if (singleChunkIsBuffer(op)) return op;\n    if (op === exports.OPS.OP_0) return Buffer.allocUnsafe(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\nexports.toStack = toStack;\nfunction isCanonicalPubKey(buffer) {\n  return ecc.isPoint(buffer);\n}\nexports.isCanonicalPubKey = isCanonicalPubKey;\nfunction isDefinedHashType(hashType) {\n  const hashTypeMod = hashType & ~0x80;\n  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nexports.isDefinedHashType = isDefinedHashType;\nfunction isCanonicalScriptSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  return bip66.check(buffer.slice(0, -1));\n}\nexports.isCanonicalScriptSignature = isCanonicalScriptSignature;\n// tslint:disable-next-line variable-name\nexports.number = scriptNumber;\nexports.signature = scriptSignature;\n"]},"metadata":{},"sourceType":"script"}