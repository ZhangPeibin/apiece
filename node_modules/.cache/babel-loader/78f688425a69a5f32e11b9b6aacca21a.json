{"ast":null,"code":"export async function onDropToUpload(acceptedFiles, buckets, bucketKey, callback) {\n  for (const accepted of acceptedFiles) {\n    await handleNewFile(accepted, buckets, bucketKey, callback);\n  }\n}\n\nasync function handleNewFile(file, buckets, bucketKey, callback) {\n  const fileSchema = {};\n  const now = new Date().getTime();\n  fileSchema['date'] = now;\n  fileSchema['name'] = `${file.name}`;\n  file.type;\n  const filename = `${file.name}`;\n  const location = `${'/'}${filename}`;\n\n  if (!buckets || !bucketKey) {\n    throw new Error('No bucket client or root key');\n  }\n\n  const reader = new FileReader(); // reader.onabort = () => {\n  //     return reject(`file reading was aborted`);\n  // }\n  // reader.onerror = () => reject('file reading has failed')\n\n  reader.onload = () => {\n    const binaryStr = reader.result; // Finally, push the full file to the bucket\n\n    buckets.pushPath(bucketKey, location, binaryStr).then(raw => {\n      const metadata = {\n        cid: raw.path.cid.toString(),\n        name: filename,\n        path: location,\n        size: file.size,\n        date: new Date().toLocaleString()\n      };\n      callback(metadata);\n    });\n  };\n\n  reader.readAsArrayBuffer(file);\n}","map":{"version":3,"sources":["E:/anipfspace/src/common/upload.ts"],"names":["onDropToUpload","acceptedFiles","buckets","bucketKey","callback","accepted","handleNewFile","file","fileSchema","now","Date","getTime","name","type","filename","location","Error","reader","FileReader","onload","binaryStr","result","pushPath","then","raw","metadata","cid","path","toString","size","date","toLocaleString","readAsArrayBuffer"],"mappings":"AAEA,OAAO,eAAeA,cAAf,CAA8BC,aAA9B,EAAqDC,OAArD,EAAuEC,SAAvE,EAA0FC,QAA1F,EAA8G;AACjH,OAAK,MAAMC,QAAX,IAAuBJ,aAAvB,EAAsC;AAClC,UAAMK,aAAa,CAACD,QAAD,EAAWH,OAAX,EAAoBC,SAApB,EAA+BC,QAA/B,CAAnB;AACH;AACJ;;AAED,eAAeE,aAAf,CAA6BC,IAA7B,EAAyCL,OAAzC,EAA2DC,SAA3D,EAA8EC,QAA9E,EAAkG;AAC9F,QAAMI,UAAkC,GAAG,EAA3C;AACA,QAAMC,GAAG,GAAG,IAAIC,IAAJ,GAAWC,OAAX,EAAZ;AACAH,EAAAA,UAAU,CAAC,MAAD,CAAV,GAAqBC,GAArB;AACAD,EAAAA,UAAU,CAAC,MAAD,CAAV,GAAsB,GAAED,IAAI,CAACK,IAAK,EAAlC;AACAL,EAAAA,IAAI,CAACM,IAAL;AACA,QAAMC,QAAQ,GAAI,GAAEP,IAAI,CAACK,IAAK,EAA9B;AACA,QAAMG,QAAQ,GAAI,GAAE,GAAI,GAAED,QAAS,EAAnC;;AAEA,MAAI,CAACZ,OAAD,IAAY,CAACC,SAAjB,EAA4B;AACxB,UAAM,IAAIa,KAAJ,CAAU,8BAAV,CAAN;AACH;;AAED,QAAMC,MAAM,GAAG,IAAIC,UAAJ,EAAf,CAb8F,CAc9F;AACA;AACA;AACA;;AACAD,EAAAA,MAAM,CAACE,MAAP,GAAgB,MAAM;AAClB,UAAMC,SAAS,GAAGH,MAAM,CAACI,MAAzB,CADkB,CAElB;;AACAnB,IAAAA,OAAO,CAACoB,QAAR,CAAiBnB,SAAjB,EAA4BY,QAA5B,EAAsCK,SAAtC,EAAiDG,IAAjD,CAAuDC,GAAD,IAAS;AAC3D,YAAMC,QAAQ,GAAG;AACbC,QAAAA,GAAG,EAAEF,GAAG,CAACG,IAAJ,CAASD,GAAT,CAAaE,QAAb,EADQ;AAEbhB,QAAAA,IAAI,EAAEE,QAFO;AAGba,QAAAA,IAAI,EAAEZ,QAHO;AAIbc,QAAAA,IAAI,EAAEtB,IAAI,CAACsB,IAJE;AAKbC,QAAAA,IAAI,EAAG,IAAIpB,IAAJ,EAAD,CAAaqB,cAAb;AALO,OAAjB;AAOA3B,MAAAA,QAAQ,CAACqB,QAAD,CAAR;AACH,KATD;AAUH,GAbD;;AAcAR,EAAAA,MAAM,CAACe,iBAAP,CAAyBzB,IAAzB;AACH","sourcesContent":["import {Buckets} from '@textile/hub'\r\n\r\nexport async function onDropToUpload(acceptedFiles: File[], buckets: Buckets, bucketKey: string, callback: Function) {\r\n    for (const accepted of acceptedFiles) {\r\n        await handleNewFile(accepted, buckets, bucketKey, callback)\r\n    }\r\n}\r\n\r\nasync function handleNewFile(file: File, buckets: Buckets, bucketKey: string, callback: Function) {\r\n    const fileSchema: { [key: string]: any } = {};\r\n    const now = new Date().getTime();\r\n    fileSchema['date'] = now;\r\n    fileSchema['name'] = `${file.name}`;\r\n    file.type;\r\n    const filename = `${file.name}`;\r\n    const location = `${'/'}${filename}`;\r\n\r\n    if (!buckets || !bucketKey) {\r\n        throw new Error('No bucket client or root key')\r\n    }\r\n\r\n    const reader = new FileReader();\r\n    // reader.onabort = () => {\r\n    //     return reject(`file reading was aborted`);\r\n    // }\r\n    // reader.onerror = () => reject('file reading has failed')\r\n    reader.onload = () => {\r\n        const binaryStr = reader.result;\r\n        // Finally, push the full file to the bucket\r\n        buckets.pushPath(bucketKey, location, binaryStr).then((raw) => {\r\n            const metadata = {\r\n                cid: raw.path.cid.toString(),\r\n                name: filename,\r\n                path: location,\r\n                size: file.size,\r\n                date: (new Date()).toLocaleString()\r\n            };\r\n            callback(metadata);\r\n        })\r\n    };\r\n    reader.readAsArrayBuffer(file)\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}