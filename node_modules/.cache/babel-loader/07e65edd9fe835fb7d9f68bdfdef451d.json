{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst typeFields_1 = require('../../typeFields');\n\nconst tools_1 = require('../tools');\n\nconst varuint = require('../varint');\n\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {\n    throw new Error('Decode Error: could not decode witnessUtxo with key 0x' + keyVal.key.toString('hex'));\n  }\n\n  const value = tools_1.readUInt64LE(keyVal.value, 0);\n  let _offset = 8;\n  const scriptLen = varuint.decode(keyVal.value, _offset);\n  _offset += varuint.encodingLength(scriptLen);\n  const script = keyVal.value.slice(_offset);\n\n  if (script.length !== scriptLen) {\n    throw new Error('Decode Error: WITNESS_UTXO script is not proper length');\n  }\n\n  return {\n    script,\n    value\n  };\n}\n\nexports.decode = decode;\n\nfunction encode(data) {\n  const {\n    script,\n    value\n  } = data;\n  const varintLen = varuint.encodingLength(script.length);\n  const result = Buffer.allocUnsafe(8 + varintLen + script.length);\n  tools_1.writeUInt64LE(result, value, 0);\n  varuint.encode(script.length, result, 8);\n  script.copy(result, 8 + varintLen);\n  return {\n    key: Buffer.from([typeFields_1.InputTypes.WITNESS_UTXO]),\n    value: result\n  };\n}\n\nexports.encode = encode;\nexports.expected = '{ script: Buffer; value: number; }';\n\nfunction check(data) {\n  return Buffer.isBuffer(data.script) && typeof data.value === 'number';\n}\n\nexports.check = check;\n\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.witnessUtxo === undefined;\n}\n\nexports.canAdd = canAdd;","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/bip174/src/lib/converter/input/witnessUtxo.js"],"names":["Object","defineProperty","exports","value","typeFields_1","require","tools_1","varuint","decode","keyVal","key","InputTypes","WITNESS_UTXO","Error","toString","readUInt64LE","_offset","scriptLen","encodingLength","script","slice","length","encode","data","varintLen","result","Buffer","allocUnsafe","writeUInt64LE","copy","from","expected","check","isBuffer","canAdd","currentData","newData","witnessUtxo","undefined"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,YAAY,GAAGC,OAAO,CAAC,kBAAD,CAA5B;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,WAAD,CAAvB;;AACA,SAASG,MAAT,CAAgBC,MAAhB,EAAwB;AACtB,MAAIA,MAAM,CAACC,GAAP,CAAW,CAAX,MAAkBN,YAAY,CAACO,UAAb,CAAwBC,YAA9C,EAA4D;AAC1D,UAAM,IAAIC,KAAJ,CACJ,2DACEJ,MAAM,CAACC,GAAP,CAAWI,QAAX,CAAoB,KAApB,CAFE,CAAN;AAID;;AACD,QAAMX,KAAK,GAAGG,OAAO,CAACS,YAAR,CAAqBN,MAAM,CAACN,KAA5B,EAAmC,CAAnC,CAAd;AACA,MAAIa,OAAO,GAAG,CAAd;AACA,QAAMC,SAAS,GAAGV,OAAO,CAACC,MAAR,CAAeC,MAAM,CAACN,KAAtB,EAA6Ba,OAA7B,CAAlB;AACAA,EAAAA,OAAO,IAAIT,OAAO,CAACW,cAAR,CAAuBD,SAAvB,CAAX;AACA,QAAME,MAAM,GAAGV,MAAM,CAACN,KAAP,CAAaiB,KAAb,CAAmBJ,OAAnB,CAAf;;AACA,MAAIG,MAAM,CAACE,MAAP,KAAkBJ,SAAtB,EAAiC;AAC/B,UAAM,IAAIJ,KAAJ,CAAU,wDAAV,CAAN;AACD;;AACD,SAAO;AACLM,IAAAA,MADK;AAELhB,IAAAA;AAFK,GAAP;AAID;;AACDD,OAAO,CAACM,MAAR,GAAiBA,MAAjB;;AACA,SAASc,MAAT,CAAgBC,IAAhB,EAAsB;AACpB,QAAM;AAAEJ,IAAAA,MAAF;AAAUhB,IAAAA;AAAV,MAAoBoB,IAA1B;AACA,QAAMC,SAAS,GAAGjB,OAAO,CAACW,cAAR,CAAuBC,MAAM,CAACE,MAA9B,CAAlB;AACA,QAAMI,MAAM,GAAGC,MAAM,CAACC,WAAP,CAAmB,IAAIH,SAAJ,GAAgBL,MAAM,CAACE,MAA1C,CAAf;AACAf,EAAAA,OAAO,CAACsB,aAAR,CAAsBH,MAAtB,EAA8BtB,KAA9B,EAAqC,CAArC;AACAI,EAAAA,OAAO,CAACe,MAAR,CAAeH,MAAM,CAACE,MAAtB,EAA8BI,MAA9B,EAAsC,CAAtC;AACAN,EAAAA,MAAM,CAACU,IAAP,CAAYJ,MAAZ,EAAoB,IAAID,SAAxB;AACA,SAAO;AACLd,IAAAA,GAAG,EAAEgB,MAAM,CAACI,IAAP,CAAY,CAAC1B,YAAY,CAACO,UAAb,CAAwBC,YAAzB,CAAZ,CADA;AAELT,IAAAA,KAAK,EAAEsB;AAFF,GAAP;AAID;;AACDvB,OAAO,CAACoB,MAAR,GAAiBA,MAAjB;AACApB,OAAO,CAAC6B,QAAR,GAAmB,oCAAnB;;AACA,SAASC,KAAT,CAAeT,IAAf,EAAqB;AACnB,SAAOG,MAAM,CAACO,QAAP,CAAgBV,IAAI,CAACJ,MAArB,KAAgC,OAAOI,IAAI,CAACpB,KAAZ,KAAsB,QAA7D;AACD;;AACDD,OAAO,CAAC8B,KAAR,GAAgBA,KAAhB;;AACA,SAASE,MAAT,CAAgBC,WAAhB,EAA6BC,OAA7B,EAAsC;AACpC,SAAO,CAAC,CAACD,WAAF,IAAiB,CAAC,CAACC,OAAnB,IAA8BD,WAAW,CAACE,WAAZ,KAA4BC,SAAjE;AACD;;AACDpC,OAAO,CAACgC,MAAR,GAAiBA,MAAjB","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nconst tools_1 = require('../tools');\nconst varuint = require('../varint');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {\n    throw new Error(\n      'Decode Error: could not decode witnessUtxo with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const value = tools_1.readUInt64LE(keyVal.value, 0);\n  let _offset = 8;\n  const scriptLen = varuint.decode(keyVal.value, _offset);\n  _offset += varuint.encodingLength(scriptLen);\n  const script = keyVal.value.slice(_offset);\n  if (script.length !== scriptLen) {\n    throw new Error('Decode Error: WITNESS_UTXO script is not proper length');\n  }\n  return {\n    script,\n    value,\n  };\n}\nexports.decode = decode;\nfunction encode(data) {\n  const { script, value } = data;\n  const varintLen = varuint.encodingLength(script.length);\n  const result = Buffer.allocUnsafe(8 + varintLen + script.length);\n  tools_1.writeUInt64LE(result, value, 0);\n  varuint.encode(script.length, result, 8);\n  script.copy(result, 8 + varintLen);\n  return {\n    key: Buffer.from([typeFields_1.InputTypes.WITNESS_UTXO]),\n    value: result,\n  };\n}\nexports.encode = encode;\nexports.expected = '{ script: Buffer; value: number; }';\nfunction check(data) {\n  return Buffer.isBuffer(data.script) && typeof data.value === 'number';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.witnessUtxo === undefined;\n}\nexports.canAdd = canAdd;\n"]},"metadata":{},"sourceType":"script"}