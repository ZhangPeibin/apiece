{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst typeFields_1 = require('../../typeFields');\n\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {\n    throw new Error('Decode Error: could not decode sighashType with key 0x' + keyVal.key.toString('hex'));\n  }\n\n  return keyVal.value.readUInt32LE(0);\n}\n\nexports.decode = decode;\n\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.SIGHASH_TYPE]);\n  const value = Buffer.allocUnsafe(4);\n  value.writeUInt32LE(data, 0);\n  return {\n    key,\n    value\n  };\n}\n\nexports.encode = encode;\nexports.expected = 'number';\n\nfunction check(data) {\n  return typeof data === 'number';\n}\n\nexports.check = check;\n\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.sighashType === undefined;\n}\n\nexports.canAdd = canAdd;","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/bip174/src/lib/converter/input/sighashType.js"],"names":["Object","defineProperty","exports","value","typeFields_1","require","decode","keyVal","key","InputTypes","SIGHASH_TYPE","Error","toString","readUInt32LE","encode","data","Buffer","from","allocUnsafe","writeUInt32LE","expected","check","canAdd","currentData","newData","sighashType","undefined"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,YAAY,GAAGC,OAAO,CAAC,kBAAD,CAA5B;;AACA,SAASC,MAAT,CAAgBC,MAAhB,EAAwB;AACtB,MAAIA,MAAM,CAACC,GAAP,CAAW,CAAX,MAAkBJ,YAAY,CAACK,UAAb,CAAwBC,YAA9C,EAA4D;AAC1D,UAAM,IAAIC,KAAJ,CACJ,2DACEJ,MAAM,CAACC,GAAP,CAAWI,QAAX,CAAoB,KAApB,CAFE,CAAN;AAID;;AACD,SAAOL,MAAM,CAACJ,KAAP,CAAaU,YAAb,CAA0B,CAA1B,CAAP;AACD;;AACDX,OAAO,CAACI,MAAR,GAAiBA,MAAjB;;AACA,SAASQ,MAAT,CAAgBC,IAAhB,EAAsB;AACpB,QAAMP,GAAG,GAAGQ,MAAM,CAACC,IAAP,CAAY,CAACb,YAAY,CAACK,UAAb,CAAwBC,YAAzB,CAAZ,CAAZ;AACA,QAAMP,KAAK,GAAGa,MAAM,CAACE,WAAP,CAAmB,CAAnB,CAAd;AACAf,EAAAA,KAAK,CAACgB,aAAN,CAAoBJ,IAApB,EAA0B,CAA1B;AACA,SAAO;AACLP,IAAAA,GADK;AAELL,IAAAA;AAFK,GAAP;AAID;;AACDD,OAAO,CAACY,MAAR,GAAiBA,MAAjB;AACAZ,OAAO,CAACkB,QAAR,GAAmB,QAAnB;;AACA,SAASC,KAAT,CAAeN,IAAf,EAAqB;AACnB,SAAO,OAAOA,IAAP,KAAgB,QAAvB;AACD;;AACDb,OAAO,CAACmB,KAAR,GAAgBA,KAAhB;;AACA,SAASC,MAAT,CAAgBC,WAAhB,EAA6BC,OAA7B,EAAsC;AACpC,SAAO,CAAC,CAACD,WAAF,IAAiB,CAAC,CAACC,OAAnB,IAA8BD,WAAW,CAACE,WAAZ,KAA4BC,SAAjE;AACD;;AACDxB,OAAO,CAACoB,MAAR,GAAiBA,MAAjB","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {\n    throw new Error(\n      'Decode Error: could not decode sighashType with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value.readUInt32LE(0);\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.SIGHASH_TYPE]);\n  const value = Buffer.allocUnsafe(4);\n  value.writeUInt32LE(data, 0);\n  return {\n    key,\n    value,\n  };\n}\nexports.encode = encode;\nexports.expected = 'number';\nfunction check(data) {\n  return typeof data === 'number';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.sighashType === undefined;\n}\nexports.canAdd = canAdd;\n"]},"metadata":{},"sourceType":"script"}