{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst networks = require('./networks');\n\nconst payments = require('./payments');\n\nconst bscript = require('./script');\n\nconst types = require('./types');\n\nconst bech32 = require('bech32');\n\nconst bs58check = require('bs58check');\n\nconst typeforce = require('typeforce');\n\nfunction fromBase58Check(address) {\n  const payload = bs58check.decode(address); // TODO: 4.0.0, move to \"toOutputScript\"\n\n  if (payload.length < 21) throw new TypeError(address + ' is too short');\n  if (payload.length > 21) throw new TypeError(address + ' is too long');\n  const version = payload.readUInt8(0);\n  const hash = payload.slice(1);\n  return {\n    version,\n    hash\n  };\n}\n\nexports.fromBase58Check = fromBase58Check;\n\nfunction fromBech32(address) {\n  const result = bech32.decode(address);\n  const data = bech32.fromWords(result.words.slice(1));\n  return {\n    version: result.words[0],\n    prefix: result.prefix,\n    data: Buffer.from(data)\n  };\n}\n\nexports.fromBech32 = fromBech32;\n\nfunction toBase58Check(hash, version) {\n  typeforce(types.tuple(types.Hash160bit, types.UInt8), arguments);\n  const payload = Buffer.allocUnsafe(21);\n  payload.writeUInt8(version, 0);\n  hash.copy(payload, 1);\n  return bs58check.encode(payload);\n}\n\nexports.toBase58Check = toBase58Check;\n\nfunction toBech32(data, version, prefix) {\n  const words = bech32.toWords(data);\n  words.unshift(version);\n  return bech32.encode(prefix, words);\n}\n\nexports.toBech32 = toBech32;\n\nfunction fromOutputScript(output, network) {\n  // TODO: Network\n  network = network || networks.bitcoin;\n\n  try {\n    return payments.p2pkh({\n      output,\n      network\n    }).address;\n  } catch (e) {}\n\n  try {\n    return payments.p2sh({\n      output,\n      network\n    }).address;\n  } catch (e) {}\n\n  try {\n    return payments.p2wpkh({\n      output,\n      network\n    }).address;\n  } catch (e) {}\n\n  try {\n    return payments.p2wsh({\n      output,\n      network\n    }).address;\n  } catch (e) {}\n\n  throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\n\nexports.fromOutputScript = fromOutputScript;\n\nfunction toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  let decodeBase58;\n  let decodeBech32;\n\n  try {\n    decodeBase58 = fromBase58Check(address);\n  } catch (e) {}\n\n  if (decodeBase58) {\n    if (decodeBase58.version === network.pubKeyHash) return payments.p2pkh({\n      hash: decodeBase58.hash\n    }).output;\n    if (decodeBase58.version === network.scriptHash) return payments.p2sh({\n      hash: decodeBase58.hash\n    }).output;\n  } else {\n    try {\n      decodeBech32 = fromBech32(address);\n    } catch (e) {}\n\n    if (decodeBech32) {\n      if (decodeBech32.prefix !== network.bech32) throw new Error(address + ' has an invalid prefix');\n\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20) return payments.p2wpkh({\n          hash: decodeBech32.data\n        }).output;\n        if (decodeBech32.data.length === 32) return payments.p2wsh({\n          hash: decodeBech32.data\n        }).output;\n      }\n    }\n  }\n\n  throw new Error(address + ' has no matching Script');\n}\n\nexports.toOutputScript = toOutputScript;","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/bitcoinjs-lib/src/address.js"],"names":["Object","defineProperty","exports","value","networks","require","payments","bscript","types","bech32","bs58check","typeforce","fromBase58Check","address","payload","decode","length","TypeError","version","readUInt8","hash","slice","fromBech32","result","data","fromWords","words","prefix","Buffer","from","toBase58Check","tuple","Hash160bit","UInt8","arguments","allocUnsafe","writeUInt8","copy","encode","toBech32","toWords","unshift","fromOutputScript","output","network","bitcoin","p2pkh","e","p2sh","p2wpkh","p2wsh","Error","toASM","toOutputScript","decodeBase58","decodeBech32","pubKeyHash","scriptHash"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst networks = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst types = require('./types');\nconst bech32 = require('bech32');\nconst bs58check = require('bs58check');\nconst typeforce = require('typeforce');\nfunction fromBase58Check(address) {\n  const payload = bs58check.decode(address);\n  // TODO: 4.0.0, move to \"toOutputScript\"\n  if (payload.length < 21) throw new TypeError(address + ' is too short');\n  if (payload.length > 21) throw new TypeError(address + ' is too long');\n  const version = payload.readUInt8(0);\n  const hash = payload.slice(1);\n  return { version, hash };\n}\nexports.fromBase58Check = fromBase58Check;\nfunction fromBech32(address) {\n  const result = bech32.decode(address);\n  const data = bech32.fromWords(result.words.slice(1));\n  return {\n    version: result.words[0],\n    prefix: result.prefix,\n    data: Buffer.from(data),\n  };\n}\nexports.fromBech32 = fromBech32;\nfunction toBase58Check(hash, version) {\n  typeforce(types.tuple(types.Hash160bit, types.UInt8), arguments);\n  const payload = Buffer.allocUnsafe(21);\n  payload.writeUInt8(version, 0);\n  hash.copy(payload, 1);\n  return bs58check.encode(payload);\n}\nexports.toBase58Check = toBase58Check;\nfunction toBech32(data, version, prefix) {\n  const words = bech32.toWords(data);\n  words.unshift(version);\n  return bech32.encode(prefix, words);\n}\nexports.toBech32 = toBech32;\nfunction fromOutputScript(output, network) {\n  // TODO: Network\n  network = network || networks.bitcoin;\n  try {\n    return payments.p2pkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2sh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wpkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wsh({ output, network }).address;\n  } catch (e) {}\n  throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\nexports.fromOutputScript = fromOutputScript;\nfunction toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  let decodeBase58;\n  let decodeBech32;\n  try {\n    decodeBase58 = fromBase58Check(address);\n  } catch (e) {}\n  if (decodeBase58) {\n    if (decodeBase58.version === network.pubKeyHash)\n      return payments.p2pkh({ hash: decodeBase58.hash }).output;\n    if (decodeBase58.version === network.scriptHash)\n      return payments.p2sh({ hash: decodeBase58.hash }).output;\n  } else {\n    try {\n      decodeBech32 = fromBech32(address);\n    } catch (e) {}\n    if (decodeBech32) {\n      if (decodeBech32.prefix !== network.bech32)\n        throw new Error(address + ' has an invalid prefix');\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20)\n          return payments.p2wpkh({ hash: decodeBech32.data }).output;\n        if (decodeBech32.data.length === 32)\n          return payments.p2wsh({ hash: decodeBech32.data }).output;\n      }\n    }\n  }\n  throw new Error(address + ' has no matching Script');\n}\nexports.toOutputScript = toOutputScript;\n"]},"metadata":{},"sourceType":"script"}