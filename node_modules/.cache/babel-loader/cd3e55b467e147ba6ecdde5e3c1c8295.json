{"ast":null,"code":"export async function onDropToUpload(acceptedFiles) {\n  for (const accepted of acceptedFiles) {\n    await handleNewFile(accepted);\n  }\n}\n\nasync function handleNewFile(file) {\n  const fileSchema = {};\n  const now = new Date().getTime();\n  fileSchema['date'] = now;\n  fileSchema['name'] = `${file.name}`;\n  const filename = `${now}_${file.name}`;\n  await processAndStore(file, '/', filename);\n}\n\nasync function processAndStore(image, path, name) {\n  // const size = await browserImageSize(finalImage)\n  const location = `${path}${name}`;\n  const raw = await insertFile(image, location);\n  const metadata = {\n    cid: raw.path.cid.toString(),\n    name: name,\n    path: location\n  };\n  return metadata;\n}\n/**\n * Pushes files to the bucket\n * @param file\n * @param path\n */\n\n\nasync function insertFile(file, path) {\n  if (!this.state.buckets || !this.state.bucketKey) {\n    throw new Error('No bucket client or root key');\n  }\n\n  const buckets = this.state.buckets;\n  return await buckets.pushPath(this.state.bucketKey, path, file.stream());\n}","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/src/common/upload.js"],"names":["onDropToUpload","acceptedFiles","accepted","handleNewFile","file","fileSchema","now","Date","getTime","name","filename","processAndStore","image","path","location","raw","insertFile","metadata","cid","toString","state","buckets","bucketKey","Error","pushPath","stream"],"mappings":"AAAA,OAAO,eAAeA,cAAf,CAA8BC,aAA9B,EAA6C;AAChD,OAAK,MAAMC,QAAX,IAAuBD,aAAvB,EAAsC;AAClC,UAAME,aAAa,CAACD,QAAD,CAAnB;AACH;AACJ;;AAED,eAAeC,aAAf,CAA6BC,IAA7B,EAAuC;AACnC,QAAMC,UAAgC,GAAG,EAAzC;AACA,QAAMC,GAAG,GAAG,IAAIC,IAAJ,GAAWC,OAAX,EAAZ;AACAH,EAAAA,UAAU,CAAC,MAAD,CAAV,GAAqBC,GAArB;AACAD,EAAAA,UAAU,CAAC,MAAD,CAAV,GAAsB,GAAED,IAAI,CAACK,IAAK,EAAlC;AACA,QAAMC,QAAQ,GAAI,GAAEJ,GAAI,IAAGF,IAAI,CAACK,IAAK,EAArC;AACA,QAAME,eAAe,CAACP,IAAD,EAAO,GAAP,EAAYM,QAAZ,CAArB;AACH;;AAED,eAAgBC,eAAhB,CAAiCC,KAAjC,EAA8CC,IAA9C,EAA4DJ,IAA5D,EAAyE;AACrE;AACA,QAAMK,QAAQ,GAAI,GAAED,IAAK,GAAEJ,IAAK,EAAhC;AACA,QAAMM,GAAG,GAAG,MAAMC,UAAU,CAACJ,KAAD,EAAQE,QAAR,CAA5B;AACA,QAAMG,QAAQ,GAAG;AACbC,IAAAA,GAAG,EAAEH,GAAG,CAACF,IAAJ,CAASK,GAAT,CAAaC,QAAb,EADQ;AAEbV,IAAAA,IAAI,EAAEA,IAFO;AAGbI,IAAAA,IAAI,EAAEC;AAHO,GAAjB;AAKA,SAAOG,QAAP;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,eAAgBD,UAAhB,CAA2BZ,IAA3B,EAAuCS,IAAvC,EAAoD;AAChD,MAAI,CAAC,KAAKO,KAAL,CAAWC,OAAZ,IAAuB,CAAC,KAAKD,KAAL,CAAWE,SAAvC,EAAkD;AAC9C,UAAM,IAAIC,KAAJ,CAAU,8BAAV,CAAN;AACH;;AACD,QAAMF,OAAgB,GAAG,KAAKD,KAAL,CAAWC,OAApC;AACA,SAAO,MAAMA,OAAO,CAACG,QAAR,CAAiB,KAAKJ,KAAL,CAAWE,SAA5B,EAAuCT,IAAvC,EAA6CT,IAAI,CAACqB,MAAL,EAA7C,CAAb;AACH","sourcesContent":["export async function onDropToUpload(acceptedFiles) {\n    for (const accepted of acceptedFiles) {\n        await handleNewFile(accepted)\n    }\n}\n\nasync function handleNewFile(file:File){\n    const fileSchema: {[key: string]: any} = {};\n    const now = new Date().getTime();\n    fileSchema['date'] = now;\n    fileSchema['name'] = `${file.name}`;\n    const filename = `${now}_${file.name}`;\n    await processAndStore(file, '/', filename)\n}\n\nasync function  processAndStore (image: File, path: string, name: string){\n    // const size = await browserImageSize(finalImage)\n    const location = `${path}${name}`\n    const raw = await insertFile(image, location)\n    const metadata = {\n        cid: raw.path.cid.toString(),\n        name: name,\n        path: location,\n    }\n    return metadata\n}\n\n/**\n * Pushes files to the bucket\n * @param file\n * @param path\n */\nasync function  insertFile(file: File, path: string){\n    if (!this.state.buckets || !this.state.bucketKey) {\n        throw new Error('No bucket client or root key')\n    }\n    const buckets: Buckets = this.state.buckets\n    return await buckets.pushPath(this.state.bucketKey, path, file.stream())\n}"]},"metadata":{},"sourceType":"module"}