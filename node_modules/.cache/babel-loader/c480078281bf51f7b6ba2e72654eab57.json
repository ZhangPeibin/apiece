{"ast":null,"code":"import { Buckets } from '@textile/hub';\nimport { Promise as reject } from \"q\";\nexport async function onDropToUpload(acceptedFiles, buckets, bucketKey) {\n  for (const accepted of acceptedFiles) {\n    await handleNewFile(accepted, buckets, bucketKey);\n  }\n}\n\nasync function handleNewFile(file, buckets, bucketKey) {\n  const fileSchema = {};\n  const now = new Date().getTime();\n  fileSchema['date'] = now;\n  fileSchema['name'] = `${file.name}`;\n  const filename = `${file.name}`;\n  const location = `${'/'}${filename}`;\n\n  if (!buckets || !bucketKey) {\n    throw new Error('No bucket client or root key');\n  }\n\n  const reader = new FileReader();\n\n  reader.onabort = () => reject('file reading was aborted');\n\n  reader.onerror = () => reject('file reading has failed');\n\n  reader.onload = () => {\n    const binaryStr = reader.result; // Finally, push the full file to the bucket\n\n    buckets.pushPath(bucketKey, path, binaryStr).then(raw => {});\n  };\n\n  reader.readAsArrayBuffer(file);\n  const raw = await buckets.pushPath(bucketKey, location, file.stream());\n  const metadata = {\n    cid: raw.path.cid.toString(),\n    name: filename,\n    path: location\n  };\n  return metadata;\n}","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/src/common/upload.js"],"names":["Buckets","Promise","reject","onDropToUpload","acceptedFiles","buckets","bucketKey","accepted","handleNewFile","file","fileSchema","now","Date","getTime","name","filename","location","Error","reader","FileReader","onabort","onerror","onload","binaryStr","result","pushPath","path","then","raw","readAsArrayBuffer","stream","metadata","cid","toString"],"mappings":"AAAA,SAASA,OAAT,QAAuB,cAAvB;AACA,SAAQC,OAAO,IAAIC,MAAnB,QAAgC,GAAhC;AAEA,OAAO,eAAeC,cAAf,CAA8BC,aAA9B,EAA4CC,OAA5C,EAAoDC,SAApD,EAA+D;AAClE,OAAK,MAAMC,QAAX,IAAuBH,aAAvB,EAAsC;AAClC,UAAMI,aAAa,CAACD,QAAD,EAAUF,OAAV,EAAkBC,SAAlB,CAAnB;AACH;AACJ;;AAED,eAAeE,aAAf,CAA6BC,IAA7B,EAAuCJ,OAAvC,EAAuDC,SAAvD,EAAiE;AAC7D,QAAMI,UAAgC,GAAG,EAAzC;AACA,QAAMC,GAAG,GAAG,IAAIC,IAAJ,GAAWC,OAAX,EAAZ;AACAH,EAAAA,UAAU,CAAC,MAAD,CAAV,GAAqBC,GAArB;AACAD,EAAAA,UAAU,CAAC,MAAD,CAAV,GAAsB,GAAED,IAAI,CAACK,IAAK,EAAlC;AACA,QAAMC,QAAQ,GAAI,GAAEN,IAAI,CAACK,IAAK,EAA9B;AACA,QAAME,QAAQ,GAAI,GAAE,GAAI,GAAED,QAAS,EAAnC;;AAEA,MAAI,CAACV,OAAD,IAAY,CAACC,SAAjB,EAA4B;AACxB,UAAM,IAAIW,KAAJ,CAAU,8BAAV,CAAN;AACH;;AAED,QAAMC,MAAM,GAAG,IAAIC,UAAJ,EAAf;;AACAD,EAAAA,MAAM,CAACE,OAAP,GAAiB,MAAMlB,MAAM,CAAC,0BAAD,CAA7B;;AACAgB,EAAAA,MAAM,CAACG,OAAP,GAAiB,MAAMnB,MAAM,CAAC,yBAAD,CAA7B;;AACAgB,EAAAA,MAAM,CAACI,MAAP,GAAgB,MAAM;AAClB,UAAMC,SAAS,GAAGL,MAAM,CAACM,MAAzB,CADkB,CAElB;;AACAnB,IAAAA,OAAO,CAACoB,QAAR,CAAiBnB,SAAjB,EAA4BoB,IAA5B,EAAkCH,SAAlC,EAA6CI,IAA7C,CAAmDC,GAAD,IAAS,CAE1D,CAFD;AAGH,GAND;;AAOAV,EAAAA,MAAM,CAACW,iBAAP,CAAyBpB,IAAzB;AAEA,QAAMmB,GAAG,GAAG,MAAMvB,OAAO,CAACoB,QAAR,CAAiBnB,SAAjB,EAA4BU,QAA5B,EAAsCP,IAAI,CAACqB,MAAL,EAAtC,CAAlB;AACA,QAAMC,QAAQ,GAAG;AACbC,IAAAA,GAAG,EAAEJ,GAAG,CAACF,IAAJ,CAASM,GAAT,CAAaC,QAAb,EADQ;AAEbnB,IAAAA,IAAI,EAAEC,QAFO;AAGbW,IAAAA,IAAI,EAAEV;AAHO,GAAjB;AAKA,SAAOe,QAAP;AACH","sourcesContent":["import { Buckets} from '@textile/hub'\nimport {Promise as reject} from \"q\";\n\nexport async function onDropToUpload(acceptedFiles,buckets,bucketKey) {\n    for (const accepted of acceptedFiles) {\n        await handleNewFile(accepted,buckets,bucketKey)\n    }\n}\n\nasync function handleNewFile(file:File,buckets:Buckets,bucketKey){\n    const fileSchema: {[key: string]: any} = {};\n    const now = new Date().getTime();\n    fileSchema['date'] = now;\n    fileSchema['name'] = `${file.name}`;\n    const filename = `${file.name}`;\n    const location = `${'/'}${filename}`;\n\n    if (!buckets || !bucketKey) {\n        throw new Error('No bucket client or root key')\n    }\n\n    const reader = new FileReader();\n    reader.onabort = () => reject('file reading was aborted')\n    reader.onerror = () => reject('file reading has failed')\n    reader.onload = () => {\n        const binaryStr = reader.result\n        // Finally, push the full file to the bucket\n        buckets.pushPath(bucketKey, path, binaryStr).then((raw) => {\n            \n        })\n    }\n    reader.readAsArrayBuffer(file)\n\n    const raw = await buckets.pushPath(bucketKey, location, file.stream())\n    const metadata = {\n        cid: raw.path.cid.toString(),\n        name: filename,\n        path: location,\n    };\n    return metadata;\n}\n\n"]},"metadata":{},"sourceType":"module"}