{"ast":null,"code":"import { getLocalUserIdentity } from \"./user\";\nexport async function getFileIndex(buckets, bucketKey) {\n  try {\n    const metadata = buckets.pullPath(bucketKey, 'index.json');\n    const {\n      value\n    } = await metadata.next();\n    let str = \"\"; // for (let i = 0; i < value.length; i++) {\n    //     str += String.fromCharCode(parseInt(String(value[i])));\n    // }\n\n    str = Utf8ArrayToStr(value);\n    const index = JSON.parse(str);\n    return index;\n  } catch (error) {\n    const index = await initIndex(buckets, bucketKey);\n    return index;\n  }\n}\n\nasync function initIndex(buckets, bucketKey) {\n  const identity = await getLocalUserIdentity();\n\n  if (!identity) {\n    console.error('Identity not set'); // @ts-ignore\n\n    return null;\n  }\n\n  const index = {\n    author: identity.public.toString(),\n    counts: 0,\n    paths: []\n  };\n  await storeIndex(index, buckets, bucketKey);\n  return index;\n}\n\nexport async function storeIndex(index, buckets, bucketKey) {\n  const buf = Buffer.from(JSON.stringify(index, null, 2));\n  const path = `index.json`;\n  await buckets.pushPath(bucketKey, path, buf);\n}\n\nfunction Utf8ArrayToStr(array) {\n  var out, i, len, c;\n  var char2, char3;\n  out = \"\";\n  len = array.length;\n  i = 0;\n\n  while (i < len) {\n    c = array[i++];\n\n    switch (c >> 4) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n        // 0xxxxxxx\n        out += String.fromCharCode(c);\n        break;\n\n      case 12:\n      case 13:\n        // 110x xxxx   10xx xxxx\n        char2 = array[i++];\n        out += String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F);\n        break;\n\n      case 14:\n        // 1110 xxxx  10xx xxxx  10xx xxxx\n        char2 = array[i++];\n        char3 = array[i++];\n        out += String.fromCharCode((c & 0x0F) << 12 | (char2 & 0x3F) << 6 | (char3 & 0x3F) << 0);\n        break;\n    }\n  }\n\n  return out;\n}\n\n_c = Utf8ArrayToStr;\n\nvar _c;\n\n$RefreshReg$(_c, \"Utf8ArrayToStr\");","map":{"version":3,"sources":["E:/anipfspace/src/common/FileIndex.ts"],"names":["getLocalUserIdentity","getFileIndex","buckets","bucketKey","metadata","pullPath","value","next","str","Utf8ArrayToStr","index","JSON","parse","error","initIndex","identity","console","author","public","toString","counts","paths","storeIndex","buf","Buffer","from","stringify","path","pushPath","array","out","i","len","c","char2","char3","length","String","fromCharCode"],"mappings":"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","sourcesContent":["import {FileIndex} from \"./Types\";\r\nimport { Buckets} from '@textile/hub'\r\nimport {getLocalUserIdentity} from \"./user\";\r\n\r\n export async function getFileIndex(buckets:Buckets,bucketKey:string) :Promise<FileIndex>{\r\n    try {\r\n        const metadata = buckets.pullPath(bucketKey ,'index.json');\r\n        const { value } = await metadata.next();\r\n        let str = \"\";\r\n        // for (let i = 0; i < value.length; i++) {\r\n        //     str += String.fromCharCode(parseInt(String(value[i])));\r\n        // }\r\n        str = Utf8ArrayToStr(value);\r\n        const index: FileIndex = JSON.parse(str);\r\n        return index\r\n    } catch (error) {\r\n        const index = await initIndex(buckets,bucketKey);\r\n        return index\r\n    }\r\n}\r\n\r\nasync function  initIndex(buckets:Buckets,bucketKey:string) :Promise<FileIndex> {\r\n    const identity = await getLocalUserIdentity();\r\n    if (!identity) {\r\n        console.error('Identity not set');\r\n        // @ts-ignore\r\n        return null;\r\n    }\r\n    const index = {\r\n        author: identity.public.toString(),\r\n        counts: 0,\r\n        paths: []\r\n    };\r\n    await storeIndex(index,buckets,bucketKey);\r\n    return index\r\n}\r\n\r\nexport async function  storeIndex(index: FileIndex,buckets:Buckets,bucketKey:string) {\r\n    const buf = Buffer.from(JSON.stringify(index, null, 2))\r\n    const path = `index.json`;\r\n    await buckets.pushPath(bucketKey, path, buf)\r\n}\r\n\r\nfunction Utf8ArrayToStr(array:Uint8Array) {\r\n    var out, i, len, c;\r\n    var char2, char3;\r\n\r\n    out = \"\";\r\n    len = array.length;\r\n    i = 0;\r\n    while(i < len) {\r\n        c = array[i++];\r\n        switch(c >> 4)\r\n        {\r\n            case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\r\n            // 0xxxxxxx\r\n            out += String.fromCharCode(c);\r\n            break;\r\n            case 12: case 13:\r\n            // 110x xxxx   10xx xxxx\r\n            char2 = array[i++];\r\n            out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));\r\n            break;\r\n            case 14:\r\n                // 1110 xxxx  10xx xxxx  10xx xxxx\r\n                char2 = array[i++];\r\n                char3 = array[i++];\r\n                out += String.fromCharCode(((c & 0x0F) << 12) |\r\n                    ((char2 & 0x3F) << 6) |\r\n                    ((char3 & 0x3F) << 0));\r\n                break;\r\n        }\r\n    }\r\n\r\n    return out;\r\n}"]},"metadata":{},"sourceType":"module"}