{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst varuint = require('./varint');\n\nexports.range = n => [...Array(n).keys()];\n\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n\n  return buffer;\n}\n\nexports.reverseBuffer = reverseBuffer;\n\nfunction keyValsToBuffer(keyVals) {\n  const buffers = keyVals.map(keyValToBuffer);\n  buffers.push(Buffer.from([0]));\n  return Buffer.concat(buffers);\n}\n\nexports.keyValsToBuffer = keyValsToBuffer;\n\nfunction keyValToBuffer(keyVal) {\n  const keyLen = keyVal.key.length;\n  const valLen = keyVal.value.length;\n  const keyVarIntLen = varuint.encodingLength(keyLen);\n  const valVarIntLen = varuint.encodingLength(valLen);\n  const buffer = Buffer.allocUnsafe(keyVarIntLen + keyLen + valVarIntLen + valLen);\n  varuint.encode(keyLen, buffer, 0);\n  keyVal.key.copy(buffer, keyVarIntLen);\n  varuint.encode(valLen, buffer, keyVarIntLen + keyLen);\n  keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);\n  return buffer;\n}\n\nexports.keyValToBuffer = keyValToBuffer; // https://github.com/feross/buffer/blob/master/index.js#L1127\n\nfunction verifuint(value, max) {\n  if (typeof value !== 'number') throw new Error('cannot write a non-number as a number');\n  if (value < 0) throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value) throw new Error('value has a fractional component');\n}\n\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\n\nexports.readUInt64LE = readUInt64LE;\n\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\n\nexports.writeUInt64LE = writeUInt64LE;","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/bip174/src/lib/converter/tools.js"],"names":["Object","defineProperty","exports","value","varuint","require","range","n","Array","keys","reverseBuffer","buffer","length","j","tmp","i","keyValsToBuffer","keyVals","buffers","map","keyValToBuffer","push","Buffer","from","concat","keyVal","keyLen","key","valLen","keyVarIntLen","encodingLength","valVarIntLen","allocUnsafe","encode","copy","verifuint","max","Error","Math","floor","readUInt64LE","offset","a","readUInt32LE","b","writeUInt64LE","writeInt32LE","writeUInt32LE"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst varuint = require('./varint');\nexports.range = n => [...Array(n).keys()];\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction keyValsToBuffer(keyVals) {\n  const buffers = keyVals.map(keyValToBuffer);\n  buffers.push(Buffer.from([0]));\n  return Buffer.concat(buffers);\n}\nexports.keyValsToBuffer = keyValsToBuffer;\nfunction keyValToBuffer(keyVal) {\n  const keyLen = keyVal.key.length;\n  const valLen = keyVal.value.length;\n  const keyVarIntLen = varuint.encodingLength(keyLen);\n  const valVarIntLen = varuint.encodingLength(valLen);\n  const buffer = Buffer.allocUnsafe(\n    keyVarIntLen + keyLen + valVarIntLen + valLen,\n  );\n  varuint.encode(keyLen, buffer, 0);\n  keyVal.key.copy(buffer, keyVarIntLen);\n  varuint.encode(valLen, buffer, keyVarIntLen + keyLen);\n  keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);\n  return buffer;\n}\nexports.keyValToBuffer = keyValToBuffer;\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0)\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value)\n    throw new Error('value has a fractional component');\n}\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\n"]},"metadata":{},"sourceType":"script"}