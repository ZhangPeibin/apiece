{"ast":null,"code":"import { Buckets } from '@textile/hub';\nexport async function getBucketKeyByBucketRoot(userIdentity, bucketRoot) {\n  if (!userIdentity) {\n    throw new Error('UserIdentity not set');\n  }\n\n  const buckets = await Buckets.withKeyInfo({\n    key: 'bbf34lt5akjatszwybsu5nfhdru'\n  }, {\n    debug: false\n  });\n  await buckets.getToken(userIdentity);\n  const buck = await buckets.getOrCreate(bucketRoot);\n\n  if (!buck.root) {\n    throw new Error('Failed to open bucket');\n  }\n\n  return {\n    buckets: buckets,\n    bucketKey: buck.root.key\n  };\n}\nexport async function getBucketKey(userIdentity) {\n  if (!userIdentity) {\n    throw new Error('UserIdentity not set');\n  }\n\n  const buckets = await Buckets.withKeyInfo({\n    key: 'bbf34lt5akjatszwybsu5nfhdru'\n  }, {\n    debug: false\n  }); // Authorize the user and your insecure keys with getToken\n\n  await buckets.getToken(userIdentity);\n  const bucketZone = getCurrentBucketZone();\n  let buck = null;\n\n  if (bucketZone == null) {\n    buck = await buckets.getOrCreate('yours.space');\n    setCurrentBucketZone('yours.space');\n  } else {\n    buck = await buckets.getOrCreate(bucketZone);\n  }\n\n  if (!buck.root) {\n    throw new Error('Failed to open bucket');\n  }\n\n  return {\n    buckets: buckets,\n    bucketKey: buck.root.key\n  };\n}\nexport function deleteBucketZone() {\n  localStorage.removeItem(\"bucket.zone\");\n}\nexport function getCurrentBucketZone() {\n  const bucketZone = localStorage.getItem(\"bucket.zone\");\n\n  if (bucketZone == null) {\n    return null;\n  }\n\n  return bucketZone;\n}\nexport function setCurrentBucketZone(bucketZone) {\n  localStorage.removeItem(\"bucket.zone\");\n  localStorage.setItem(\"bucket.zone\", bucketZone);\n}\nexport async function bucketLinks(buckets, bucketKey) {\n  const links = await buckets.links(bucketKey);\n  return links;\n}\nexport async function bucketList(buckets) {\n  const bucketRoots = await buckets.list();\n  return bucketRoots;\n}\nexport async function deleteBucket(buckets, bucketKey) {\n  await buckets.remove(bucketKey);\n}\nexport async function removeBucketPath(buckets, bucketKey, deleteFilePath) {\n  const removeResponse = await buckets.removePath(bucketKey, deleteFilePath);\n  return removeResponse;\n}","map":{"version":3,"sources":["E:/anipfspace/src/common/bucket.ts"],"names":["Buckets","getBucketKeyByBucketRoot","userIdentity","bucketRoot","Error","buckets","withKeyInfo","key","debug","getToken","buck","getOrCreate","root","bucketKey","getBucketKey","bucketZone","getCurrentBucketZone","setCurrentBucketZone","deleteBucketZone","localStorage","removeItem","getItem","setItem","bucketLinks","links","bucketList","bucketRoots","list","deleteBucket","remove","removeBucketPath","deleteFilePath","removeResponse","removePath"],"mappings":"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","sourcesContent":["import { Buckets, PushPathResult, KeyInfo, PrivateKey, WithKeyInfoOptions, Root } from '@textile/hub'\r\nimport {async} from \"q\";\r\nimport {func, string} from \"prop-types\";\r\n\r\nexport async function getBucketKeyByBucketRoot(userIdentity:PrivateKey,bucketRoot:string) {\r\n    if (!userIdentity) {\r\n        throw new Error('UserIdentity not set')\r\n    }\r\n    const buckets = await Buckets.withKeyInfo({\r\n        key: 'bbf34lt5akjatszwybsu5nfhdru'\r\n    } ,{\r\n        debug: false\r\n    });\r\n\r\n    await buckets.getToken(userIdentity);\r\n    const buck = await buckets.getOrCreate(bucketRoot);\r\n    if (!buck.root) {\r\n        throw new Error('Failed to open bucket')\r\n    }\r\n    return {buckets: buckets, bucketKey: buck.root.key};\r\n}\r\n\r\nexport async function getBucketKey(userIdentity:PrivateKey) {\r\n    if (!userIdentity) {\r\n        throw new Error('UserIdentity not set')\r\n    }\r\n    const buckets = await Buckets.withKeyInfo({\r\n        key: 'bbf34lt5akjatszwybsu5nfhdru'\r\n    } ,{\r\n        debug: false\r\n    });\r\n\r\n    // Authorize the user and your insecure keys with getToken\r\n    await buckets.getToken(userIdentity);\r\n    const bucketZone = getCurrentBucketZone();\r\n    let buck = null;\r\n    if(bucketZone==null){\r\n        buck = await buckets.getOrCreate('yours.space');\r\n        setCurrentBucketZone('yours.space')\r\n    }else{\r\n        buck = await buckets.getOrCreate(bucketZone)\r\n    }\r\n    if (!buck.root) {\r\n        throw new Error('Failed to open bucket')\r\n    }\r\n    return {buckets: buckets, bucketKey: buck.root.key};\r\n}\r\nexport  function deleteBucketZone() {\r\n    localStorage.removeItem(\"bucket.zone\");\r\n}\r\n\r\nexport  function getCurrentBucketZone()  {\r\n    const bucketZone = localStorage.getItem(\"bucket.zone\");\r\n    if( bucketZone==null){\r\n        return null;\r\n    }\r\n    return bucketZone\r\n}\r\n\r\nexport  function setCurrentBucketZone(bucketZone:string) {\r\n    localStorage.removeItem(\"bucket.zone\");\r\n    localStorage.setItem(\"bucket.zone\",bucketZone)\r\n}\r\n\r\n\r\nexport async function bucketLinks(buckets:Buckets,bucketKey:string) {\r\n    const links = await buckets.links(bucketKey);\r\n    return links;\r\n}\r\n\r\nexport async function bucketList(buckets:Buckets): Promise<Root[]>  {\r\n    const bucketRoots = await buckets.list();\r\n    return bucketRoots;\r\n}\r\n\r\nexport async function deleteBucket(buckets:Buckets,bucketKey:string) {\r\n    await buckets.remove(bucketKey)\r\n}\r\n\r\nexport async function removeBucketPath(buckets:Buckets,bucketKey:string,deleteFilePath: string) {\r\n    const  removeResponse = await buckets.removePath(bucketKey,deleteFilePath)\r\n    return removeResponse;\r\n}"]},"metadata":{},"sourceType":"module"}