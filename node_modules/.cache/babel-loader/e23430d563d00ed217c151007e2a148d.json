{"ast":null,"code":"\"use strict\";\n/*! noble-ed25519 - MIT License (c) Paul Miller (paulmillr.com) */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.utils = exports.verify = exports.sign = exports.getPublicKey = exports.SignResult = exports.Signature = exports.Point = exports.ExtendedPoint = exports.CURVE = void 0;\nconst CURVE = {\n  a: -1n,\n  d: 37095705934669439343138083508754565189542113879843219016388785533085940283555n,\n  P: 2n ** 255n - 19n,\n  n: 2n ** 252n + 27742317777372353535851937790883648493n,\n  h: 8n,\n  Gx: 15112221349535400772501151409588531511454012693041857206046113283949847762202n,\n  Gy: 46316835694926478169428394003475163141307993866256225615783033603165251855960n\n};\nexports.CURVE = CURVE;\nconst B32 = 32;\nconst SQRT_M1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n;\nconst SQRT_AD_MINUS_ONE = 25063068953384623474111414158702152701244531502492656460079210482610430750235n;\nconst INVSQRT_A_MINUS_D = 54469307008909316920995813868745141605393597292927456921205312896311721017578n;\nconst ONE_MINUS_D_SQ = 1159843021668779879193775521855586647937357759715417654439879720876111806838n;\nconst D_MINUS_ONE_SQ = 40440834346308536858101042469323190826248399146238708352240133220865137265952n;\n\nclass ExtendedPoint {\n  constructor(x, y, z, t) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.t = t;\n  }\n\n  static fromAffine(p) {\n    if (!(p instanceof Point)) {\n      throw new TypeError('ExtendedPoint#fromAffine: expected Point');\n    }\n\n    if (p.equals(Point.ZERO)) return ExtendedPoint.ZERO;\n    return new ExtendedPoint(p.x, p.y, 1n, mod(p.x * p.y));\n  }\n\n  static toAffineBatch(points) {\n    const toInv = invertBatch(points.map(p => p.z));\n    return points.map((p, i) => p.toAffine(toInv[i]));\n  }\n\n  static normalizeZ(points) {\n    return this.toAffineBatch(points).map(this.fromAffine);\n  }\n\n  static fromRistrettoHash(hash) {\n    const r1 = bytes255ToNumberLE(hash.slice(0, B32));\n    const R1 = this.calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(hash.slice(B32, B32 * 2));\n    const R2 = this.calcElligatorRistrettoMap(r2);\n    return R1.add(R2);\n  }\n\n  static calcElligatorRistrettoMap(r0) {\n    const {\n      d\n    } = CURVE;\n    const r = mod(SQRT_M1 * r0 * r0);\n    const Ns = mod((r + 1n) * ONE_MINUS_D_SQ);\n    let c = -1n;\n    const D = mod((c - d * r) * mod(r + d));\n    let {\n      isValid: Ns_D_is_sq,\n      value: s\n    } = uvRatio(Ns, D);\n    let s_ = mod(s * r0);\n    if (!edIsNegative(s_)) s_ = mod(-s_);\n    if (!Ns_D_is_sq) s = s_;\n    if (!Ns_D_is_sq) c = r;\n    const Nt = mod(c * (r - 1n) * D_MINUS_ONE_SQ - D);\n    const s2 = s * s;\n    const W0 = mod((s + s) * D);\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n    const W2 = mod(1n - s2);\n    const W3 = mod(1n + s2);\n    return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n  }\n\n  static fromRistrettoBytes(bytes) {\n    const {\n      a,\n      d\n    } = CURVE;\n    const emsg = 'ExtendedPoint.fromRistrettoBytes: Cannot convert bytes to Ristretto Point';\n    const s = bytes255ToNumberLE(bytes);\n    if (!equalBytes(numberToBytesPadded(s, B32), bytes) || edIsNegative(s)) throw new Error(emsg);\n    const s2 = mod(s * s);\n    const u1 = mod(1n + a * s2);\n    const u2 = mod(1n - a * s2);\n    const u1_2 = mod(u1 * u1);\n    const u2_2 = mod(u2 * u2);\n    const v = mod(a * d * u1_2 - u2_2);\n    const {\n      isValid,\n      value: I\n    } = invertSqrt(mod(v * u2_2));\n    const Dx = mod(I * u2);\n    const Dy = mod(I * Dx * v);\n    let x = mod((s + s) * Dx);\n    if (edIsNegative(x)) x = mod(-x);\n    const y = mod(u1 * Dy);\n    const t = mod(x * y);\n    if (!isValid || edIsNegative(t) || y === 0n) throw new Error(emsg);\n    return new ExtendedPoint(x, y, 1n, t);\n  }\n\n  toRistrettoBytes() {\n    let {\n      x,\n      y,\n      z,\n      t\n    } = this;\n    const u1 = mod((z + y) * (z - y));\n    const u2 = mod(x * y);\n    const {\n      value: invsqrt\n    } = invertSqrt(mod(u1 * u2 ** 2n));\n    const D1 = mod(invsqrt * u1);\n    const D2 = mod(invsqrt * u2);\n    const zInv = mod(D1 * D2 * t);\n    let D;\n\n    if (edIsNegative(t * zInv)) {\n      [x, y] = [mod(y * SQRT_M1), mod(x * SQRT_M1)];\n      D = mod(D1 * INVSQRT_A_MINUS_D);\n    } else {\n      D = D2;\n    }\n\n    if (edIsNegative(x * zInv)) y = mod(-y);\n    let s = mod((z - y) * D);\n    if (edIsNegative(s)) s = mod(-s);\n    return numberToBytesPadded(s, B32);\n  }\n\n  equals(other) {\n    const a = this;\n    const b = other;\n    const [T1, T2, Z1, Z2] = [a.t, b.t, a.z, b.z];\n    return mod(T1 * Z2) === mod(T2 * Z1);\n  }\n\n  negate() {\n    return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n  }\n\n  double() {\n    const X1 = this.x;\n    const Y1 = this.y;\n    const Z1 = this.z;\n    const {\n      a\n    } = CURVE;\n    const A = mod(X1 ** 2n);\n    const B = mod(Y1 ** 2n);\n    const C = mod(2n * Z1 ** 2n);\n    const D = mod(a * A);\n    const E = mod((X1 + Y1) ** 2n - A - B);\n    const G = mod(D + B);\n    const F = mod(G - C);\n    const H = mod(D - B);\n    const X3 = mod(E * F);\n    const Y3 = mod(G * H);\n    const T3 = mod(E * H);\n    const Z3 = mod(F * G);\n    return new ExtendedPoint(X3, Y3, Z3, T3);\n  }\n\n  add(other) {\n    const X1 = this.x;\n    const Y1 = this.y;\n    const Z1 = this.z;\n    const T1 = this.t;\n    const X2 = other.x;\n    const Y2 = other.y;\n    const Z2 = other.z;\n    const T2 = other.t;\n    const A = mod((Y1 - X1) * (Y2 + X2));\n    const B = mod((Y1 + X1) * (Y2 - X2));\n    const F = mod(B - A);\n\n    if (F === 0n) {\n      return this.double();\n    }\n\n    const C = mod(Z1 * 2n * T2);\n    const D = mod(T1 * 2n * Z2);\n    const E = mod(D + C);\n    const G = mod(B + A);\n    const H = mod(D - C);\n    const X3 = mod(E * F);\n    const Y3 = mod(G * H);\n    const T3 = mod(E * H);\n    const Z3 = mod(F * G);\n    return new ExtendedPoint(X3, Y3, Z3, T3);\n  }\n\n  subtract(other) {\n    return this.add(other.negate());\n  }\n\n  multiplyUnsafe(scalar) {\n    if (!isValidScalar(scalar)) throw new TypeError('Point#multiply: expected number or bigint');\n    let n = mod(BigInt(scalar), CURVE.n);\n    if (n === 1n) return this;\n    let p = ExtendedPoint.ZERO;\n    let d = this;\n\n    while (n > 0n) {\n      if (n & 1n) p = p.add(d);\n      d = d.double();\n      n >>= 1n;\n    }\n\n    return p;\n  }\n\n  precomputeWindow(W) {\n    const windows = 256 / W + 1;\n    let points = [];\n    let p = this;\n    let base = p;\n\n    for (let window = 0; window < windows; window++) {\n      base = p;\n      points.push(base);\n\n      for (let i = 1; i < 2 ** (W - 1); i++) {\n        base = base.add(p);\n        points.push(base);\n      }\n\n      p = base.double();\n    }\n\n    return points;\n  }\n\n  wNAF(n, affinePoint) {\n    if (!affinePoint && this.equals(ExtendedPoint.BASE)) affinePoint = Point.BASE;\n    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n\n    if (256 % W) {\n      throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n    }\n\n    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n\n    if (!precomputes) {\n      precomputes = this.precomputeWindow(W);\n\n      if (affinePoint && W !== 1) {\n        precomputes = ExtendedPoint.normalizeZ(precomputes);\n        pointPrecomputes.set(affinePoint, precomputes);\n      }\n    }\n\n    let p = ExtendedPoint.ZERO;\n    let f = ExtendedPoint.ZERO;\n    const windows = 256 / W + 1;\n    const windowSize = 2 ** (W - 1);\n    const mask = BigInt(2 ** W - 1);\n    const maxNumber = 2 ** W;\n    const shiftBy = BigInt(W);\n\n    for (let window = 0; window < windows; window++) {\n      const offset = window * windowSize;\n      let wbits = Number(n & mask);\n      n >>= shiftBy;\n\n      if (wbits > windowSize) {\n        wbits -= maxNumber;\n        n += 1n;\n      }\n\n      if (wbits === 0) {\n        f = f.add(window % 2 ? precomputes[offset].negate() : precomputes[offset]);\n      } else {\n        const cached = precomputes[offset + Math.abs(wbits) - 1];\n        p = p.add(wbits < 0 ? cached.negate() : cached);\n      }\n    }\n\n    return [p, f];\n  }\n\n  multiply(scalar, affinePoint) {\n    if (!isValidScalar(scalar)) throw new TypeError('Point#multiply: expected number or bigint');\n    const n = mod(BigInt(scalar), CURVE.n);\n    return ExtendedPoint.normalizeZ(this.wNAF(n, affinePoint))[0];\n  }\n\n  toAffine(invZ = invert(this.z)) {\n    const x = mod(this.x * invZ);\n    const y = mod(this.y * invZ);\n    return new Point(x, y);\n  }\n\n}\n\nexports.ExtendedPoint = ExtendedPoint;\nExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, 1n, mod(CURVE.Gx * CURVE.Gy));\nExtendedPoint.ZERO = new ExtendedPoint(0n, 1n, 1n, 0n);\nconst pointPrecomputes = new WeakMap();\n\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  _setWindowSize(windowSize) {\n    this._WINDOW_SIZE = windowSize;\n    pointPrecomputes.delete(this);\n  }\n\n  static fromHex(hash) {\n    const {\n      d,\n      P\n    } = CURVE;\n    const bytes = hash instanceof Uint8Array ? hash : hexToBytes(hash);\n    if (bytes.length !== 32) throw new Error('Point.fromHex: expected 32 bytes');\n    const last = bytes[31];\n    const normedLast = last & ~0x80;\n    const isLastByteOdd = (last & 0x80) !== 0;\n    const normed = Uint8Array.from(Array.from(bytes.slice(0, 31)).concat(normedLast));\n    const y = bytesToNumberLE(normed);\n    if (y >= P) throw new Error('Point.fromHex expects hex <= Fp');\n    const y2 = mod(y * y);\n    const u = mod(y2 - 1n);\n    const v = mod(d * y2 + 1n);\n    let {\n      isValid,\n      value: x\n    } = uvRatio(u, v);\n    if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n    const isXOdd = (x & 1n) === 1n;\n\n    if (isLastByteOdd !== isXOdd) {\n      x = mod(-x);\n    }\n\n    return new Point(x, y);\n  }\n\n  static async fromPrivateKey(privateKey) {\n    const privBytes = await exports.utils.sha512(normalizePrivateKey(privateKey));\n    return Point.BASE.multiply(encodePrivate(privBytes));\n  }\n\n  toRawBytes() {\n    const hex = numberToHex(this.y);\n    const u8 = new Uint8Array(B32);\n\n    for (let i = hex.length - 2, j = 0; j < B32 && i >= 0; i -= 2, j++) {\n      u8[j] = Number.parseInt(hex[i] + hex[i + 1], 16);\n    }\n\n    const mask = this.x & 1n ? 0x80 : 0;\n    u8[B32 - 1] |= mask;\n    return u8;\n  }\n\n  toHex() {\n    return bytesToHex(this.toRawBytes());\n  }\n\n  toX25519() {\n    return mod((1n + this.y) * invert(1n - this.y));\n  }\n\n  equals(other) {\n    return this.x === other.x && this.y === other.y;\n  }\n\n  negate() {\n    return new Point(mod(-this.x), this.y);\n  }\n\n  add(other) {\n    return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n  }\n\n  subtract(other) {\n    return this.add(other.negate());\n  }\n\n  multiply(scalar) {\n    return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n  }\n\n}\n\nexports.Point = Point;\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(0n, 1n);\n\nclass Signature {\n  constructor(r, s) {\n    this.r = r;\n    this.s = s;\n  }\n\n  static fromHex(hex) {\n    hex = ensureBytes(hex);\n    const r = Point.fromHex(hex.slice(0, 32));\n    const s = bytesToNumberLE(hex.slice(32));\n    if (!isWithinCurveOrder(s)) throw new Error('Signature.fromHex expects s <= CURVE.n');\n    return new Signature(r, s);\n  }\n\n  toRawBytes() {\n    const numberBytes = hexToBytes(numberToHex(this.s)).reverse();\n    const sBytes = new Uint8Array(B32);\n    sBytes.set(numberBytes);\n    const res = new Uint8Array(B32 * 2);\n    res.set(this.r.toRawBytes());\n    res.set(sBytes, 32);\n    return res;\n  }\n\n  toHex() {\n    return bytesToHex(this.toRawBytes());\n  }\n\n}\n\nexports.Signature = Signature;\nexports.SignResult = Signature;\n\nfunction concatBytes(...arrays) {\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n\n  return result;\n}\n\nfunction bytesToHex(uint8a) {\n  let hex = '';\n\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += uint8a[i].toString(16).padStart(2, '0');\n  }\n\n  return hex;\n}\n\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string' || hex.length % 2) throw new Error('Expected valid hex');\n  const array = new Uint8Array(hex.length / 2);\n\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    array[i] = Number.parseInt(hex.slice(j, j + 2), 16);\n  }\n\n  return array;\n}\n\nfunction numberToHex(num) {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\n\nfunction numberToBytesPadded(num, length = B32) {\n  const hex = numberToHex(num).padStart(length * 2, '0');\n  return hexToBytes(hex).reverse();\n}\n\nfunction edIsNegative(num) {\n  return (mod(num) & 1n) === 1n;\n}\n\nfunction isValidScalar(num) {\n  if (typeof num === 'bigint' && num > 0n) return true;\n  if (typeof num === 'number' && num > 0 && Number.isSafeInteger(num)) return true;\n  return false;\n}\n\nfunction bytesToNumberLE(uint8a) {\n  let value = 0n;\n\n  for (let i = 0; i < uint8a.length; i++) {\n    value += BigInt(uint8a[i]) << 8n * BigInt(i);\n  }\n\n  return value;\n}\n\nfunction bytes255ToNumberLE(bytes) {\n  return mod(bytesToNumberLE(bytes) & 2n ** 255n - 1n);\n}\n\nfunction mod(a, b = CURVE.P) {\n  const res = a % b;\n  return res >= 0n ? res : b + res;\n}\n\nfunction invert(number, modulo = CURVE.P) {\n  if (number === 0n || modulo <= 0n) {\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n  }\n\n  let a = mod(number, modulo);\n  let b = modulo;\n  let [x, y, u, v] = [0n, 1n, 1n, 0n];\n\n  while (a !== 0n) {\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    [b, a] = [a, r];\n    [x, y] = [u, v];\n    [u, v] = [m, n];\n  }\n\n  const gcd = b;\n  if (gcd !== 1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\nfunction invertBatch(nums, n = CURVE.P) {\n  const len = nums.length;\n  const scratch = new Array(len);\n  let acc = 1n;\n\n  for (let i = 0; i < len; i++) {\n    if (nums[i] === 0n) continue;\n    scratch[i] = acc;\n    acc = mod(acc * nums[i], n);\n  }\n\n  acc = invert(acc, n);\n\n  for (let i = len - 1; i >= 0; i--) {\n    if (nums[i] === 0n) continue;\n    let tmp = mod(acc * nums[i], n);\n    nums[i] = mod(acc * scratch[i], n);\n    acc = tmp;\n  }\n\n  return nums;\n}\n\nfunction pow2(x, power) {\n  const {\n    P\n  } = CURVE;\n  let res = x;\n\n  while (power-- > 0n) {\n    res *= res;\n    res %= P;\n  }\n\n  return res;\n}\n\nfunction pow_2_252_3(x) {\n  const {\n    P\n  } = CURVE;\n  const x2 = x * x % P;\n  const b2 = x2 * x % P;\n  const b4 = pow2(b2, 2n) * b2 % P;\n  const b5 = pow2(b4, 1n) * x % P;\n  const b10 = pow2(b5, 5n) * b5 % P;\n  const b20 = pow2(b10, 10n) * b10 % P;\n  const b40 = pow2(b20, 20n) * b20 % P;\n  const b80 = pow2(b40, 40n) * b40 % P;\n  const b160 = pow2(b80, 80n) * b80 % P;\n  const b240 = pow2(b160, 80n) * b80 % P;\n  const b250 = pow2(b240, 10n) * b10 % P;\n  const pow_p_5_8 = pow2(b250, 2n) * x % P;\n  return pow_p_5_8;\n}\n\nfunction uvRatio(u, v) {\n  const v3 = mod(v * v * v);\n  const v7 = mod(v3 * v3 * v);\n  let x = mod(u * v3 * pow_2_252_3(u * v7));\n  const vx2 = mod(v * x * x);\n  const root1 = x;\n  const root2 = mod(x * SQRT_M1);\n  const useRoot1 = vx2 === u;\n  const useRoot2 = vx2 === mod(-u);\n  const noRoot = vx2 === mod(-u * SQRT_M1);\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2;\n  if (edIsNegative(x)) x = mod(-x);\n  return {\n    isValid: useRoot1 || useRoot2,\n    value: x\n  };\n}\n\nfunction invertSqrt(number) {\n  return uvRatio(1n, number);\n}\n\nasync function sha512ToNumberLE(...args) {\n  const messageArray = concatBytes(...args);\n  const hash = await exports.utils.sha512(messageArray);\n  const value = bytesToNumberLE(hash);\n  return mod(value, CURVE.n);\n}\n\nfunction keyPrefix(privateBytes) {\n  return privateBytes.slice(B32);\n}\n\nfunction encodePrivate(privateBytes) {\n  const last = B32 - 1;\n  const head = privateBytes.slice(0, B32);\n  head[0] &= 248;\n  head[last] &= 127;\n  head[last] |= 64;\n  return mod(bytesToNumberLE(head), CURVE.n);\n}\n\nfunction equalBytes(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] !== b2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction ensureBytes(hash) {\n  return hash instanceof Uint8Array ? hash : hexToBytes(hash);\n}\n\nfunction isWithinCurveOrder(num) {\n  return 0 < num && num < CURVE.n;\n}\n\nfunction normalizePrivateKey(key) {\n  let num;\n\n  if (typeof key === 'bigint' || typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n    num = BigInt(key);\n    key = num.toString(16).padStart(B32 * 2, '0');\n  }\n\n  if (typeof key === 'string') {\n    if (key.length !== 64) throw new Error('Expected 32 bytes of private key');\n    return hexToBytes(key);\n  } else if (key instanceof Uint8Array) {\n    if (key.length !== 32) throw new Error('Expected 32 bytes of private key');\n    return key;\n  } else {\n    throw new TypeError('Expected valid private key');\n  }\n}\n\nasync function getPublicKey(privateKey) {\n  const key = await Point.fromPrivateKey(privateKey);\n  return typeof privateKey === 'string' ? key.toHex() : key.toRawBytes();\n}\n\nexports.getPublicKey = getPublicKey;\n\nasync function sign(hash, privateKey) {\n  const privBytes = await exports.utils.sha512(normalizePrivateKey(privateKey));\n  const p = encodePrivate(privBytes);\n  const P = Point.BASE.multiply(p);\n  const msg = ensureBytes(hash);\n  const r = await sha512ToNumberLE(keyPrefix(privBytes), msg);\n  const R = Point.BASE.multiply(r);\n  const h = await sha512ToNumberLE(R.toRawBytes(), P.toRawBytes(), msg);\n  const S = mod(r + h * p, CURVE.n);\n  const sig = new Signature(R, S);\n  return typeof hash === 'string' ? sig.toHex() : sig.toRawBytes();\n}\n\nexports.sign = sign;\n\nasync function verify(signature, hash, publicKey) {\n  hash = ensureBytes(hash);\n  if (!(publicKey instanceof Point)) publicKey = Point.fromHex(publicKey);\n  if (!(signature instanceof Signature)) signature = Signature.fromHex(signature);\n  const hs = await sha512ToNumberLE(signature.r.toRawBytes(), publicKey.toRawBytes(), hash);\n  const Ph = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(hs);\n  const Gs = ExtendedPoint.BASE.multiply(signature.s);\n  const RPh = ExtendedPoint.fromAffine(signature.r).add(Ph);\n  return RPh.subtract(Gs).multiplyUnsafe(8n).equals(ExtendedPoint.ZERO);\n}\n\nexports.verify = verify;\n\nPoint.BASE._setWindowSize(8);\n\nexports.utils = {\n  TORSION_SUBGROUP: ['0100000000000000000000000000000000000000000000000000000000000000', 'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a', '0000000000000000000000000000000000000000000000000000000000000080', '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05', 'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f', '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85', '0000000000000000000000000000000000000000000000000000000000000000', 'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa'],\n  randomPrivateKey: (bytesLength = 32) => {\n    if (typeof window == 'object' && 'crypto' in window) {\n      return window.crypto.getRandomValues(new Uint8Array(bytesLength));\n    } else if (typeof process === 'object' && 'node' in process.versions) {\n      const {\n        randomBytes\n      } = require('crypto');\n\n      return new Uint8Array(randomBytes(bytesLength).buffer);\n    } else {\n      throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n  },\n  sha512: async message => {\n    if (typeof window == 'object' && 'crypto' in window) {\n      const buffer = await window.crypto.subtle.digest('SHA-512', message.buffer);\n      return new Uint8Array(buffer);\n    } else if (typeof process === 'object' && 'node' in process.versions) {\n      const {\n        createHash\n      } = require('crypto');\n\n      const hash = createHash('sha512');\n      hash.update(message);\n      return Uint8Array.from(hash.digest());\n    } else {\n      throw new Error(\"The environment doesn't have sha512 function\");\n    }\n  },\n\n  precompute(windowSize = 8, point = Point.BASE) {\n    const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n\n    cached._setWindowSize(windowSize);\n\n    cached.multiply(1n);\n    return cached;\n  }\n\n};","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/noble-ed25519/index.js"],"names":["Object","defineProperty","exports","value","utils","verify","sign","getPublicKey","SignResult","Signature","Point","ExtendedPoint","CURVE","a","d","P","n","h","Gx","Gy","B32","SQRT_M1","SQRT_AD_MINUS_ONE","INVSQRT_A_MINUS_D","ONE_MINUS_D_SQ","D_MINUS_ONE_SQ","constructor","x","y","z","t","fromAffine","p","TypeError","equals","ZERO","mod","toAffineBatch","points","toInv","invertBatch","map","i","toAffine","normalizeZ","fromRistrettoHash","hash","r1","bytes255ToNumberLE","slice","R1","calcElligatorRistrettoMap","r2","R2","add","r0","r","Ns","c","D","isValid","Ns_D_is_sq","s","uvRatio","s_","edIsNegative","Nt","s2","W0","W1","W2","W3","fromRistrettoBytes","bytes","emsg","equalBytes","numberToBytesPadded","Error","u1","u2","u1_2","u2_2","v","I","invertSqrt","Dx","Dy","toRistrettoBytes","invsqrt","D1","D2","zInv","other","b","T1","T2","Z1","Z2","negate","double","X1","Y1","A","B","C","E","G","F","H","X3","Y3","T3","Z3","X2","Y2","subtract","multiplyUnsafe","scalar","isValidScalar","BigInt","precomputeWindow","W","windows","base","window","push","wNAF","affinePoint","BASE","_WINDOW_SIZE","precomputes","pointPrecomputes","get","set","f","windowSize","mask","maxNumber","shiftBy","offset","wbits","Number","cached","Math","abs","multiply","invZ","invert","WeakMap","_setWindowSize","delete","fromHex","Uint8Array","hexToBytes","length","last","normedLast","isLastByteOdd","normed","from","Array","concat","bytesToNumberLE","y2","u","isXOdd","fromPrivateKey","privateKey","privBytes","sha512","normalizePrivateKey","encodePrivate","toRawBytes","hex","numberToHex","u8","j","parseInt","toHex","bytesToHex","toX25519","ensureBytes","isWithinCurveOrder","numberBytes","reverse","sBytes","res","concatBytes","arrays","reduce","arr","result","pad","uint8a","toString","padStart","array","num","isSafeInteger","number","modulo","q","m","gcd","nums","len","scratch","acc","tmp","pow2","power","pow_2_252_3","x2","b2","b4","b5","b10","b20","b40","b80","b160","b240","b250","pow_p_5_8","v3","v7","vx2","root1","root2","useRoot1","useRoot2","noRoot","sha512ToNumberLE","args","messageArray","keyPrefix","privateBytes","head","b1","key","msg","R","S","sig","signature","publicKey","hs","Ph","Gs","RPh","TORSION_SUBGROUP","randomPrivateKey","bytesLength","crypto","getRandomValues","process","versions","randomBytes","require","buffer","message","subtle","digest","createHash","update","precompute","point"],"mappings":"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","sourcesContent":["\"use strict\";\n/*! noble-ed25519 - MIT License (c) Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.utils = exports.verify = exports.sign = exports.getPublicKey = exports.SignResult = exports.Signature = exports.Point = exports.ExtendedPoint = exports.CURVE = void 0;\nconst CURVE = {\n    a: -1n,\n    d: 37095705934669439343138083508754565189542113879843219016388785533085940283555n,\n    P: 2n ** 255n - 19n,\n    n: 2n ** 252n + 27742317777372353535851937790883648493n,\n    h: 8n,\n    Gx: 15112221349535400772501151409588531511454012693041857206046113283949847762202n,\n    Gy: 46316835694926478169428394003475163141307993866256225615783033603165251855960n,\n};\nexports.CURVE = CURVE;\nconst B32 = 32;\nconst SQRT_M1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n;\nconst SQRT_AD_MINUS_ONE = 25063068953384623474111414158702152701244531502492656460079210482610430750235n;\nconst INVSQRT_A_MINUS_D = 54469307008909316920995813868745141605393597292927456921205312896311721017578n;\nconst ONE_MINUS_D_SQ = 1159843021668779879193775521855586647937357759715417654439879720876111806838n;\nconst D_MINUS_ONE_SQ = 40440834346308536858101042469323190826248399146238708352240133220865137265952n;\nclass ExtendedPoint {\n    constructor(x, y, z, t) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.t = t;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('ExtendedPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return ExtendedPoint.ZERO;\n        return new ExtendedPoint(p.x, p.y, 1n, mod(p.x * p.y));\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return this.toAffineBatch(points).map(this.fromAffine);\n    }\n    static fromRistrettoHash(hash) {\n        const r1 = bytes255ToNumberLE(hash.slice(0, B32));\n        const R1 = this.calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hash.slice(B32, B32 * 2));\n        const R2 = this.calcElligatorRistrettoMap(r2);\n        return R1.add(R2);\n    }\n    static calcElligatorRistrettoMap(r0) {\n        const { d } = CURVE;\n        const r = mod(SQRT_M1 * r0 * r0);\n        const Ns = mod((r + 1n) * ONE_MINUS_D_SQ);\n        let c = -1n;\n        const D = mod((c - d * r) * mod(r + d));\n        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);\n        let s_ = mod(s * r0);\n        if (!edIsNegative(s_))\n            s_ = mod(-s_);\n        if (!Ns_D_is_sq)\n            s = s_;\n        if (!Ns_D_is_sq)\n            c = r;\n        const Nt = mod(c * (r - 1n) * D_MINUS_ONE_SQ - D);\n        const s2 = s * s;\n        const W0 = mod((s + s) * D);\n        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n        const W2 = mod(1n - s2);\n        const W3 = mod(1n + s2);\n        return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n    }\n    static fromRistrettoBytes(bytes) {\n        const { a, d } = CURVE;\n        const emsg = 'ExtendedPoint.fromRistrettoBytes: Cannot convert bytes to Ristretto Point';\n        const s = bytes255ToNumberLE(bytes);\n        if (!equalBytes(numberToBytesPadded(s, B32), bytes) || edIsNegative(s))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(1n + a * s2);\n        const u2 = mod(1n - a * s2);\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2);\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2));\n        const Dx = mod(I * u2);\n        const Dy = mod(I * Dx * v);\n        let x = mod((s + s) * Dx);\n        if (edIsNegative(x))\n            x = mod(-x);\n        const y = mod(u1 * Dy);\n        const t = mod(x * y);\n        if (!isValid || edIsNegative(t) || y === 0n)\n            throw new Error(emsg);\n        return new ExtendedPoint(x, y, 1n, t);\n    }\n    toRistrettoBytes() {\n        let { x, y, z, t } = this;\n        const u1 = mod((z + y) * (z - y));\n        const u2 = mod(x * y);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2 ** 2n));\n        const D1 = mod(invsqrt * u1);\n        const D2 = mod(invsqrt * u2);\n        const zInv = mod(D1 * D2 * t);\n        let D;\n        if (edIsNegative(t * zInv)) {\n            [x, y] = [mod(y * SQRT_M1), mod(x * SQRT_M1)];\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2;\n        }\n        if (edIsNegative(x * zInv))\n            y = mod(-y);\n        let s = mod((z - y) * D);\n        if (edIsNegative(s))\n            s = mod(-s);\n        return numberToBytesPadded(s, B32);\n    }\n    equals(other) {\n        const a = this;\n        const b = other;\n        const [T1, T2, Z1, Z2] = [a.t, b.t, a.z, b.z];\n        return mod(T1 * Z2) === mod(T2 * Z1);\n    }\n    negate() {\n        return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n    }\n    double() {\n        const X1 = this.x;\n        const Y1 = this.y;\n        const Z1 = this.z;\n        const { a } = CURVE;\n        const A = mod(X1 ** 2n);\n        const B = mod(Y1 ** 2n);\n        const C = mod(2n * Z1 ** 2n);\n        const D = mod(a * A);\n        const E = mod((X1 + Y1) ** 2n - A - B);\n        const G = mod(D + B);\n        const F = mod(G - C);\n        const H = mod(D - B);\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    add(other) {\n        const X1 = this.x;\n        const Y1 = this.y;\n        const Z1 = this.z;\n        const T1 = this.t;\n        const X2 = other.x;\n        const Y2 = other.y;\n        const Z2 = other.z;\n        const T2 = other.t;\n        const A = mod((Y1 - X1) * (Y2 + X2));\n        const B = mod((Y1 + X1) * (Y2 - X2));\n        const F = mod(B - A);\n        if (F === 0n) {\n            return this.double();\n        }\n        const C = mod(Z1 * 2n * T2);\n        const D = mod(T1 * 2n * Z2);\n        const E = mod(D + C);\n        const G = mod(B + A);\n        const H = mod(D - C);\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        if (!isValidScalar(scalar))\n            throw new TypeError('Point#multiply: expected number or bigint');\n        let n = mod(BigInt(scalar), CURVE.n);\n        if (n === 1n)\n            return this;\n        let p = ExtendedPoint.ZERO;\n        let d = this;\n        while (n > 0n) {\n            if (n & 1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= 1n;\n        }\n        return p;\n    }\n    precomputeWindow(W) {\n        const windows = 256 / W + 1;\n        let points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(ExtendedPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = ExtendedPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = ExtendedPoint.ZERO;\n        let f = ExtendedPoint.ZERO;\n        const windows = 256 / W + 1;\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += 1n;\n            }\n            if (wbits === 0) {\n                f = f.add(window % 2 ? precomputes[offset].negate() : precomputes[offset]);\n            }\n            else {\n                const cached = precomputes[offset + Math.abs(wbits) - 1];\n                p = p.add(wbits < 0 ? cached.negate() : cached);\n            }\n        }\n        return [p, f];\n    }\n    multiply(scalar, affinePoint) {\n        if (!isValidScalar(scalar))\n            throw new TypeError('Point#multiply: expected number or bigint');\n        const n = mod(BigInt(scalar), CURVE.n);\n        return ExtendedPoint.normalizeZ(this.wNAF(n, affinePoint))[0];\n    }\n    toAffine(invZ = invert(this.z)) {\n        const x = mod(this.x * invZ);\n        const y = mod(this.y * invZ);\n        return new Point(x, y);\n    }\n}\nexports.ExtendedPoint = ExtendedPoint;\nExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, 1n, mod(CURVE.Gx * CURVE.Gy));\nExtendedPoint.ZERO = new ExtendedPoint(0n, 1n, 1n, 0n);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromHex(hash) {\n        const { d, P } = CURVE;\n        const bytes = hash instanceof Uint8Array ? hash : hexToBytes(hash);\n        if (bytes.length !== 32)\n            throw new Error('Point.fromHex: expected 32 bytes');\n        const last = bytes[31];\n        const normedLast = last & ~0x80;\n        const isLastByteOdd = (last & 0x80) !== 0;\n        const normed = Uint8Array.from(Array.from(bytes.slice(0, 31)).concat(normedLast));\n        const y = bytesToNumberLE(normed);\n        if (y >= P)\n            throw new Error('Point.fromHex expects hex <= Fp');\n        const y2 = mod(y * y);\n        const u = mod(y2 - 1n);\n        const v = mod(d * y2 + 1n);\n        let { isValid, value: x } = uvRatio(u, v);\n        if (!isValid)\n            throw new Error('Point.fromHex: invalid y coordinate');\n        const isXOdd = (x & 1n) === 1n;\n        if (isLastByteOdd !== isXOdd) {\n            x = mod(-x);\n        }\n        return new Point(x, y);\n    }\n    static async fromPrivateKey(privateKey) {\n        const privBytes = await exports.utils.sha512(normalizePrivateKey(privateKey));\n        return Point.BASE.multiply(encodePrivate(privBytes));\n    }\n    toRawBytes() {\n        const hex = numberToHex(this.y);\n        const u8 = new Uint8Array(B32);\n        for (let i = hex.length - 2, j = 0; j < B32 && i >= 0; i -= 2, j++) {\n            u8[j] = Number.parseInt(hex[i] + hex[i + 1], 16);\n        }\n        const mask = this.x & 1n ? 0x80 : 0;\n        u8[B32 - 1] |= mask;\n        return u8;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toX25519() {\n        return mod((1n + this.y) * invert(1n - this.y));\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(mod(-this.x), this.y);\n    }\n    add(other) {\n        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n}\nexports.Point = Point;\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(0n, 1n);\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n    }\n    static fromHex(hex) {\n        hex = ensureBytes(hex);\n        const r = Point.fromHex(hex.slice(0, 32));\n        const s = bytesToNumberLE(hex.slice(32));\n        if (!isWithinCurveOrder(s))\n            throw new Error('Signature.fromHex expects s <= CURVE.n');\n        return new Signature(r, s);\n    }\n    toRawBytes() {\n        const numberBytes = hexToBytes(numberToHex(this.s)).reverse();\n        const sBytes = new Uint8Array(B32);\n        sBytes.set(numberBytes);\n        const res = new Uint8Array(B32 * 2);\n        res.set(this.r.toRawBytes());\n        res.set(sBytes, 32);\n        return res;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n}\nexports.Signature = Signature;\nexports.SignResult = Signature;\nfunction concatBytes(...arrays) {\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nfunction bytesToHex(uint8a) {\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += uint8a[i].toString(16).padStart(2, '0');\n    }\n    return hex;\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string' || hex.length % 2)\n        throw new Error('Expected valid hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        array[i] = Number.parseInt(hex.slice(j, j + 2), 16);\n    }\n    return array;\n}\nfunction numberToHex(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction numberToBytesPadded(num, length = B32) {\n    const hex = numberToHex(num).padStart(length * 2, '0');\n    return hexToBytes(hex).reverse();\n}\nfunction edIsNegative(num) {\n    return (mod(num) & 1n) === 1n;\n}\nfunction isValidScalar(num) {\n    if (typeof num === 'bigint' && num > 0n)\n        return true;\n    if (typeof num === 'number' && num > 0 && Number.isSafeInteger(num))\n        return true;\n    return false;\n}\nfunction bytesToNumberLE(uint8a) {\n    let value = 0n;\n    for (let i = 0; i < uint8a.length; i++) {\n        value += BigInt(uint8a[i]) << (8n * BigInt(i));\n    }\n    return value;\n}\nfunction bytes255ToNumberLE(bytes) {\n    return mod(bytesToNumberLE(bytes) & (2n ** 255n - 1n));\n}\nfunction mod(a, b = CURVE.P) {\n    const res = a % b;\n    return res >= 0n ? res : b + res;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === 0n || modulo <= 0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let [x, y, u, v] = [0n, 1n, 1n, 0n];\n    while (a !== 0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        [b, a] = [a, r];\n        [x, y] = [u, v];\n        [u, v] = [m, n];\n    }\n    const gcd = b;\n    if (gcd !== 1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, n = CURVE.P) {\n    const len = nums.length;\n    const scratch = new Array(len);\n    let acc = 1n;\n    for (let i = 0; i < len; i++) {\n        if (nums[i] === 0n)\n            continue;\n        scratch[i] = acc;\n        acc = mod(acc * nums[i], n);\n    }\n    acc = invert(acc, n);\n    for (let i = len - 1; i >= 0; i--) {\n        if (nums[i] === 0n)\n            continue;\n        let tmp = mod(acc * nums[i], n);\n        nums[i] = mod(acc * scratch[i], n);\n        acc = tmp;\n    }\n    return nums;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > 0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction pow_2_252_3(x) {\n    const { P } = CURVE;\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P;\n    const b4 = (pow2(b2, 2n) * b2) % P;\n    const b5 = (pow2(b4, 1n) * x) % P;\n    const b10 = (pow2(b5, 5n) * b5) % P;\n    const b20 = (pow2(b10, 10n) * b10) % P;\n    const b40 = (pow2(b20, 20n) * b20) % P;\n    const b80 = (pow2(b40, 40n) * b40) % P;\n    const b160 = (pow2(b80, 80n) * b80) % P;\n    const b240 = (pow2(b160, 80n) * b80) % P;\n    const b250 = (pow2(b240, 10n) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, 2n) * x) % P;\n    return pow_p_5_8;\n}\nfunction uvRatio(u, v) {\n    const v3 = mod(v * v * v);\n    const v7 = mod(v3 * v3 * v);\n    let x = mod(u * v3 * pow_2_252_3(u * v7));\n    const vx2 = mod(v * x * x);\n    const root1 = x;\n    const root2 = mod(x * SQRT_M1);\n    const useRoot1 = vx2 === u;\n    const useRoot2 = vx2 === mod(-u);\n    const noRoot = vx2 === mod(-u * SQRT_M1);\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2;\n    if (edIsNegative(x))\n        x = mod(-x);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\nfunction invertSqrt(number) {\n    return uvRatio(1n, number);\n}\nasync function sha512ToNumberLE(...args) {\n    const messageArray = concatBytes(...args);\n    const hash = await exports.utils.sha512(messageArray);\n    const value = bytesToNumberLE(hash);\n    return mod(value, CURVE.n);\n}\nfunction keyPrefix(privateBytes) {\n    return privateBytes.slice(B32);\n}\nfunction encodePrivate(privateBytes) {\n    const last = B32 - 1;\n    const head = privateBytes.slice(0, B32);\n    head[0] &= 248;\n    head[last] &= 127;\n    head[last] |= 64;\n    return mod(bytesToNumberLE(head), CURVE.n);\n}\nfunction equalBytes(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    for (let i = 0; i < b1.length; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction ensureBytes(hash) {\n    return hash instanceof Uint8Array ? hash : hexToBytes(hash);\n}\nfunction isWithinCurveOrder(num) {\n    return 0 < num && num < CURVE.n;\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint' || (typeof key === 'number' && Number.isSafeInteger(key) && key > 0)) {\n        num = BigInt(key);\n        key = num.toString(16).padStart(B32 * 2, '0');\n    }\n    if (typeof key === 'string') {\n        if (key.length !== 64)\n            throw new Error('Expected 32 bytes of private key');\n        return hexToBytes(key);\n    }\n    else if (key instanceof Uint8Array) {\n        if (key.length !== 32)\n            throw new Error('Expected 32 bytes of private key');\n        return key;\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n}\nasync function getPublicKey(privateKey) {\n    const key = await Point.fromPrivateKey(privateKey);\n    return typeof privateKey === 'string' ? key.toHex() : key.toRawBytes();\n}\nexports.getPublicKey = getPublicKey;\nasync function sign(hash, privateKey) {\n    const privBytes = await exports.utils.sha512(normalizePrivateKey(privateKey));\n    const p = encodePrivate(privBytes);\n    const P = Point.BASE.multiply(p);\n    const msg = ensureBytes(hash);\n    const r = await sha512ToNumberLE(keyPrefix(privBytes), msg);\n    const R = Point.BASE.multiply(r);\n    const h = await sha512ToNumberLE(R.toRawBytes(), P.toRawBytes(), msg);\n    const S = mod(r + h * p, CURVE.n);\n    const sig = new Signature(R, S);\n    return typeof hash === 'string' ? sig.toHex() : sig.toRawBytes();\n}\nexports.sign = sign;\nasync function verify(signature, hash, publicKey) {\n    hash = ensureBytes(hash);\n    if (!(publicKey instanceof Point))\n        publicKey = Point.fromHex(publicKey);\n    if (!(signature instanceof Signature))\n        signature = Signature.fromHex(signature);\n    const hs = await sha512ToNumberLE(signature.r.toRawBytes(), publicKey.toRawBytes(), hash);\n    const Ph = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(hs);\n    const Gs = ExtendedPoint.BASE.multiply(signature.s);\n    const RPh = ExtendedPoint.fromAffine(signature.r).add(Ph);\n    return RPh.subtract(Gs).multiplyUnsafe(8n).equals(ExtendedPoint.ZERO);\n}\nexports.verify = verify;\nPoint.BASE._setWindowSize(8);\nexports.utils = {\n    TORSION_SUBGROUP: [\n        '0100000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n        '0000000000000000000000000000000000000000000000000000000000000080',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n        'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n        '0000000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n    ],\n    randomPrivateKey: (bytesLength = 32) => {\n        if (typeof window == 'object' && 'crypto' in window) {\n            return window.crypto.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (typeof process === 'object' && 'node' in process.versions) {\n            const { randomBytes } = require('crypto');\n            return new Uint8Array(randomBytes(bytesLength).buffer);\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    sha512: async (message) => {\n        if (typeof window == 'object' && 'crypto' in window) {\n            const buffer = await window.crypto.subtle.digest('SHA-512', message.buffer);\n            return new Uint8Array(buffer);\n        }\n        else if (typeof process === 'object' && 'node' in process.versions) {\n            const { createHash } = require('crypto');\n            const hash = createHash('sha512');\n            hash.update(message);\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha512 function\");\n        }\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(1n);\n        return cached;\n    },\n};\n"]},"metadata":{},"sourceType":"script"}