{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst createHash = require(\"create-hash\");\n\nconst pbkdf2_1 = require(\"pbkdf2\");\n\nconst randomBytes = require(\"randombytes\");\n\nconst _wordlists_1 = require(\"./_wordlists\");\n\nlet DEFAULT_WORDLIST = _wordlists_1._default;\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\nconst WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\\n' + 'Please pass a 2048 word array explicitly.';\n\nfunction pbkdf2Promise(password, saltMixin, iterations, keylen, digest) {\n  return Promise.resolve().then(() => new Promise((resolve, reject) => {\n    const callback = (err, derivedKey) => {\n      if (err) {\n        return reject(err);\n      } else {\n        return resolve(derivedKey);\n      }\n    };\n\n    pbkdf2_1.pbkdf2(password, saltMixin, iterations, keylen, digest, callback);\n  }));\n}\n\nfunction normalize(str) {\n  return (str || '').normalize('NFKD');\n}\n\nfunction lpad(str, padString, length) {\n  while (str.length < length) {\n    str = padString + str;\n  }\n\n  return str;\n}\n\nfunction binaryToByte(bin) {\n  return parseInt(bin, 2);\n}\n\nfunction bytesToBinary(bytes) {\n  return bytes.map(x => lpad(x.toString(2), '0', 8)).join('');\n}\n\nfunction deriveChecksumBits(entropyBuffer) {\n  const ENT = entropyBuffer.length * 8;\n  const CS = ENT / 32;\n  const hash = createHash('sha256').update(entropyBuffer).digest();\n  return bytesToBinary(Array.from(hash)).slice(0, CS);\n}\n\nfunction salt(password) {\n  return 'mnemonic' + (password || '');\n}\n\nfunction mnemonicToSeedSync(mnemonic, password) {\n  const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');\n  const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');\n  return pbkdf2_1.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n}\n\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\n\nfunction mnemonicToSeed(mnemonic, password) {\n  return Promise.resolve().then(() => {\n    const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');\n    const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');\n    return pbkdf2Promise(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n  });\n}\n\nexports.mnemonicToSeed = mnemonicToSeed;\n\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n  wordlist = wordlist || DEFAULT_WORDLIST;\n\n  if (!wordlist) {\n    throw new Error(WORDLIST_REQUIRED);\n  }\n\n  const words = normalize(mnemonic).split(' ');\n\n  if (words.length % 3 !== 0) {\n    throw new Error(INVALID_MNEMONIC);\n  } // convert word indices to 11 bit binary strings\n\n\n  const bits = words.map(word => {\n    const index = wordlist.indexOf(word);\n\n    if (index === -1) {\n      throw new Error(INVALID_MNEMONIC);\n    }\n\n    return lpad(index.toString(2), '0', 11);\n  }).join(''); // split the binary string into ENT/CS\n\n  const dividerIndex = Math.floor(bits.length / 33) * 32;\n  const entropyBits = bits.slice(0, dividerIndex);\n  const checksumBits = bits.slice(dividerIndex); // calculate the checksum and compare\n\n  const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);\n\n  if (entropyBytes.length < 16) {\n    throw new Error(INVALID_ENTROPY);\n  }\n\n  if (entropyBytes.length > 32) {\n    throw new Error(INVALID_ENTROPY);\n  }\n\n  if (entropyBytes.length % 4 !== 0) {\n    throw new Error(INVALID_ENTROPY);\n  }\n\n  const entropy = Buffer.from(entropyBytes);\n  const newChecksum = deriveChecksumBits(entropy);\n\n  if (newChecksum !== checksumBits) {\n    throw new Error(INVALID_CHECKSUM);\n  }\n\n  return entropy.toString('hex');\n}\n\nexports.mnemonicToEntropy = mnemonicToEntropy;\n\nfunction entropyToMnemonic(entropy, wordlist) {\n  if (!Buffer.isBuffer(entropy)) {\n    entropy = Buffer.from(entropy, 'hex');\n  }\n\n  wordlist = wordlist || DEFAULT_WORDLIST;\n\n  if (!wordlist) {\n    throw new Error(WORDLIST_REQUIRED);\n  } // 128 <= ENT <= 256\n\n\n  if (entropy.length < 16) {\n    throw new TypeError(INVALID_ENTROPY);\n  }\n\n  if (entropy.length > 32) {\n    throw new TypeError(INVALID_ENTROPY);\n  }\n\n  if (entropy.length % 4 !== 0) {\n    throw new TypeError(INVALID_ENTROPY);\n  }\n\n  const entropyBits = bytesToBinary(Array.from(entropy));\n  const checksumBits = deriveChecksumBits(entropy);\n  const bits = entropyBits + checksumBits;\n  const chunks = bits.match(/(.{1,11})/g);\n  const words = chunks.map(binary => {\n    const index = binaryToByte(binary);\n    return wordlist[index];\n  });\n  return wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093' // Japanese wordlist\n  ? words.join('\\u3000') : words.join(' ');\n}\n\nexports.entropyToMnemonic = entropyToMnemonic;\n\nfunction generateMnemonic(strength, rng, wordlist) {\n  strength = strength || 128;\n\n  if (strength % 32 !== 0) {\n    throw new TypeError(INVALID_ENTROPY);\n  }\n\n  rng = rng || randomBytes;\n  return entropyToMnemonic(rng(strength / 8), wordlist);\n}\n\nexports.generateMnemonic = generateMnemonic;\n\nfunction validateMnemonic(mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.validateMnemonic = validateMnemonic;\n\nfunction setDefaultWordlist(language) {\n  const result = _wordlists_1.wordlists[language];\n\n  if (result) {\n    DEFAULT_WORDLIST = result;\n  } else {\n    throw new Error('Could not find wordlist for language \"' + language + '\"');\n  }\n}\n\nexports.setDefaultWordlist = setDefaultWordlist;\n\nfunction getDefaultWordlist() {\n  if (!DEFAULT_WORDLIST) {\n    throw new Error('No Default Wordlist set');\n  }\n\n  return Object.keys(_wordlists_1.wordlists).filter(lang => {\n    if (lang === 'JA' || lang === 'EN') {\n      return false;\n    }\n\n    return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);\n  })[0];\n}\n\nexports.getDefaultWordlist = getDefaultWordlist;\n\nvar _wordlists_2 = require(\"./_wordlists\");\n\nexports.wordlists = _wordlists_2.wordlists;","map":{"version":3,"sources":["E:/anipfspace/node_modules/bip39/src/index.js"],"names":["Object","defineProperty","exports","value","createHash","require","pbkdf2_1","randomBytes","_wordlists_1","DEFAULT_WORDLIST","_default","INVALID_MNEMONIC","INVALID_ENTROPY","INVALID_CHECKSUM","WORDLIST_REQUIRED","pbkdf2Promise","password","saltMixin","iterations","keylen","digest","Promise","resolve","then","reject","callback","err","derivedKey","pbkdf2","normalize","str","lpad","padString","length","binaryToByte","bin","parseInt","bytesToBinary","bytes","map","x","toString","join","deriveChecksumBits","entropyBuffer","ENT","CS","hash","update","Array","from","slice","salt","mnemonicToSeedSync","mnemonic","mnemonicBuffer","Buffer","saltBuffer","pbkdf2Sync","mnemonicToSeed","mnemonicToEntropy","wordlist","Error","words","split","bits","word","index","indexOf","dividerIndex","Math","floor","entropyBits","checksumBits","entropyBytes","match","entropy","newChecksum","entropyToMnemonic","isBuffer","TypeError","chunks","binary","generateMnemonic","strength","rng","validateMnemonic","e","setDefaultWordlist","language","result","wordlists","getDefaultWordlist","keys","filter","lang","every","_wordlists_2"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst createHash = require(\"create-hash\");\r\nconst pbkdf2_1 = require(\"pbkdf2\");\r\nconst randomBytes = require(\"randombytes\");\r\nconst _wordlists_1 = require(\"./_wordlists\");\r\nlet DEFAULT_WORDLIST = _wordlists_1._default;\r\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\r\nconst INVALID_ENTROPY = 'Invalid entropy';\r\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\r\nconst WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\\n' +\r\n    'Please pass a 2048 word array explicitly.';\r\nfunction pbkdf2Promise(password, saltMixin, iterations, keylen, digest) {\r\n    return Promise.resolve().then(() => new Promise((resolve, reject) => {\r\n        const callback = (err, derivedKey) => {\r\n            if (err) {\r\n                return reject(err);\r\n            }\r\n            else {\r\n                return resolve(derivedKey);\r\n            }\r\n        };\r\n        pbkdf2_1.pbkdf2(password, saltMixin, iterations, keylen, digest, callback);\r\n    }));\r\n}\r\nfunction normalize(str) {\r\n    return (str || '').normalize('NFKD');\r\n}\r\nfunction lpad(str, padString, length) {\r\n    while (str.length < length) {\r\n        str = padString + str;\r\n    }\r\n    return str;\r\n}\r\nfunction binaryToByte(bin) {\r\n    return parseInt(bin, 2);\r\n}\r\nfunction bytesToBinary(bytes) {\r\n    return bytes.map((x) => lpad(x.toString(2), '0', 8)).join('');\r\n}\r\nfunction deriveChecksumBits(entropyBuffer) {\r\n    const ENT = entropyBuffer.length * 8;\r\n    const CS = ENT / 32;\r\n    const hash = createHash('sha256')\r\n        .update(entropyBuffer)\r\n        .digest();\r\n    return bytesToBinary(Array.from(hash)).slice(0, CS);\r\n}\r\nfunction salt(password) {\r\n    return 'mnemonic' + (password || '');\r\n}\r\nfunction mnemonicToSeedSync(mnemonic, password) {\r\n    const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');\r\n    const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');\r\n    return pbkdf2_1.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\r\n}\r\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\r\nfunction mnemonicToSeed(mnemonic, password) {\r\n    return Promise.resolve().then(() => {\r\n        const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');\r\n        const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');\r\n        return pbkdf2Promise(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\r\n    });\r\n}\r\nexports.mnemonicToSeed = mnemonicToSeed;\r\nfunction mnemonicToEntropy(mnemonic, wordlist) {\r\n    wordlist = wordlist || DEFAULT_WORDLIST;\r\n    if (!wordlist) {\r\n        throw new Error(WORDLIST_REQUIRED);\r\n    }\r\n    const words = normalize(mnemonic).split(' ');\r\n    if (words.length % 3 !== 0) {\r\n        throw new Error(INVALID_MNEMONIC);\r\n    }\r\n    // convert word indices to 11 bit binary strings\r\n    const bits = words\r\n        .map((word) => {\r\n        const index = wordlist.indexOf(word);\r\n        if (index === -1) {\r\n            throw new Error(INVALID_MNEMONIC);\r\n        }\r\n        return lpad(index.toString(2), '0', 11);\r\n    })\r\n        .join('');\r\n    // split the binary string into ENT/CS\r\n    const dividerIndex = Math.floor(bits.length / 33) * 32;\r\n    const entropyBits = bits.slice(0, dividerIndex);\r\n    const checksumBits = bits.slice(dividerIndex);\r\n    // calculate the checksum and compare\r\n    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);\r\n    if (entropyBytes.length < 16) {\r\n        throw new Error(INVALID_ENTROPY);\r\n    }\r\n    if (entropyBytes.length > 32) {\r\n        throw new Error(INVALID_ENTROPY);\r\n    }\r\n    if (entropyBytes.length % 4 !== 0) {\r\n        throw new Error(INVALID_ENTROPY);\r\n    }\r\n    const entropy = Buffer.from(entropyBytes);\r\n    const newChecksum = deriveChecksumBits(entropy);\r\n    if (newChecksum !== checksumBits) {\r\n        throw new Error(INVALID_CHECKSUM);\r\n    }\r\n    return entropy.toString('hex');\r\n}\r\nexports.mnemonicToEntropy = mnemonicToEntropy;\r\nfunction entropyToMnemonic(entropy, wordlist) {\r\n    if (!Buffer.isBuffer(entropy)) {\r\n        entropy = Buffer.from(entropy, 'hex');\r\n    }\r\n    wordlist = wordlist || DEFAULT_WORDLIST;\r\n    if (!wordlist) {\r\n        throw new Error(WORDLIST_REQUIRED);\r\n    }\r\n    // 128 <= ENT <= 256\r\n    if (entropy.length < 16) {\r\n        throw new TypeError(INVALID_ENTROPY);\r\n    }\r\n    if (entropy.length > 32) {\r\n        throw new TypeError(INVALID_ENTROPY);\r\n    }\r\n    if (entropy.length % 4 !== 0) {\r\n        throw new TypeError(INVALID_ENTROPY);\r\n    }\r\n    const entropyBits = bytesToBinary(Array.from(entropy));\r\n    const checksumBits = deriveChecksumBits(entropy);\r\n    const bits = entropyBits + checksumBits;\r\n    const chunks = bits.match(/(.{1,11})/g);\r\n    const words = chunks.map((binary) => {\r\n        const index = binaryToByte(binary);\r\n        return wordlist[index];\r\n    });\r\n    return wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093' // Japanese wordlist\r\n        ? words.join('\\u3000')\r\n        : words.join(' ');\r\n}\r\nexports.entropyToMnemonic = entropyToMnemonic;\r\nfunction generateMnemonic(strength, rng, wordlist) {\r\n    strength = strength || 128;\r\n    if (strength % 32 !== 0) {\r\n        throw new TypeError(INVALID_ENTROPY);\r\n    }\r\n    rng = rng || randomBytes;\r\n    return entropyToMnemonic(rng(strength / 8), wordlist);\r\n}\r\nexports.generateMnemonic = generateMnemonic;\r\nfunction validateMnemonic(mnemonic, wordlist) {\r\n    try {\r\n        mnemonicToEntropy(mnemonic, wordlist);\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nexports.validateMnemonic = validateMnemonic;\r\nfunction setDefaultWordlist(language) {\r\n    const result = _wordlists_1.wordlists[language];\r\n    if (result) {\r\n        DEFAULT_WORDLIST = result;\r\n    }\r\n    else {\r\n        throw new Error('Could not find wordlist for language \"' + language + '\"');\r\n    }\r\n}\r\nexports.setDefaultWordlist = setDefaultWordlist;\r\nfunction getDefaultWordlist() {\r\n    if (!DEFAULT_WORDLIST) {\r\n        throw new Error('No Default Wordlist set');\r\n    }\r\n    return Object.keys(_wordlists_1.wordlists).filter((lang) => {\r\n        if (lang === 'JA' || lang === 'EN') {\r\n            return false;\r\n        }\r\n        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);\r\n    })[0];\r\n}\r\nexports.getDefaultWordlist = getDefaultWordlist;\r\nvar _wordlists_2 = require(\"./_wordlists\");\r\nexports.wordlists = _wordlists_2.wordlists;\r\n"]},"metadata":{},"sourceType":"script"}