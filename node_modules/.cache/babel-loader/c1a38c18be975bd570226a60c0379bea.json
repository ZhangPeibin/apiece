{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst parser_1 = require('../parser');\n\nfunction combine(psbts) {\n  const self = psbts[0];\n  const selfKeyVals = parser_1.psbtToKeyVals(self);\n  const others = psbts.slice(1);\n  if (others.length === 0) throw new Error('Combine: Nothing to combine');\n  const selfTx = getTx(self);\n\n  if (selfTx === undefined) {\n    throw new Error('Combine: Self missing transaction');\n  }\n\n  const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);\n  const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);\n  const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);\n\n  for (const other of others) {\n    const otherTx = getTx(other);\n\n    if (otherTx === undefined || !otherTx.toBuffer().equals(selfTx.toBuffer())) {\n      throw new Error('Combine: One of the Psbts does not have the same transaction.');\n    }\n\n    const otherKeyVals = parser_1.psbtToKeyVals(other);\n    const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);\n    otherGlobalSet.forEach(keyPusher(selfGlobalSet, selfKeyVals.globalKeyVals, otherKeyVals.globalKeyVals));\n    const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);\n    otherInputSets.forEach((inputSet, idx) => inputSet.forEach(keyPusher(selfInputSets[idx], selfKeyVals.inputKeyVals[idx], otherKeyVals.inputKeyVals[idx])));\n    const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);\n    otherOutputSets.forEach((outputSet, idx) => outputSet.forEach(keyPusher(selfOutputSets[idx], selfKeyVals.outputKeyVals[idx], otherKeyVals.outputKeyVals[idx])));\n  }\n\n  return parser_1.psbtFromKeyVals(selfTx, {\n    globalMapKeyVals: selfKeyVals.globalKeyVals,\n    inputKeyVals: selfKeyVals.inputKeyVals,\n    outputKeyVals: selfKeyVals.outputKeyVals\n  });\n}\n\nexports.combine = combine;\n\nfunction keyPusher(selfSet, selfKeyVals, otherKeyVals) {\n  return key => {\n    if (selfSet.has(key)) return;\n    const newKv = otherKeyVals.filter(kv => kv.key.toString('hex') === key)[0];\n    selfKeyVals.push(newKv);\n    selfSet.add(key);\n  };\n}\n\nfunction getTx(psbt) {\n  return psbt.globalMap.unsignedTx;\n}\n\nfunction getKeySet(keyVals) {\n  const set = new Set();\n  keyVals.forEach(keyVal => {\n    const hex = keyVal.key.toString('hex');\n    if (set.has(hex)) throw new Error('Combine: KeyValue Map keys should be unique');\n    set.add(hex);\n  });\n  return set;\n}","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/bip174/src/lib/combiner/index.js"],"names":["Object","defineProperty","exports","value","parser_1","require","combine","psbts","self","selfKeyVals","psbtToKeyVals","others","slice","length","Error","selfTx","getTx","undefined","selfGlobalSet","getKeySet","globalKeyVals","selfInputSets","inputKeyVals","map","selfOutputSets","outputKeyVals","other","otherTx","toBuffer","equals","otherKeyVals","otherGlobalSet","forEach","keyPusher","otherInputSets","inputSet","idx","otherOutputSets","outputSet","psbtFromKeyVals","globalMapKeyVals","selfSet","key","has","newKv","filter","kv","toString","push","add","psbt","globalMap","unsignedTx","keyVals","set","Set","keyVal","hex"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst parser_1 = require('../parser');\nfunction combine(psbts) {\n  const self = psbts[0];\n  const selfKeyVals = parser_1.psbtToKeyVals(self);\n  const others = psbts.slice(1);\n  if (others.length === 0) throw new Error('Combine: Nothing to combine');\n  const selfTx = getTx(self);\n  if (selfTx === undefined) {\n    throw new Error('Combine: Self missing transaction');\n  }\n  const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);\n  const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);\n  const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);\n  for (const other of others) {\n    const otherTx = getTx(other);\n    if (\n      otherTx === undefined ||\n      !otherTx.toBuffer().equals(selfTx.toBuffer())\n    ) {\n      throw new Error(\n        'Combine: One of the Psbts does not have the same transaction.',\n      );\n    }\n    const otherKeyVals = parser_1.psbtToKeyVals(other);\n    const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);\n    otherGlobalSet.forEach(\n      keyPusher(\n        selfGlobalSet,\n        selfKeyVals.globalKeyVals,\n        otherKeyVals.globalKeyVals,\n      ),\n    );\n    const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);\n    otherInputSets.forEach((inputSet, idx) =>\n      inputSet.forEach(\n        keyPusher(\n          selfInputSets[idx],\n          selfKeyVals.inputKeyVals[idx],\n          otherKeyVals.inputKeyVals[idx],\n        ),\n      ),\n    );\n    const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);\n    otherOutputSets.forEach((outputSet, idx) =>\n      outputSet.forEach(\n        keyPusher(\n          selfOutputSets[idx],\n          selfKeyVals.outputKeyVals[idx],\n          otherKeyVals.outputKeyVals[idx],\n        ),\n      ),\n    );\n  }\n  return parser_1.psbtFromKeyVals(selfTx, {\n    globalMapKeyVals: selfKeyVals.globalKeyVals,\n    inputKeyVals: selfKeyVals.inputKeyVals,\n    outputKeyVals: selfKeyVals.outputKeyVals,\n  });\n}\nexports.combine = combine;\nfunction keyPusher(selfSet, selfKeyVals, otherKeyVals) {\n  return key => {\n    if (selfSet.has(key)) return;\n    const newKv = otherKeyVals.filter(kv => kv.key.toString('hex') === key)[0];\n    selfKeyVals.push(newKv);\n    selfSet.add(key);\n  };\n}\nfunction getTx(psbt) {\n  return psbt.globalMap.unsignedTx;\n}\nfunction getKeySet(keyVals) {\n  const set = new Set();\n  keyVals.forEach(keyVal => {\n    const hex = keyVal.key.toString('hex');\n    if (set.has(hex))\n      throw new Error('Combine: KeyValue Map keys should be unique');\n    set.add(hex);\n  });\n  return set;\n}\n"]},"metadata":{},"sourceType":"script"}