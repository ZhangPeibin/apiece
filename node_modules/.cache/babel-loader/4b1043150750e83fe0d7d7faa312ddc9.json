{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst mm = require(\"micromatch\");\n\nconst HarmonyExportImportedSpecifierDependency = require(\"../dependencies/HarmonyExportImportedSpecifierDependency\");\n\nconst HarmonyImportSideEffectDependency = require(\"../dependencies/HarmonyImportSideEffectDependency\");\n\nconst HarmonyImportSpecifierDependency = require(\"../dependencies/HarmonyImportSpecifierDependency\");\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/**\n * @typedef {Object} ExportInModule\n * @property {Module} module the module\n * @property {string} exportName the name of the export\n * @property {boolean} checked if the export is conditional\n */\n\n/**\n * @typedef {Object} ReexportInfo\n * @property {Map<string, ExportInModule[]>} static\n * @property {Map<Module, Set<string>>} dynamic\n */\n\n/**\n * @param {ReexportInfo} info info object\n * @param {string} exportName name of export\n * @returns {ExportInModule | undefined} static export\n */\n\n\nconst getMappingFromInfo = (info, exportName) => {\n  const staticMappings = info.static.get(exportName);\n\n  if (staticMappings !== undefined) {\n    if (staticMappings.length === 1) return staticMappings[0];\n    return undefined;\n  }\n\n  const dynamicMappings = Array.from(info.dynamic).filter(([_, ignored]) => !ignored.has(exportName));\n\n  if (dynamicMappings.length === 1) {\n    return {\n      module: dynamicMappings[0][0],\n      exportName,\n      checked: true\n    };\n  }\n\n  return undefined;\n};\n/**\n * @param {ReexportInfo} info info object\n * @param {string} exportName name of export of source module\n * @param {Module} module the target module\n * @param {string} innerExportName name of export of target module\n * @param {boolean} checked true, if existence of target module is checked\n */\n\n\nconst addStaticReexport = (info, exportName, module, innerExportName, checked) => {\n  let mappings = info.static.get(exportName);\n\n  if (mappings !== undefined) {\n    for (const mapping of mappings) {\n      if (mapping.module === module && mapping.exportName === innerExportName) {\n        mapping.checked = mapping.checked && checked;\n        return;\n      }\n    }\n  } else {\n    mappings = [];\n    info.static.set(exportName, mappings);\n  }\n\n  mappings.push({\n    module,\n    exportName: innerExportName,\n    checked\n  });\n};\n/**\n * @param {ReexportInfo} info info object\n * @param {Module} module the reexport module\n * @param {Set<string>} ignored ignore list\n * @returns {void}\n */\n\n\nconst addDynamicReexport = (info, module, ignored) => {\n  const existingList = info.dynamic.get(module);\n\n  if (existingList !== undefined) {\n    for (const key of existingList) {\n      if (!ignored.has(key)) existingList.delete(key);\n    }\n  } else {\n    info.dynamic.set(module, new Set(ignored));\n  }\n};\n\nclass SideEffectsFlagPlugin {\n  apply(compiler) {\n    compiler.hooks.normalModuleFactory.tap(\"SideEffectsFlagPlugin\", nmf => {\n      nmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n        const resolveData = data.resourceResolveData;\n\n        if (resolveData && resolveData.descriptionFileData && resolveData.relativePath) {\n          const sideEffects = resolveData.descriptionFileData.sideEffects;\n          const hasSideEffects = SideEffectsFlagPlugin.moduleHasSideEffects(resolveData.relativePath, sideEffects);\n\n          if (!hasSideEffects) {\n            module.factoryMeta.sideEffectFree = true;\n          }\n        }\n\n        return module;\n      });\n      nmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n        if (data.settings.sideEffects === false) {\n          module.factoryMeta.sideEffectFree = true;\n        } else if (data.settings.sideEffects === true) {\n          module.factoryMeta.sideEffectFree = false;\n        }\n      });\n    });\n    compiler.hooks.compilation.tap(\"SideEffectsFlagPlugin\", compilation => {\n      compilation.hooks.optimizeDependencies.tap(\"SideEffectsFlagPlugin\", modules => {\n        /** @type {Map<Module, ReexportInfo>} */\n        const reexportMaps = new Map(); // Capture reexports of sideEffectFree modules\n\n        for (const module of modules) {\n          /** @type {Dependency[]} */\n          const removeDependencies = [];\n\n          for (const dep of module.dependencies) {\n            if (dep instanceof HarmonyImportSideEffectDependency) {\n              if (dep.module && dep.module.factoryMeta.sideEffectFree) {\n                removeDependencies.push(dep);\n              }\n            } else if (dep instanceof HarmonyExportImportedSpecifierDependency) {\n              if (module.factoryMeta.sideEffectFree) {\n                const mode = dep.getMode(true);\n\n                if (mode.type === \"safe-reexport\" || mode.type === \"checked-reexport\" || mode.type === \"dynamic-reexport\" || mode.type === \"reexport-non-harmony-default\" || mode.type === \"reexport-non-harmony-default-strict\" || mode.type === \"reexport-named-default\") {\n                  let info = reexportMaps.get(module);\n\n                  if (!info) {\n                    reexportMaps.set(module, info = {\n                      static: new Map(),\n                      dynamic: new Map()\n                    });\n                  }\n\n                  const targetModule = dep._module;\n\n                  switch (mode.type) {\n                    case \"safe-reexport\":\n                      for (const [key, id] of mode.map) {\n                        if (id) {\n                          addStaticReexport(info, key, targetModule, id, false);\n                        }\n                      }\n\n                      break;\n\n                    case \"checked-reexport\":\n                      for (const [key, id] of mode.map) {\n                        if (id) {\n                          addStaticReexport(info, key, targetModule, id, true);\n                        }\n                      }\n\n                      break;\n\n                    case \"dynamic-reexport\":\n                      addDynamicReexport(info, targetModule, mode.ignored);\n                      break;\n\n                    case \"reexport-non-harmony-default\":\n                    case \"reexport-non-harmony-default-strict\":\n                    case \"reexport-named-default\":\n                      addStaticReexport(info, mode.name, targetModule, \"default\", false);\n                      break;\n                  }\n                }\n              }\n            }\n          }\n        } // Flatten reexports\n\n\n        for (const info of reexportMaps.values()) {\n          const dynamicReexports = info.dynamic;\n          info.dynamic = new Map();\n\n          for (const reexport of dynamicReexports) {\n            let [targetModule, ignored] = reexport;\n\n            for (;;) {\n              const innerInfo = reexportMaps.get(targetModule);\n              if (!innerInfo) break;\n\n              for (const [key, reexports] of innerInfo.static) {\n                if (ignored.has(key)) continue;\n\n                for (const {\n                  module,\n                  exportName,\n                  checked\n                } of reexports) {\n                  addStaticReexport(info, key, module, exportName, checked);\n                }\n              } // Follow dynamic reexport if there is only one\n\n\n              if (innerInfo.dynamic.size !== 1) {\n                // When there are more then one, we don't know which one\n                break;\n              }\n\n              ignored = new Set(ignored);\n\n              for (const [innerModule, innerIgnored] of innerInfo.dynamic) {\n                for (const key of innerIgnored) {\n                  if (ignored.has(key)) continue; // This reexports ends here\n\n                  addStaticReexport(info, key, targetModule, key, true);\n                  ignored.add(key);\n                }\n\n                targetModule = innerModule;\n              }\n            } // Update reexport as all other cases has been handled\n\n\n            addDynamicReexport(info, targetModule, ignored);\n          }\n        }\n\n        for (const info of reexportMaps.values()) {\n          const staticReexports = info.static;\n          info.static = new Map();\n\n          for (const [key, reexports] of staticReexports) {\n            for (let mapping of reexports) {\n              for (;;) {\n                const innerInfo = reexportMaps.get(mapping.module);\n                if (!innerInfo) break;\n                const newMapping = getMappingFromInfo(innerInfo, mapping.exportName);\n                if (!newMapping) break;\n                mapping = newMapping;\n              }\n\n              addStaticReexport(info, key, mapping.module, mapping.exportName, mapping.checked);\n            }\n          }\n        } // Update imports along the reexports from sideEffectFree modules\n\n\n        for (const pair of reexportMaps) {\n          const module = pair[0];\n          const info = pair[1];\n          let newReasons = undefined;\n\n          for (let i = 0; i < module.reasons.length; i++) {\n            const reason = module.reasons[i];\n            const dep = reason.dependency;\n\n            if ((dep instanceof HarmonyExportImportedSpecifierDependency || dep instanceof HarmonyImportSpecifierDependency && !dep.namespaceObjectAsContext) && dep._id) {\n              const mapping = getMappingFromInfo(info, dep._id);\n\n              if (mapping) {\n                dep.redirectedModule = mapping.module;\n                dep.redirectedId = mapping.exportName;\n                mapping.module.addReason(reason.module, dep, reason.explanation ? reason.explanation + \" (skipped side-effect-free modules)\" : \"(skipped side-effect-free modules)\"); // removing the currect reason, by not adding it to the newReasons array\n                // lazily create the newReasons array\n\n                if (newReasons === undefined) {\n                  newReasons = i === 0 ? [] : module.reasons.slice(0, i);\n                }\n\n                continue;\n              }\n            }\n\n            if (newReasons !== undefined) newReasons.push(reason);\n          }\n\n          if (newReasons !== undefined) {\n            module.reasons = newReasons;\n          }\n        }\n      });\n    });\n  }\n\n  static moduleHasSideEffects(moduleName, flagValue) {\n    switch (typeof flagValue) {\n      case \"undefined\":\n        return true;\n\n      case \"boolean\":\n        return flagValue;\n\n      case \"string\":\n        if (process.platform === \"win32\") {\n          flagValue = flagValue.replace(/\\\\/g, \"/\");\n        }\n\n        return mm.isMatch(moduleName, flagValue, {\n          matchBase: true\n        });\n\n      case \"object\":\n        return flagValue.some(glob => SideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob));\n    }\n  }\n\n}\n\nmodule.exports = SideEffectsFlagPlugin;","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/webpack/lib/optimize/SideEffectsFlagPlugin.js"],"names":["mm","require","HarmonyExportImportedSpecifierDependency","HarmonyImportSideEffectDependency","HarmonyImportSpecifierDependency","getMappingFromInfo","info","exportName","staticMappings","static","get","undefined","length","dynamicMappings","Array","from","dynamic","filter","_","ignored","has","module","checked","addStaticReexport","innerExportName","mappings","mapping","set","push","addDynamicReexport","existingList","key","delete","Set","SideEffectsFlagPlugin","apply","compiler","hooks","normalModuleFactory","tap","nmf","data","resolveData","resourceResolveData","descriptionFileData","relativePath","sideEffects","hasSideEffects","moduleHasSideEffects","factoryMeta","sideEffectFree","settings","compilation","optimizeDependencies","modules","reexportMaps","Map","removeDependencies","dep","dependencies","mode","getMode","type","targetModule","_module","id","map","name","values","dynamicReexports","reexport","innerInfo","reexports","size","innerModule","innerIgnored","add","staticReexports","newMapping","pair","newReasons","i","reasons","reason","dependency","namespaceObjectAsContext","_id","redirectedModule","redirectedId","addReason","explanation","slice","moduleName","flagValue","process","platform","replace","isMatch","matchBase","some","glob","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst mm = require(\"micromatch\");\nconst HarmonyExportImportedSpecifierDependency = require(\"../dependencies/HarmonyExportImportedSpecifierDependency\");\nconst HarmonyImportSideEffectDependency = require(\"../dependencies/HarmonyImportSideEffectDependency\");\nconst HarmonyImportSpecifierDependency = require(\"../dependencies/HarmonyImportSpecifierDependency\");\n\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/**\n * @typedef {Object} ExportInModule\n * @property {Module} module the module\n * @property {string} exportName the name of the export\n * @property {boolean} checked if the export is conditional\n */\n\n/**\n * @typedef {Object} ReexportInfo\n * @property {Map<string, ExportInModule[]>} static\n * @property {Map<Module, Set<string>>} dynamic\n */\n\n/**\n * @param {ReexportInfo} info info object\n * @param {string} exportName name of export\n * @returns {ExportInModule | undefined} static export\n */\nconst getMappingFromInfo = (info, exportName) => {\n\tconst staticMappings = info.static.get(exportName);\n\tif (staticMappings !== undefined) {\n\t\tif (staticMappings.length === 1) return staticMappings[0];\n\t\treturn undefined;\n\t}\n\tconst dynamicMappings = Array.from(info.dynamic).filter(\n\t\t([_, ignored]) => !ignored.has(exportName)\n\t);\n\tif (dynamicMappings.length === 1) {\n\t\treturn {\n\t\t\tmodule: dynamicMappings[0][0],\n\t\t\texportName,\n\t\t\tchecked: true\n\t\t};\n\t}\n\treturn undefined;\n};\n\n/**\n * @param {ReexportInfo} info info object\n * @param {string} exportName name of export of source module\n * @param {Module} module the target module\n * @param {string} innerExportName name of export of target module\n * @param {boolean} checked true, if existence of target module is checked\n */\nconst addStaticReexport = (\n\tinfo,\n\texportName,\n\tmodule,\n\tinnerExportName,\n\tchecked\n) => {\n\tlet mappings = info.static.get(exportName);\n\tif (mappings !== undefined) {\n\t\tfor (const mapping of mappings) {\n\t\t\tif (mapping.module === module && mapping.exportName === innerExportName) {\n\t\t\t\tmapping.checked = mapping.checked && checked;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmappings = [];\n\t\tinfo.static.set(exportName, mappings);\n\t}\n\tmappings.push({\n\t\tmodule,\n\t\texportName: innerExportName,\n\t\tchecked\n\t});\n};\n\n/**\n * @param {ReexportInfo} info info object\n * @param {Module} module the reexport module\n * @param {Set<string>} ignored ignore list\n * @returns {void}\n */\nconst addDynamicReexport = (info, module, ignored) => {\n\tconst existingList = info.dynamic.get(module);\n\tif (existingList !== undefined) {\n\t\tfor (const key of existingList) {\n\t\t\tif (!ignored.has(key)) existingList.delete(key);\n\t\t}\n\t} else {\n\t\tinfo.dynamic.set(module, new Set(ignored));\n\t}\n};\n\nclass SideEffectsFlagPlugin {\n\tapply(compiler) {\n\t\tcompiler.hooks.normalModuleFactory.tap(\"SideEffectsFlagPlugin\", nmf => {\n\t\t\tnmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n\t\t\t\tconst resolveData = data.resourceResolveData;\n\t\t\t\tif (\n\t\t\t\t\tresolveData &&\n\t\t\t\t\tresolveData.descriptionFileData &&\n\t\t\t\t\tresolveData.relativePath\n\t\t\t\t) {\n\t\t\t\t\tconst sideEffects = resolveData.descriptionFileData.sideEffects;\n\t\t\t\t\tconst hasSideEffects = SideEffectsFlagPlugin.moduleHasSideEffects(\n\t\t\t\t\t\tresolveData.relativePath,\n\t\t\t\t\t\tsideEffects\n\t\t\t\t\t);\n\t\t\t\t\tif (!hasSideEffects) {\n\t\t\t\t\t\tmodule.factoryMeta.sideEffectFree = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn module;\n\t\t\t});\n\t\t\tnmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n\t\t\t\tif (data.settings.sideEffects === false) {\n\t\t\t\t\tmodule.factoryMeta.sideEffectFree = true;\n\t\t\t\t} else if (data.settings.sideEffects === true) {\n\t\t\t\t\tmodule.factoryMeta.sideEffectFree = false;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tcompiler.hooks.compilation.tap(\"SideEffectsFlagPlugin\", compilation => {\n\t\t\tcompilation.hooks.optimizeDependencies.tap(\n\t\t\t\t\"SideEffectsFlagPlugin\",\n\t\t\t\tmodules => {\n\t\t\t\t\t/** @type {Map<Module, ReexportInfo>} */\n\t\t\t\t\tconst reexportMaps = new Map();\n\n\t\t\t\t\t// Capture reexports of sideEffectFree modules\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t/** @type {Dependency[]} */\n\t\t\t\t\t\tconst removeDependencies = [];\n\t\t\t\t\t\tfor (const dep of module.dependencies) {\n\t\t\t\t\t\t\tif (dep instanceof HarmonyImportSideEffectDependency) {\n\t\t\t\t\t\t\t\tif (dep.module && dep.module.factoryMeta.sideEffectFree) {\n\t\t\t\t\t\t\t\t\tremoveDependencies.push(dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\tdep instanceof HarmonyExportImportedSpecifierDependency\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tif (module.factoryMeta.sideEffectFree) {\n\t\t\t\t\t\t\t\t\tconst mode = dep.getMode(true);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tmode.type === \"safe-reexport\" ||\n\t\t\t\t\t\t\t\t\t\tmode.type === \"checked-reexport\" ||\n\t\t\t\t\t\t\t\t\t\tmode.type === \"dynamic-reexport\" ||\n\t\t\t\t\t\t\t\t\t\tmode.type === \"reexport-non-harmony-default\" ||\n\t\t\t\t\t\t\t\t\t\tmode.type === \"reexport-non-harmony-default-strict\" ||\n\t\t\t\t\t\t\t\t\t\tmode.type === \"reexport-named-default\"\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tlet info = reexportMaps.get(module);\n\t\t\t\t\t\t\t\t\t\tif (!info) {\n\t\t\t\t\t\t\t\t\t\t\treexportMaps.set(\n\t\t\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\t\t\t(info = {\n\t\t\t\t\t\t\t\t\t\t\t\t\tstatic: new Map(),\n\t\t\t\t\t\t\t\t\t\t\t\t\tdynamic: new Map()\n\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst targetModule = dep._module;\n\t\t\t\t\t\t\t\t\t\tswitch (mode.type) {\n\t\t\t\t\t\t\t\t\t\t\tcase \"safe-reexport\":\n\t\t\t\t\t\t\t\t\t\t\t\tfor (const [key, id] of mode.map) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (id) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\taddStaticReexport(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetModule,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"checked-reexport\":\n\t\t\t\t\t\t\t\t\t\t\t\tfor (const [key, id] of mode.map) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (id) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\taddStaticReexport(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetModule,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"dynamic-reexport\":\n\t\t\t\t\t\t\t\t\t\t\t\taddDynamicReexport(info, targetModule, mode.ignored);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"reexport-non-harmony-default\":\n\t\t\t\t\t\t\t\t\t\t\tcase \"reexport-non-harmony-default-strict\":\n\t\t\t\t\t\t\t\t\t\t\tcase \"reexport-named-default\":\n\t\t\t\t\t\t\t\t\t\t\t\taddStaticReexport(\n\t\t\t\t\t\t\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\tmode.name,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttargetModule,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"default\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Flatten reexports\n\t\t\t\t\tfor (const info of reexportMaps.values()) {\n\t\t\t\t\t\tconst dynamicReexports = info.dynamic;\n\t\t\t\t\t\tinfo.dynamic = new Map();\n\t\t\t\t\t\tfor (const reexport of dynamicReexports) {\n\t\t\t\t\t\t\tlet [targetModule, ignored] = reexport;\n\t\t\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\t\t\tconst innerInfo = reexportMaps.get(targetModule);\n\t\t\t\t\t\t\t\tif (!innerInfo) break;\n\n\t\t\t\t\t\t\t\tfor (const [key, reexports] of innerInfo.static) {\n\t\t\t\t\t\t\t\t\tif (ignored.has(key)) continue;\n\t\t\t\t\t\t\t\t\tfor (const { module, exportName, checked } of reexports) {\n\t\t\t\t\t\t\t\t\t\taddStaticReexport(info, key, module, exportName, checked);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Follow dynamic reexport if there is only one\n\t\t\t\t\t\t\t\tif (innerInfo.dynamic.size !== 1) {\n\t\t\t\t\t\t\t\t\t// When there are more then one, we don't know which one\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tignored = new Set(ignored);\n\t\t\t\t\t\t\t\tfor (const [innerModule, innerIgnored] of innerInfo.dynamic) {\n\t\t\t\t\t\t\t\t\tfor (const key of innerIgnored) {\n\t\t\t\t\t\t\t\t\t\tif (ignored.has(key)) continue;\n\t\t\t\t\t\t\t\t\t\t// This reexports ends here\n\t\t\t\t\t\t\t\t\t\taddStaticReexport(info, key, targetModule, key, true);\n\t\t\t\t\t\t\t\t\t\tignored.add(key);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ttargetModule = innerModule;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Update reexport as all other cases has been handled\n\t\t\t\t\t\t\taddDynamicReexport(info, targetModule, ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const info of reexportMaps.values()) {\n\t\t\t\t\t\tconst staticReexports = info.static;\n\t\t\t\t\t\tinfo.static = new Map();\n\t\t\t\t\t\tfor (const [key, reexports] of staticReexports) {\n\t\t\t\t\t\t\tfor (let mapping of reexports) {\n\t\t\t\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\t\t\t\tconst innerInfo = reexportMaps.get(mapping.module);\n\t\t\t\t\t\t\t\t\tif (!innerInfo) break;\n\n\t\t\t\t\t\t\t\t\tconst newMapping = getMappingFromInfo(\n\t\t\t\t\t\t\t\t\t\tinnerInfo,\n\t\t\t\t\t\t\t\t\t\tmapping.exportName\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (!newMapping) break;\n\t\t\t\t\t\t\t\t\tmapping = newMapping;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\taddStaticReexport(\n\t\t\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\tmapping.module,\n\t\t\t\t\t\t\t\t\tmapping.exportName,\n\t\t\t\t\t\t\t\t\tmapping.checked\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update imports along the reexports from sideEffectFree modules\n\t\t\t\t\tfor (const pair of reexportMaps) {\n\t\t\t\t\t\tconst module = pair[0];\n\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\tlet newReasons = undefined;\n\t\t\t\t\t\tfor (let i = 0; i < module.reasons.length; i++) {\n\t\t\t\t\t\t\tconst reason = module.reasons[i];\n\t\t\t\t\t\t\tconst dep = reason.dependency;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t(dep instanceof HarmonyExportImportedSpecifierDependency ||\n\t\t\t\t\t\t\t\t\t(dep instanceof HarmonyImportSpecifierDependency &&\n\t\t\t\t\t\t\t\t\t\t!dep.namespaceObjectAsContext)) &&\n\t\t\t\t\t\t\t\tdep._id\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst mapping = getMappingFromInfo(info, dep._id);\n\t\t\t\t\t\t\t\tif (mapping) {\n\t\t\t\t\t\t\t\t\tdep.redirectedModule = mapping.module;\n\t\t\t\t\t\t\t\t\tdep.redirectedId = mapping.exportName;\n\t\t\t\t\t\t\t\t\tmapping.module.addReason(\n\t\t\t\t\t\t\t\t\t\treason.module,\n\t\t\t\t\t\t\t\t\t\tdep,\n\t\t\t\t\t\t\t\t\t\treason.explanation\n\t\t\t\t\t\t\t\t\t\t\t? reason.explanation +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\" (skipped side-effect-free modules)\"\n\t\t\t\t\t\t\t\t\t\t\t: \"(skipped side-effect-free modules)\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t// removing the currect reason, by not adding it to the newReasons array\n\t\t\t\t\t\t\t\t\t// lazily create the newReasons array\n\t\t\t\t\t\t\t\t\tif (newReasons === undefined) {\n\t\t\t\t\t\t\t\t\t\tnewReasons = i === 0 ? [] : module.reasons.slice(0, i);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (newReasons !== undefined) newReasons.push(reason);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (newReasons !== undefined) {\n\t\t\t\t\t\t\tmodule.reasons = newReasons;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\tstatic moduleHasSideEffects(moduleName, flagValue) {\n\t\tswitch (typeof flagValue) {\n\t\t\tcase \"undefined\":\n\t\t\t\treturn true;\n\t\t\tcase \"boolean\":\n\t\t\t\treturn flagValue;\n\t\t\tcase \"string\":\n\t\t\t\tif (process.platform === \"win32\") {\n\t\t\t\t\tflagValue = flagValue.replace(/\\\\/g, \"/\");\n\t\t\t\t}\n\t\t\t\treturn mm.isMatch(moduleName, flagValue, {\n\t\t\t\t\tmatchBase: true\n\t\t\t\t});\n\t\t\tcase \"object\":\n\t\t\t\treturn flagValue.some(glob =>\n\t\t\t\t\tSideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob)\n\t\t\t\t);\n\t\t}\n\t}\n}\nmodule.exports = SideEffectsFlagPlugin;\n"]},"metadata":{},"sourceType":"script"}