{"ast":null,"code":"import { getLocalUserIdentity } from \"./user\";\nexport async function getFileIndex(buckets, bucketKey) {\n  try {\n    const metadata = buckets.pullPath(bucketKey, 'index.json');\n    const {\n      value\n    } = await metadata.next();\n    let str = \"\";\n\n    for (let i = 0; i < value.length; i++) {\n      str += String.fromCharCode(parseInt(String(value[i])));\n    }\n\n    const index = JSON.parse(str);\n    return index;\n  } catch (error) {\n    const index = await initIndex(buckets, bucketKey);\n    return index;\n  }\n}\n\nasync function initIndex(buckets, bucketKey) {\n  const identity = await getLocalUserIdentity();\n\n  if (!identity) {\n    console.error('Identity not set'); // @ts-ignore\n\n    return null;\n  }\n\n  const index = {\n    author: identity.public.toString(),\n    counts: 0,\n    paths: []\n  };\n  await storeIndex(index, buckets, bucketKey);\n  return index;\n}\n\nexport async function storeIndex(index, buckets, bucketKey) {\n  const buf = Buffer.from(JSON.stringify(index, null, 2));\n  const path = `index.json`;\n  await buckets.pushPath(bucketKey, path, buf);\n}\n\nfunction Utf8ArrayToStr(array) {\n  var out, i, len, c;\n  var char2, char3;\n  out = \"\";\n  len = array.length;\n  i = 0;\n\n  while (i < len) {\n    c = array[i++];\n\n    switch (c >> 4) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n        // 0xxxxxxx\n        out += String.fromCharCode(c);\n        break;\n\n      case 12:\n      case 13:\n        // 110x xxxx   10xx xxxx\n        char2 = array[i++];\n        out += String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F);\n        break;\n\n      case 14:\n        // 1110 xxxx  10xx xxxx  10xx xxxx\n        char2 = array[i++];\n        char3 = array[i++];\n        out += String.fromCharCode((c & 0x0F) << 12 | (char2 & 0x3F) << 6 | (char3 & 0x3F) << 0);\n        break;\n    }\n  }\n\n  return out;\n}\n\n_c = Utf8ArrayToStr;\n\nvar _c;\n\n$RefreshReg$(_c, \"Utf8ArrayToStr\");","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/src/common/FileIndex.ts"],"names":["getLocalUserIdentity","getFileIndex","buckets","bucketKey","metadata","pullPath","value","next","str","i","length","String","fromCharCode","parseInt","index","JSON","parse","error","initIndex","identity","console","author","public","toString","counts","paths","storeIndex","buf","Buffer","from","stringify","path","pushPath","Utf8ArrayToStr","array","out","len","c","char2","char3"],"mappings":"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","sourcesContent":["import {FileIndex} from \"./Types\";\nimport { Buckets} from '@textile/hub'\nimport {getLocalUserIdentity} from \"./user\";\n\n export async function getFileIndex(buckets:Buckets,bucketKey:string) :Promise<FileIndex>{\n    try {\n        const metadata = buckets.pullPath(bucketKey ,'index.json');\n        const { value } = await metadata.next();\n        let str = \"\";\n        for (let i = 0; i < value.length; i++) {\n            str += String.fromCharCode(parseInt(String(value[i])));\n        }\n        const index: FileIndex = JSON.parse(str);\n        return index\n    } catch (error) {\n        const index = await initIndex(buckets,bucketKey);\n        return index\n    }\n}\n\nasync function  initIndex(buckets:Buckets,bucketKey:string) :Promise<FileIndex> {\n    const identity = await getLocalUserIdentity();\n    if (!identity) {\n        console.error('Identity not set');\n        // @ts-ignore\n        return null;\n    }\n    const index = {\n        author: identity.public.toString(),\n        counts: 0,\n        paths: []\n    };\n    await storeIndex(index,buckets,bucketKey);\n    return index\n}\n\nexport async function  storeIndex(index: FileIndex,buckets:Buckets,bucketKey:string) {\n    const buf = Buffer.from(JSON.stringify(index, null, 2))\n    const path = `index.json`;\n    await buckets.pushPath(bucketKey, path, buf)\n}\n\nfunction Utf8ArrayToStr(array:utf) {\n    var out, i, len, c;\n    var char2, char3;\n\n    out = \"\";\n    len = array.length;\n    i = 0;\n    while(i < len) {\n        c = array[i++];\n        switch(c >> 4)\n        {\n            case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\n            // 0xxxxxxx\n            out += String.fromCharCode(c);\n            break;\n            case 12: case 13:\n            // 110x xxxx   10xx xxxx\n            char2 = array[i++];\n            out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));\n            break;\n            case 14:\n                // 1110 xxxx  10xx xxxx  10xx xxxx\n                char2 = array[i++];\n                char3 = array[i++];\n                out += String.fromCharCode(((c & 0x0F) << 12) |\n                    ((char2 & 0x3F) << 6) |\n                    ((char3 & 0x3F) << 0));\n                break;\n        }\n    }\n\n    return out;\n}"]},"metadata":{},"sourceType":"module"}