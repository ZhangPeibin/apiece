{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst NETWORKS = require('./networks');\n\nconst types = require('./types');\n\nconst ecc = require('tiny-secp256k1');\n\nconst randomBytes = require('randombytes');\n\nconst typeforce = require('typeforce');\n\nconst wif = require('wif');\n\nconst isOptions = typeforce.maybe(typeforce.compile({\n  compressed: types.maybe(types.Boolean),\n  network: types.maybe(types.Network)\n}));\n\nclass ECPair {\n  constructor(__D, __Q, options) {\n    this.__D = __D;\n    this.__Q = __Q;\n    this.lowR = false;\n    if (options === undefined) options = {};\n    this.compressed = options.compressed === undefined ? true : options.compressed;\n    this.network = options.network || NETWORKS.bitcoin;\n    if (__Q !== undefined) this.__Q = ecc.pointCompress(__Q, this.compressed);\n  }\n\n  get privateKey() {\n    return this.__D;\n  }\n\n  get publicKey() {\n    if (!this.__Q) this.__Q = ecc.pointFromScalar(this.__D, this.compressed);\n    return this.__Q;\n  }\n\n  toWIF() {\n    if (!this.__D) throw new Error('Missing private key');\n    return wif.encode(this.network.wif, this.__D, this.compressed);\n  }\n\n  sign(hash, lowR) {\n    if (!this.__D) throw new Error('Missing private key');\n    if (lowR === undefined) lowR = this.lowR;\n\n    if (lowR === false) {\n      return ecc.sign(hash, this.__D);\n    } else {\n      let sig = ecc.sign(hash, this.__D);\n      const extraData = Buffer.alloc(32, 0);\n      let counter = 0; // if first try is lowR, skip the loop\n      // for second try and on, add extra entropy counting up\n\n      while (sig[0] > 0x7f) {\n        counter++;\n        extraData.writeUIntLE(counter, 0, 6);\n        sig = ecc.signWithEntropy(hash, this.__D, extraData);\n      }\n\n      return sig;\n    }\n  }\n\n  verify(hash, signature) {\n    return ecc.verify(hash, this.publicKey, signature);\n  }\n\n}\n\nfunction fromPrivateKey(buffer, options) {\n  typeforce(types.Buffer256bit, buffer);\n  if (!ecc.isPrivate(buffer)) throw new TypeError('Private key not in range [1, n)');\n  typeforce(isOptions, options);\n  return new ECPair(buffer, undefined, options);\n}\n\nexports.fromPrivateKey = fromPrivateKey;\n\nfunction fromPublicKey(buffer, options) {\n  typeforce(ecc.isPoint, buffer);\n  typeforce(isOptions, options);\n  return new ECPair(undefined, buffer, options);\n}\n\nexports.fromPublicKey = fromPublicKey;\n\nfunction fromWIF(wifString, network) {\n  const decoded = wif.decode(wifString);\n  const version = decoded.version; // list of networks?\n\n  if (types.Array(network)) {\n    network = network.filter(x => {\n      return version === x.wif;\n    }).pop();\n    if (!network) throw new Error('Unknown network version'); // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = network || NETWORKS.bitcoin;\n    if (version !== network.wif) throw new Error('Invalid network version');\n  }\n\n  return fromPrivateKey(decoded.privateKey, {\n    compressed: decoded.compressed,\n    network: network\n  });\n}\n\nexports.fromWIF = fromWIF;\n\nfunction makeRandom(options) {\n  typeforce(isOptions, options);\n  if (options === undefined) options = {};\n  const rng = options.rng || randomBytes;\n  let d;\n\n  do {\n    d = rng(32);\n    typeforce(types.Buffer256bit, d);\n  } while (!ecc.isPrivate(d));\n\n  return fromPrivateKey(d, options);\n}\n\nexports.makeRandom = makeRandom;","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/bitcoinjs-lib/src/ecpair.js"],"names":["Object","defineProperty","exports","value","NETWORKS","require","types","ecc","randomBytes","typeforce","wif","isOptions","maybe","compile","compressed","Boolean","network","Network","ECPair","constructor","__D","__Q","options","lowR","undefined","bitcoin","pointCompress","privateKey","publicKey","pointFromScalar","toWIF","Error","encode","sign","hash","sig","extraData","Buffer","alloc","counter","writeUIntLE","signWithEntropy","verify","signature","fromPrivateKey","buffer","Buffer256bit","isPrivate","TypeError","fromPublicKey","isPoint","fromWIF","wifString","decoded","decode","version","Array","filter","x","pop","makeRandom","rng","d"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst NETWORKS = require('./networks');\nconst types = require('./types');\nconst ecc = require('tiny-secp256k1');\nconst randomBytes = require('randombytes');\nconst typeforce = require('typeforce');\nconst wif = require('wif');\nconst isOptions = typeforce.maybe(\n  typeforce.compile({\n    compressed: types.maybe(types.Boolean),\n    network: types.maybe(types.Network),\n  }),\n);\nclass ECPair {\n  constructor(__D, __Q, options) {\n    this.__D = __D;\n    this.__Q = __Q;\n    this.lowR = false;\n    if (options === undefined) options = {};\n    this.compressed =\n      options.compressed === undefined ? true : options.compressed;\n    this.network = options.network || NETWORKS.bitcoin;\n    if (__Q !== undefined) this.__Q = ecc.pointCompress(__Q, this.compressed);\n  }\n  get privateKey() {\n    return this.__D;\n  }\n  get publicKey() {\n    if (!this.__Q) this.__Q = ecc.pointFromScalar(this.__D, this.compressed);\n    return this.__Q;\n  }\n  toWIF() {\n    if (!this.__D) throw new Error('Missing private key');\n    return wif.encode(this.network.wif, this.__D, this.compressed);\n  }\n  sign(hash, lowR) {\n    if (!this.__D) throw new Error('Missing private key');\n    if (lowR === undefined) lowR = this.lowR;\n    if (lowR === false) {\n      return ecc.sign(hash, this.__D);\n    } else {\n      let sig = ecc.sign(hash, this.__D);\n      const extraData = Buffer.alloc(32, 0);\n      let counter = 0;\n      // if first try is lowR, skip the loop\n      // for second try and on, add extra entropy counting up\n      while (sig[0] > 0x7f) {\n        counter++;\n        extraData.writeUIntLE(counter, 0, 6);\n        sig = ecc.signWithEntropy(hash, this.__D, extraData);\n      }\n      return sig;\n    }\n  }\n  verify(hash, signature) {\n    return ecc.verify(hash, this.publicKey, signature);\n  }\n}\nfunction fromPrivateKey(buffer, options) {\n  typeforce(types.Buffer256bit, buffer);\n  if (!ecc.isPrivate(buffer))\n    throw new TypeError('Private key not in range [1, n)');\n  typeforce(isOptions, options);\n  return new ECPair(buffer, undefined, options);\n}\nexports.fromPrivateKey = fromPrivateKey;\nfunction fromPublicKey(buffer, options) {\n  typeforce(ecc.isPoint, buffer);\n  typeforce(isOptions, options);\n  return new ECPair(undefined, buffer, options);\n}\nexports.fromPublicKey = fromPublicKey;\nfunction fromWIF(wifString, network) {\n  const decoded = wif.decode(wifString);\n  const version = decoded.version;\n  // list of networks?\n  if (types.Array(network)) {\n    network = network\n      .filter(x => {\n        return version === x.wif;\n      })\n      .pop();\n    if (!network) throw new Error('Unknown network version');\n    // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = network || NETWORKS.bitcoin;\n    if (version !== network.wif) throw new Error('Invalid network version');\n  }\n  return fromPrivateKey(decoded.privateKey, {\n    compressed: decoded.compressed,\n    network: network,\n  });\n}\nexports.fromWIF = fromWIF;\nfunction makeRandom(options) {\n  typeforce(isOptions, options);\n  if (options === undefined) options = {};\n  const rng = options.rng || randomBytes;\n  let d;\n  do {\n    d = rng(32);\n    typeforce(types.Buffer256bit, d);\n  } while (!ecc.isPrivate(d));\n  return fromPrivateKey(d, options);\n}\nexports.makeRandom = makeRandom;\n"]},"metadata":{},"sourceType":"script"}