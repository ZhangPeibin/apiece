{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst bcrypto = require('../crypto');\n\nconst networks_1 = require('../networks');\n\nconst bscript = require('../script');\n\nconst lazy = require('./lazy');\n\nconst typef = require('typeforce');\n\nconst OPS = bscript.OPS;\n\nconst ecc = require('tiny-secp256k1');\n\nconst bech32 = require('bech32');\n\nconst EMPTY_BUFFER = Buffer.alloc(0); // witness: {signature} {pubKey}\n// input: <>\n// output: OP_0 {pubKeyHash}\n\nfunction p2wpkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness) throw new TypeError('Not enough data');\n  opts = Object.assign({\n    validate: true\n  }, opts || {});\n  typef({\n    address: typef.maybe(typef.String),\n    hash: typef.maybe(typef.BufferN(20)),\n    input: typef.maybe(typef.BufferN(0)),\n    network: typef.maybe(typef.Object),\n    output: typef.maybe(typef.BufferN(22)),\n    pubkey: typef.maybe(ecc.isPoint),\n    signature: typef.maybe(bscript.isCanonicalScriptSignature),\n    witness: typef.maybe(typef.arrayOf(typef.Buffer))\n  }, a);\n\n  const _address = lazy.value(() => {\n    const result = bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data)\n    };\n  });\n\n  const network = a.network || networks_1.bitcoin;\n  const o = {\n    name: 'p2wpkh',\n    network\n  };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().data;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (!a.witness) return;\n    return a.witness[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.witness) return;\n    return a.witness[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return [a.signature, a.pubkey];\n  }); // extended validation\n\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix) throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00) throw new TypeError('Invalid address version');\n      if (_address().data.length !== 20) throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash)) throw new TypeError('Hash mismatch');else hash = a.hash;\n    }\n\n    if (a.output) {\n      if (a.output.length !== 22 || a.output[0] !== OPS.OP_0 || a.output[1] !== 0x14) throw new TypeError('Output is invalid');\n      if (hash.length > 0 && !hash.equals(a.output.slice(2))) throw new TypeError('Hash mismatch');else hash = a.output.slice(2);\n    }\n\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh)) throw new TypeError('Hash mismatch');else hash = pkh;\n      if (!ecc.isPoint(a.pubkey) || a.pubkey.length !== 33) throw new TypeError('Invalid pubkey for p2wpkh');\n    }\n\n    if (a.witness) {\n      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');\n      if (!bscript.isCanonicalScriptSignature(a.witness[0])) throw new TypeError('Witness has invalid signature');\n      if (!ecc.isPoint(a.witness[1]) || a.witness[1].length !== 33) throw new TypeError('Witness has invalid pubkey');\n      if (a.signature && !a.signature.equals(a.witness[0])) throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(a.witness[1])) throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(a.witness[1]);\n      if (hash.length > 0 && !hash.equals(pkh)) throw new TypeError('Hash mismatch');\n    }\n  }\n\n  return Object.assign(o, a);\n}\n\nexports.p2wpkh = p2wpkh;","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/bitcoinjs-lib/src/payments/p2wpkh.js"],"names":["Object","defineProperty","exports","value","bcrypto","require","networks_1","bscript","lazy","typef","OPS","ecc","bech32","EMPTY_BUFFER","Buffer","alloc","p2wpkh","a","opts","address","hash","output","pubkey","witness","TypeError","assign","validate","maybe","String","BufferN","input","network","isPoint","signature","isCanonicalScriptSignature","arrayOf","_address","result","decode","version","words","shift","data","fromWords","prefix","from","bitcoin","o","name","prop","toWords","unshift","encode","slice","hash160","compile","OP_0","length","equals","pkh"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst ecc = require('tiny-secp256k1');\nconst bech32 = require('bech32');\nconst EMPTY_BUFFER = Buffer.alloc(0);\n// witness: {signature} {pubKey}\n// input: <>\n// output: OP_0 {pubKeyHash}\nfunction p2wpkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      address: typef.maybe(typef.String),\n      hash: typef.maybe(typef.BufferN(20)),\n      input: typef.maybe(typef.BufferN(0)),\n      network: typef.maybe(typef.Object),\n      output: typef.maybe(typef.BufferN(22)),\n      pubkey: typef.maybe(ecc.isPoint),\n      signature: typef.maybe(bscript.isCanonicalScriptSignature),\n      witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data),\n    };\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2wpkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().data;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (!a.witness) return;\n    return a.witness[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.witness) return;\n    return a.witness[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return [a.signature, a.pubkey];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 20)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 22 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x14\n      )\n        throw new TypeError('Output is invalid');\n      if (hash.length > 0 && !hash.equals(a.output.slice(2)))\n        throw new TypeError('Hash mismatch');\n      else hash = a.output.slice(2);\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n      if (!ecc.isPoint(a.pubkey) || a.pubkey.length !== 33)\n        throw new TypeError('Invalid pubkey for p2wpkh');\n    }\n    if (a.witness) {\n      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');\n      if (!bscript.isCanonicalScriptSignature(a.witness[0]))\n        throw new TypeError('Witness has invalid signature');\n      if (!ecc.isPoint(a.witness[1]) || a.witness[1].length !== 33)\n        throw new TypeError('Witness has invalid pubkey');\n      if (a.signature && !a.signature.equals(a.witness[0]))\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(a.witness[1]))\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(a.witness[1]);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2wpkh = p2wpkh;\n"]},"metadata":{},"sourceType":"script"}