{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst convert = require('../converter');\n\nconst tools_1 = require('../converter/tools');\n\nconst varuint = require('../converter/varint');\n\nconst typeFields_1 = require('../typeFields');\n\nfunction psbtFromBuffer(buffer, txGetter) {\n  let offset = 0;\n\n  function varSlice() {\n    const keyLen = varuint.decode(buffer, offset);\n    offset += varuint.encodingLength(keyLen);\n    const key = buffer.slice(offset, offset + keyLen);\n    offset += keyLen;\n    return key;\n  }\n\n  function readUInt32BE() {\n    const num = buffer.readUInt32BE(offset);\n    offset += 4;\n    return num;\n  }\n\n  function readUInt8() {\n    const num = buffer.readUInt8(offset);\n    offset += 1;\n    return num;\n  }\n\n  function getKeyValue() {\n    const key = varSlice();\n    const value = varSlice();\n    return {\n      key,\n      value\n    };\n  }\n\n  function checkEndOfKeyValPairs() {\n    if (offset >= buffer.length) {\n      throw new Error('Format Error: Unexpected End of PSBT');\n    }\n\n    const isEnd = buffer.readUInt8(offset) === 0;\n\n    if (isEnd) {\n      offset++;\n    }\n\n    return isEnd;\n  }\n\n  if (readUInt32BE() !== 0x70736274) {\n    throw new Error('Format Error: Invalid Magic Number');\n  }\n\n  if (readUInt8() !== 0xff) {\n    throw new Error('Format Error: Magic Number must be followed by 0xff separator');\n  }\n\n  const globalMapKeyVals = [];\n  const globalKeyIndex = {};\n\n  while (!checkEndOfKeyValPairs()) {\n    const keyVal = getKeyValue();\n    const hexKey = keyVal.key.toString('hex');\n\n    if (globalKeyIndex[hexKey]) {\n      throw new Error('Format Error: Keys must be unique for global keymap: key ' + hexKey);\n    }\n\n    globalKeyIndex[hexKey] = 1;\n    globalMapKeyVals.push(keyVal);\n  }\n\n  const unsignedTxMaps = globalMapKeyVals.filter(keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX);\n\n  if (unsignedTxMaps.length !== 1) {\n    throw new Error('Format Error: Only one UNSIGNED_TX allowed');\n  }\n\n  const unsignedTx = txGetter(unsignedTxMaps[0].value); // Get input and output counts to loop the respective fields\n\n  const {\n    inputCount,\n    outputCount\n  } = unsignedTx.getInputOutputCounts();\n  const inputKeyVals = [];\n  const outputKeyVals = []; // Get input fields\n\n  for (const index of tools_1.range(inputCount)) {\n    const inputKeyIndex = {};\n    const input = [];\n\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n\n      if (inputKeyIndex[hexKey]) {\n        throw new Error('Format Error: Keys must be unique for each input: ' + 'input index ' + index + ' key ' + hexKey);\n      }\n\n      inputKeyIndex[hexKey] = 1;\n      input.push(keyVal);\n    }\n\n    inputKeyVals.push(input);\n  }\n\n  for (const index of tools_1.range(outputCount)) {\n    const outputKeyIndex = {};\n    const output = [];\n\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n\n      if (outputKeyIndex[hexKey]) {\n        throw new Error('Format Error: Keys must be unique for each output: ' + 'output index ' + index + ' key ' + hexKey);\n      }\n\n      outputKeyIndex[hexKey] = 1;\n      output.push(keyVal);\n    }\n\n    outputKeyVals.push(output);\n  }\n\n  return psbtFromKeyVals(unsignedTx, {\n    globalMapKeyVals,\n    inputKeyVals,\n    outputKeyVals\n  });\n}\n\nexports.psbtFromBuffer = psbtFromBuffer;\n\nfunction checkKeyBuffer(type, keyBuf, keyNum) {\n  if (!keyBuf.equals(Buffer.from([keyNum]))) {\n    throw new Error(`Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`);\n  }\n}\n\nexports.checkKeyBuffer = checkKeyBuffer;\n\nfunction psbtFromKeyVals(unsignedTx, {\n  globalMapKeyVals,\n  inputKeyVals,\n  outputKeyVals\n}) {\n  // That was easy :-)\n  const globalMap = {\n    unsignedTx\n  };\n  let txCount = 0;\n\n  for (const keyVal of globalMapKeyVals) {\n    // If a globalMap item needs pubkey, uncomment\n    // const pubkey = convert.globals.checkPubkey(keyVal);\n    switch (keyVal.key[0]) {\n      case typeFields_1.GlobalTypes.UNSIGNED_TX:\n        checkKeyBuffer('global', keyVal.key, typeFields_1.GlobalTypes.UNSIGNED_TX);\n\n        if (txCount > 0) {\n          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');\n        }\n\n        txCount++;\n        break;\n\n      case typeFields_1.GlobalTypes.GLOBAL_XPUB:\n        if (globalMap.globalXpub === undefined) {\n          globalMap.globalXpub = [];\n        }\n\n        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));\n        break;\n\n      default:\n        // This will allow inclusion during serialization.\n        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];\n        globalMap.unknownKeyVals.push(keyVal);\n    }\n  } // Get input and output counts to loop the respective fields\n\n\n  const inputCount = inputKeyVals.length;\n  const outputCount = outputKeyVals.length;\n  const inputs = [];\n  const outputs = []; // Get input fields\n\n  for (const index of tools_1.range(inputCount)) {\n    const input = {};\n\n    for (const keyVal of inputKeyVals[index]) {\n      convert.inputs.checkPubkey(keyVal);\n\n      switch (keyVal.key[0]) {\n        case typeFields_1.InputTypes.NON_WITNESS_UTXO:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.NON_WITNESS_UTXO);\n\n          if (input.nonWitnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple NON_WITNESS_UTXO');\n          }\n\n          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.WITNESS_UTXO:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.WITNESS_UTXO);\n\n          if (input.witnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_UTXO');\n          }\n\n          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.PARTIAL_SIG:\n          if (input.partialSig === undefined) {\n            input.partialSig = [];\n          }\n\n          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));\n          break;\n\n        case typeFields_1.InputTypes.SIGHASH_TYPE:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.SIGHASH_TYPE);\n\n          if (input.sighashType !== undefined) {\n            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');\n          }\n\n          input.sighashType = convert.inputs.sighashType.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.REDEEM_SCRIPT);\n\n          if (input.redeemScript !== undefined) {\n            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');\n          }\n\n          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.WITNESS_SCRIPT);\n\n          if (input.witnessScript !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');\n          }\n\n          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.BIP32_DERIVATION:\n          if (input.bip32Derivation === undefined) {\n            input.bip32Derivation = [];\n          }\n\n          input.bip32Derivation.push(convert.inputs.bip32Derivation.decode(keyVal));\n          break;\n\n        case typeFields_1.InputTypes.FINAL_SCRIPTSIG:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.FINAL_SCRIPTSIG);\n          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.FINAL_SCRIPTWITNESS);\n          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.POR_COMMITMENT:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.POR_COMMITMENT);\n          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);\n          break;\n\n        default:\n          // This will allow inclusion during serialization.\n          if (!input.unknownKeyVals) input.unknownKeyVals = [];\n          input.unknownKeyVals.push(keyVal);\n      }\n    }\n\n    inputs.push(input);\n  }\n\n  for (const index of tools_1.range(outputCount)) {\n    const output = {};\n\n    for (const keyVal of outputKeyVals[index]) {\n      convert.outputs.checkPubkey(keyVal);\n\n      switch (keyVal.key[0]) {\n        case typeFields_1.OutputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer('output', keyVal.key, typeFields_1.OutputTypes.REDEEM_SCRIPT);\n\n          if (output.redeemScript !== undefined) {\n            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');\n          }\n\n          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);\n          break;\n\n        case typeFields_1.OutputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer('output', keyVal.key, typeFields_1.OutputTypes.WITNESS_SCRIPT);\n\n          if (output.witnessScript !== undefined) {\n            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');\n          }\n\n          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);\n          break;\n\n        case typeFields_1.OutputTypes.BIP32_DERIVATION:\n          if (output.bip32Derivation === undefined) {\n            output.bip32Derivation = [];\n          }\n\n          output.bip32Derivation.push(convert.outputs.bip32Derivation.decode(keyVal));\n          break;\n\n        default:\n          if (!output.unknownKeyVals) output.unknownKeyVals = [];\n          output.unknownKeyVals.push(keyVal);\n      }\n    }\n\n    outputs.push(output);\n  }\n\n  return {\n    globalMap,\n    inputs,\n    outputs\n  };\n}\n\nexports.psbtFromKeyVals = psbtFromKeyVals;","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/bip174/src/lib/parser/fromBuffer.js"],"names":["Object","defineProperty","exports","value","convert","require","tools_1","varuint","typeFields_1","psbtFromBuffer","buffer","txGetter","offset","varSlice","keyLen","decode","encodingLength","key","slice","readUInt32BE","num","readUInt8","getKeyValue","checkEndOfKeyValPairs","length","Error","isEnd","globalMapKeyVals","globalKeyIndex","keyVal","hexKey","toString","push","unsignedTxMaps","filter","GlobalTypes","UNSIGNED_TX","unsignedTx","inputCount","outputCount","getInputOutputCounts","inputKeyVals","outputKeyVals","index","range","inputKeyIndex","input","outputKeyIndex","output","psbtFromKeyVals","checkKeyBuffer","type","keyBuf","keyNum","equals","Buffer","from","globalMap","txCount","GLOBAL_XPUB","globalXpub","undefined","globals","unknownKeyVals","inputs","outputs","checkPubkey","InputTypes","NON_WITNESS_UTXO","nonWitnessUtxo","WITNESS_UTXO","witnessUtxo","PARTIAL_SIG","partialSig","SIGHASH_TYPE","sighashType","REDEEM_SCRIPT","redeemScript","WITNESS_SCRIPT","witnessScript","BIP32_DERIVATION","bip32Derivation","FINAL_SCRIPTSIG","finalScriptSig","FINAL_SCRIPTWITNESS","finalScriptWitness","POR_COMMITMENT","porCommitment","OutputTypes"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst convert = require('../converter');\nconst tools_1 = require('../converter/tools');\nconst varuint = require('../converter/varint');\nconst typeFields_1 = require('../typeFields');\nfunction psbtFromBuffer(buffer, txGetter) {\n  let offset = 0;\n  function varSlice() {\n    const keyLen = varuint.decode(buffer, offset);\n    offset += varuint.encodingLength(keyLen);\n    const key = buffer.slice(offset, offset + keyLen);\n    offset += keyLen;\n    return key;\n  }\n  function readUInt32BE() {\n    const num = buffer.readUInt32BE(offset);\n    offset += 4;\n    return num;\n  }\n  function readUInt8() {\n    const num = buffer.readUInt8(offset);\n    offset += 1;\n    return num;\n  }\n  function getKeyValue() {\n    const key = varSlice();\n    const value = varSlice();\n    return {\n      key,\n      value,\n    };\n  }\n  function checkEndOfKeyValPairs() {\n    if (offset >= buffer.length) {\n      throw new Error('Format Error: Unexpected End of PSBT');\n    }\n    const isEnd = buffer.readUInt8(offset) === 0;\n    if (isEnd) {\n      offset++;\n    }\n    return isEnd;\n  }\n  if (readUInt32BE() !== 0x70736274) {\n    throw new Error('Format Error: Invalid Magic Number');\n  }\n  if (readUInt8() !== 0xff) {\n    throw new Error(\n      'Format Error: Magic Number must be followed by 0xff separator',\n    );\n  }\n  const globalMapKeyVals = [];\n  const globalKeyIndex = {};\n  while (!checkEndOfKeyValPairs()) {\n    const keyVal = getKeyValue();\n    const hexKey = keyVal.key.toString('hex');\n    if (globalKeyIndex[hexKey]) {\n      throw new Error(\n        'Format Error: Keys must be unique for global keymap: key ' + hexKey,\n      );\n    }\n    globalKeyIndex[hexKey] = 1;\n    globalMapKeyVals.push(keyVal);\n  }\n  const unsignedTxMaps = globalMapKeyVals.filter(\n    keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX,\n  );\n  if (unsignedTxMaps.length !== 1) {\n    throw new Error('Format Error: Only one UNSIGNED_TX allowed');\n  }\n  const unsignedTx = txGetter(unsignedTxMaps[0].value);\n  // Get input and output counts to loop the respective fields\n  const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();\n  const inputKeyVals = [];\n  const outputKeyVals = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const inputKeyIndex = {};\n    const input = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (inputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each input: ' +\n            'input index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      inputKeyIndex[hexKey] = 1;\n      input.push(keyVal);\n    }\n    inputKeyVals.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const outputKeyIndex = {};\n    const output = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (outputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each output: ' +\n            'output index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      outputKeyIndex[hexKey] = 1;\n      output.push(keyVal);\n    }\n    outputKeyVals.push(output);\n  }\n  return psbtFromKeyVals(unsignedTx, {\n    globalMapKeyVals,\n    inputKeyVals,\n    outputKeyVals,\n  });\n}\nexports.psbtFromBuffer = psbtFromBuffer;\nfunction checkKeyBuffer(type, keyBuf, keyNum) {\n  if (!keyBuf.equals(Buffer.from([keyNum]))) {\n    throw new Error(\n      `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,\n    );\n  }\n}\nexports.checkKeyBuffer = checkKeyBuffer;\nfunction psbtFromKeyVals(\n  unsignedTx,\n  { globalMapKeyVals, inputKeyVals, outputKeyVals },\n) {\n  // That was easy :-)\n  const globalMap = {\n    unsignedTx,\n  };\n  let txCount = 0;\n  for (const keyVal of globalMapKeyVals) {\n    // If a globalMap item needs pubkey, uncomment\n    // const pubkey = convert.globals.checkPubkey(keyVal);\n    switch (keyVal.key[0]) {\n      case typeFields_1.GlobalTypes.UNSIGNED_TX:\n        checkKeyBuffer(\n          'global',\n          keyVal.key,\n          typeFields_1.GlobalTypes.UNSIGNED_TX,\n        );\n        if (txCount > 0) {\n          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');\n        }\n        txCount++;\n        break;\n      case typeFields_1.GlobalTypes.GLOBAL_XPUB:\n        if (globalMap.globalXpub === undefined) {\n          globalMap.globalXpub = [];\n        }\n        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));\n        break;\n      default:\n        // This will allow inclusion during serialization.\n        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];\n        globalMap.unknownKeyVals.push(keyVal);\n    }\n  }\n  // Get input and output counts to loop the respective fields\n  const inputCount = inputKeyVals.length;\n  const outputCount = outputKeyVals.length;\n  const inputs = [];\n  const outputs = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const input = {};\n    for (const keyVal of inputKeyVals[index]) {\n      convert.inputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.InputTypes.NON_WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.NON_WITNESS_UTXO,\n          );\n          if (input.nonWitnessUtxo !== undefined) {\n            throw new Error(\n              'Format Error: Input has multiple NON_WITNESS_UTXO',\n            );\n          }\n          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_UTXO,\n          );\n          if (input.witnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_UTXO');\n          }\n          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.PARTIAL_SIG:\n          if (input.partialSig === undefined) {\n            input.partialSig = [];\n          }\n          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.SIGHASH_TYPE:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.SIGHASH_TYPE,\n          );\n          if (input.sighashType !== undefined) {\n            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');\n          }\n          input.sighashType = convert.inputs.sighashType.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.REDEEM_SCRIPT,\n          );\n          if (input.redeemScript !== undefined) {\n            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');\n          }\n          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_SCRIPT,\n          );\n          if (input.witnessScript !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');\n          }\n          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.BIP32_DERIVATION:\n          if (input.bip32Derivation === undefined) {\n            input.bip32Derivation = [];\n          }\n          input.bip32Derivation.push(\n            convert.inputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTSIG:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTSIG,\n          );\n          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTWITNESS,\n          );\n          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(\n            keyVal,\n          );\n          break;\n        case typeFields_1.InputTypes.POR_COMMITMENT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.POR_COMMITMENT,\n          );\n          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);\n          break;\n        default:\n          // This will allow inclusion during serialization.\n          if (!input.unknownKeyVals) input.unknownKeyVals = [];\n          input.unknownKeyVals.push(keyVal);\n      }\n    }\n    inputs.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const output = {};\n    for (const keyVal of outputKeyVals[index]) {\n      convert.outputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.OutputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.REDEEM_SCRIPT,\n          );\n          if (output.redeemScript !== undefined) {\n            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');\n          }\n          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.WITNESS_SCRIPT,\n          );\n          if (output.witnessScript !== undefined) {\n            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');\n          }\n          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.BIP32_DERIVATION:\n          if (output.bip32Derivation === undefined) {\n            output.bip32Derivation = [];\n          }\n          output.bip32Derivation.push(\n            convert.outputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        default:\n          if (!output.unknownKeyVals) output.unknownKeyVals = [];\n          output.unknownKeyVals.push(keyVal);\n      }\n    }\n    outputs.push(output);\n  }\n  return { globalMap, inputs, outputs };\n}\nexports.psbtFromKeyVals = psbtFromKeyVals;\n"]},"metadata":{},"sourceType":"script"}