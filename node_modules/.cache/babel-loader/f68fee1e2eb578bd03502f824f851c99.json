{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\n\nconst GraphHelpers = require(\"./GraphHelpers\");\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./Compilation\")} Compilation */\n\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n\n/** @typedef {import(\"./Dependency\")} Dependency */\n\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {Set<Module>} minAvailableModules current minimal set of modules available at this point\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\n * @property {Set<Module>[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {QueueItem[]} skippedItems queue items that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<Module>} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroup>} children set of children chunk groups, that will be revisited when availableModules shrink\n */\n\n/**\n * @typedef {Object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\n/**\n * @template T\n * @param {Set<T>} a first set\n * @param {Set<T>} b second set\n * @returns {number} cmp\n */\n\n\nconst bySetSize = (a, b) => {\n  return b.size - a.size;\n};\n/**\n * Extracts simplified info from the modules and their dependencies\n * @param {Compilation} compilation the compilation\n * @returns {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} the mapping block to modules and inner blocks\n */\n\n\nconst extraceBlockInfoMap = compilation => {\n  /** @type {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} */\n  const blockInfoMap = new Map();\n  /**\n   * @param {Dependency} d dependency to iterate over\n   * @returns {void}\n   */\n\n  const iteratorDependency = d => {\n    // We skip Dependencies without Reference\n    const ref = compilation.getDependencyReference(currentModule, d);\n\n    if (!ref) {\n      return;\n    } // We skip Dependencies without Module pointer\n\n\n    const refModule = ref.module;\n\n    if (!refModule) {\n      return;\n    } // We skip weak Dependencies\n\n\n    if (ref.weak) {\n      return;\n    }\n\n    blockInfoModules.add(refModule);\n  };\n  /**\n   * @param {AsyncDependenciesBlock} b blocks to prepare\n   * @returns {void}\n   */\n\n\n  const iteratorBlockPrepare = b => {\n    blockInfoBlocks.push(b);\n    blockQueue.push(b);\n  };\n  /** @type {Module} */\n\n\n  let currentModule;\n  /** @type {DependenciesBlock} */\n\n  let block;\n  /** @type {DependenciesBlock[]} */\n\n  let blockQueue;\n  /** @type {Set<Module>} */\n\n  let blockInfoModules;\n  /** @type {AsyncDependenciesBlock[]} */\n\n  let blockInfoBlocks;\n\n  for (const module of compilation.modules) {\n    blockQueue = [module];\n    currentModule = module;\n\n    while (blockQueue.length > 0) {\n      block = blockQueue.pop();\n      blockInfoModules = new Set();\n      blockInfoBlocks = [];\n\n      if (block.variables) {\n        for (const variable of block.variables) {\n          for (const dep of variable.dependencies) iteratorDependency(dep);\n        }\n      }\n\n      if (block.dependencies) {\n        for (const dep of block.dependencies) iteratorDependency(dep);\n      }\n\n      if (block.blocks) {\n        for (const b of block.blocks) iteratorBlockPrepare(b);\n      }\n\n      const blockInfo = {\n        modules: blockInfoModules,\n        blocks: blockInfoBlocks\n      };\n      blockInfoMap.set(block, blockInfo);\n    }\n  }\n\n  return blockInfoMap;\n};\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups input groups\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\n */\n\n\nconst visitModules = (compilation, inputChunkGroups, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups) => {\n  const logger = compilation.getLogger(\"webpack.buildChunkGraph.visitModules\");\n  const {\n    namedChunkGroups\n  } = compilation;\n  logger.time(\"prepare\");\n  const blockInfoMap = extraceBlockInfoMap(compilation);\n  /** @type {Map<ChunkGroup, { index: number, index2: number }>} */\n\n  const chunkGroupCounters = new Map();\n\n  for (const chunkGroup of inputChunkGroups) {\n    chunkGroupCounters.set(chunkGroup, {\n      index: 0,\n      index2: 0\n    });\n  }\n\n  let nextFreeModuleIndex = 0;\n  let nextFreeModuleIndex2 = 0;\n  /** @type {Map<DependenciesBlock, ChunkGroup>} */\n\n  const blockChunkGroups = new Map();\n  const ADD_AND_ENTER_MODULE = 0;\n  const ENTER_MODULE = 1;\n  const PROCESS_BLOCK = 2;\n  const LEAVE_MODULE = 3;\n  /**\n   * @param {QueueItem[]} queue the queue array (will be mutated)\n   * @param {ChunkGroup} chunkGroup chunk group\n   * @returns {QueueItem[]} the queue array again\n   */\n\n  const reduceChunkGroupToQueueItem = (queue, chunkGroup) => {\n    for (const chunk of chunkGroup.chunks) {\n      const module = chunk.entryModule;\n      queue.push({\n        action: ENTER_MODULE,\n        block: module,\n        module,\n        chunk,\n        chunkGroup\n      });\n    }\n\n    chunkGroupInfoMap.set(chunkGroup, {\n      chunkGroup,\n      minAvailableModules: new Set(),\n      minAvailableModulesOwned: true,\n      availableModulesToBeMerged: [],\n      skippedItems: [],\n      resultingAvailableModules: undefined,\n      children: undefined\n    });\n    return queue;\n  }; // Start with the provided modules/chunks\n\n  /** @type {QueueItem[]} */\n\n\n  let queue = inputChunkGroups.reduce(reduceChunkGroupToQueueItem, []).reverse();\n  /** @type {Map<ChunkGroup, Set<ChunkGroup>>} */\n\n  const queueConnect = new Map();\n  /** @type {Set<ChunkGroupInfo>} */\n\n  const outdatedChunkGroupInfo = new Set();\n  /** @type {QueueItem[]} */\n\n  let queueDelayed = [];\n  logger.timeEnd(\"prepare\");\n  /** @type {Module} */\n\n  let module;\n  /** @type {Chunk} */\n\n  let chunk;\n  /** @type {ChunkGroup} */\n\n  let chunkGroup;\n  /** @type {ChunkGroupInfo} */\n\n  let chunkGroupInfo;\n  /** @type {DependenciesBlock} */\n\n  let block;\n  /** @type {Set<Module>} */\n\n  let minAvailableModules;\n  /** @type {QueueItem[]} */\n\n  let skippedItems; // For each async Block in graph\n\n  /**\n   * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n   * @returns {void}\n   */\n\n  const iteratorBlock = b => {\n    // 1. We create a chunk for this Block\n    // but only once (blockChunkGroups map)\n    let c = blockChunkGroups.get(b);\n\n    if (c === undefined) {\n      c = namedChunkGroups.get(b.chunkName);\n\n      if (c && c.isInitial()) {\n        compilation.errors.push(new AsyncDependencyToInitialChunkError(b.chunkName, module, b.loc));\n        c = chunkGroup;\n      } else {\n        c = compilation.addChunkInGroup(b.groupOptions || b.chunkName, module, b.loc, b.request);\n        chunkGroupCounters.set(c, {\n          index: 0,\n          index2: 0\n        });\n        blockChunkGroups.set(b, c);\n        allCreatedChunkGroups.add(c);\n      }\n\n      blockConnections.set(b, []);\n    } else {\n      // TODO webpack 5 remove addOptions check\n      if (c.addOptions) c.addOptions(b.groupOptions);\n      c.addOrigin(module, b.loc, b.request);\n    } // 2. We store the connection for the block\n    // to connect it later if needed\n\n\n    blockConnections.get(b).push({\n      originChunkGroupInfo: chunkGroupInfo,\n      chunkGroup: c\n    }); // 3. We create/update the chunk group info\n\n    let connectList = queueConnect.get(chunkGroup);\n\n    if (connectList === undefined) {\n      connectList = new Set();\n      queueConnect.set(chunkGroup, connectList);\n    }\n\n    connectList.add(c); // 4. We enqueue the DependenciesBlock for traversal\n\n    queueDelayed.push({\n      action: PROCESS_BLOCK,\n      block: b,\n      module: module,\n      chunk: c.chunks[0],\n      chunkGroup: c\n    });\n  }; // Iterative traversal of the Module graph\n  // Recursive would be simpler to write but could result in Stack Overflows\n\n\n  while (queue.length) {\n    logger.time(\"visiting\");\n\n    while (queue.length) {\n      const queueItem = queue.pop();\n      module = queueItem.module;\n      block = queueItem.block;\n      chunk = queueItem.chunk;\n\n      if (chunkGroup !== queueItem.chunkGroup) {\n        chunkGroup = queueItem.chunkGroup;\n        chunkGroupInfo = chunkGroupInfoMap.get(chunkGroup);\n        minAvailableModules = chunkGroupInfo.minAvailableModules;\n        skippedItems = chunkGroupInfo.skippedItems;\n      }\n\n      switch (queueItem.action) {\n        case ADD_AND_ENTER_MODULE:\n          {\n            if (minAvailableModules.has(module)) {\n              // already in parent chunks\n              // skip it for now, but enqueue for rechecking when minAvailableModules shrinks\n              skippedItems.push(queueItem);\n              break;\n            } // We connect Module and Chunk when not already done\n\n\n            if (chunk.addModule(module)) {\n              module.addChunk(chunk);\n            } else {\n              // already connected, skip it\n              break;\n            }\n          }\n        // fallthrough\n\n        case ENTER_MODULE:\n          {\n            if (chunkGroup !== undefined) {\n              const index = chunkGroup.getModuleIndex(module);\n\n              if (index === undefined) {\n                chunkGroup.setModuleIndex(module, chunkGroupCounters.get(chunkGroup).index++);\n              }\n            }\n\n            if (module.index === null) {\n              module.index = nextFreeModuleIndex++;\n            }\n\n            queue.push({\n              action: LEAVE_MODULE,\n              block,\n              module,\n              chunk,\n              chunkGroup\n            });\n          }\n        // fallthrough\n\n        case PROCESS_BLOCK:\n          {\n            // get prepared block info\n            const blockInfo = blockInfoMap.get(block); // Buffer items because order need to be reverse to get indicies correct\n\n            const skipBuffer = [];\n            const queueBuffer = []; // Traverse all referenced modules\n\n            for (const refModule of blockInfo.modules) {\n              if (chunk.containsModule(refModule)) {\n                // skip early if already connected\n                continue;\n              }\n\n              if (minAvailableModules.has(refModule)) {\n                // already in parent chunks, skip it for now\n                skipBuffer.push({\n                  action: ADD_AND_ENTER_MODULE,\n                  block: refModule,\n                  module: refModule,\n                  chunk,\n                  chunkGroup\n                });\n                continue;\n              } // enqueue the add and enter to enter in the correct order\n              // this is relevant with circular dependencies\n\n\n              queueBuffer.push({\n                action: ADD_AND_ENTER_MODULE,\n                block: refModule,\n                module: refModule,\n                chunk,\n                chunkGroup\n              });\n            } // Add buffered items in reversed order\n\n\n            for (let i = skipBuffer.length - 1; i >= 0; i--) {\n              skippedItems.push(skipBuffer[i]);\n            }\n\n            for (let i = queueBuffer.length - 1; i >= 0; i--) {\n              queue.push(queueBuffer[i]);\n            } // Traverse all Blocks\n\n\n            for (const block of blockInfo.blocks) iteratorBlock(block);\n\n            if (blockInfo.blocks.length > 0 && module !== block) {\n              blocksWithNestedBlocks.add(block);\n            }\n\n            break;\n          }\n\n        case LEAVE_MODULE:\n          {\n            if (chunkGroup !== undefined) {\n              const index = chunkGroup.getModuleIndex2(module);\n\n              if (index === undefined) {\n                chunkGroup.setModuleIndex2(module, chunkGroupCounters.get(chunkGroup).index2++);\n              }\n            }\n\n            if (module.index2 === null) {\n              module.index2 = nextFreeModuleIndex2++;\n            }\n\n            break;\n          }\n      }\n    }\n\n    logger.timeEnd(\"visiting\");\n\n    while (queueConnect.size > 0) {\n      logger.time(\"calculating available modules\"); // Figure out new parents for chunk groups\n      // to get new available modules for these children\n\n      for (const [chunkGroup, targets] of queueConnect) {\n        const info = chunkGroupInfoMap.get(chunkGroup);\n        let minAvailableModules = info.minAvailableModules; // 1. Create a new Set of available modules at this points\n\n        const resultingAvailableModules = new Set(minAvailableModules);\n\n        for (const chunk of chunkGroup.chunks) {\n          for (const m of chunk.modulesIterable) {\n            resultingAvailableModules.add(m);\n          }\n        }\n\n        info.resultingAvailableModules = resultingAvailableModules;\n\n        if (info.children === undefined) {\n          info.children = targets;\n        } else {\n          for (const target of targets) {\n            info.children.add(target);\n          }\n        } // 2. Update chunk group info\n\n\n        for (const target of targets) {\n          let chunkGroupInfo = chunkGroupInfoMap.get(target);\n\n          if (chunkGroupInfo === undefined) {\n            chunkGroupInfo = {\n              chunkGroup: target,\n              minAvailableModules: undefined,\n              minAvailableModulesOwned: undefined,\n              availableModulesToBeMerged: [],\n              skippedItems: [],\n              resultingAvailableModules: undefined,\n              children: undefined\n            };\n            chunkGroupInfoMap.set(target, chunkGroupInfo);\n          }\n\n          chunkGroupInfo.availableModulesToBeMerged.push(resultingAvailableModules);\n          outdatedChunkGroupInfo.add(chunkGroupInfo);\n        }\n      }\n\n      queueConnect.clear();\n      logger.timeEnd(\"calculating available modules\");\n\n      if (outdatedChunkGroupInfo.size > 0) {\n        logger.time(\"merging available modules\"); // Execute the merge\n\n        for (const info of outdatedChunkGroupInfo) {\n          const availableModulesToBeMerged = info.availableModulesToBeMerged;\n          let cachedMinAvailableModules = info.minAvailableModules; // 1. Get minimal available modules\n          // It doesn't make sense to traverse a chunk again with more available modules.\n          // This step calculates the minimal available modules and skips traversal when\n          // the list didn't shrink.\n\n          if (availableModulesToBeMerged.length > 1) {\n            availableModulesToBeMerged.sort(bySetSize);\n          }\n\n          let changed = false;\n\n          for (const availableModules of availableModulesToBeMerged) {\n            if (cachedMinAvailableModules === undefined) {\n              cachedMinAvailableModules = availableModules;\n              info.minAvailableModules = cachedMinAvailableModules;\n              info.minAvailableModulesOwned = false;\n              changed = true;\n            } else {\n              if (info.minAvailableModulesOwned) {\n                // We own it and can modify it\n                for (const m of cachedMinAvailableModules) {\n                  if (!availableModules.has(m)) {\n                    cachedMinAvailableModules.delete(m);\n                    changed = true;\n                  }\n                }\n              } else {\n                for (const m of cachedMinAvailableModules) {\n                  if (!availableModules.has(m)) {\n                    // cachedMinAvailableModules need to be modified\n                    // but we don't own it\n                    // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\n                    /** @type {Set<Module>} */\n                    const newSet = new Set();\n                    const iterator = cachedMinAvailableModules[Symbol.iterator]();\n                    /** @type {IteratorResult<Module>} */\n\n                    let it;\n\n                    while (!(it = iterator.next()).done) {\n                      const module = it.value;\n                      if (module === m) break;\n                      newSet.add(module);\n                    }\n\n                    while (!(it = iterator.next()).done) {\n                      const module = it.value;\n\n                      if (availableModules.has(module)) {\n                        newSet.add(module);\n                      }\n                    }\n\n                    cachedMinAvailableModules = newSet;\n                    info.minAvailableModulesOwned = true;\n                    info.minAvailableModules = newSet; // Update the cache from the first queue\n                    // if the chunkGroup is currently cached\n\n                    if (chunkGroup === info.chunkGroup) {\n                      minAvailableModules = cachedMinAvailableModules;\n                    }\n\n                    changed = true;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n\n          availableModulesToBeMerged.length = 0;\n          if (!changed) continue; // 2. Reconsider skipped items\n\n          for (const queueItem of info.skippedItems) {\n            queue.push(queueItem);\n          }\n\n          info.skippedItems.length = 0; // 3. Reconsider children chunk groups\n\n          if (info.children !== undefined) {\n            const chunkGroup = info.chunkGroup;\n\n            for (const c of info.children) {\n              let connectList = queueConnect.get(chunkGroup);\n\n              if (connectList === undefined) {\n                connectList = new Set();\n                queueConnect.set(chunkGroup, connectList);\n              }\n\n              connectList.add(c);\n            }\n          }\n        }\n\n        outdatedChunkGroupInfo.clear();\n        logger.timeEnd(\"merging available modules\");\n      }\n    } // Run queueDelayed when all items of the queue are processed\n    // This is important to get the global indicing correct\n    // Async blocks should be processed after all sync blocks are processed\n\n\n    if (queue.length === 0) {\n      const tempQueue = queue;\n      queue = queueDelayed.reverse();\n      queueDelayed = tempQueue;\n    }\n  }\n};\n/**\n *\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n */\n\n\nconst connectChunkGroups = (blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap) => {\n  /**\n   * Helper function to check if all modules of a chunk are available\n   *\n   * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n   * @param {Set<Module>} availableModules the comparitor set\n   * @returns {boolean} return true if all modules of a chunk are available\n   */\n  const areModulesAvailable = (chunkGroup, availableModules) => {\n    for (const chunk of chunkGroup.chunks) {\n      for (const module of chunk.modulesIterable) {\n        if (!availableModules.has(module)) return false;\n      }\n    }\n\n    return true;\n  }; // For each edge in the basic chunk graph\n\n\n  for (const [block, connections] of blockConnections) {\n    // 1. Check if connection is needed\n    // When none of the dependencies need to be connected\n    // we can skip all of them\n    // It's not possible to filter each item so it doesn't create inconsistent\n    // connections and modules can only create one version\n    // TODO maybe decide this per runtime\n    if ( // TODO is this needed?\n    !blocksWithNestedBlocks.has(block) && connections.every(({\n      chunkGroup,\n      originChunkGroupInfo\n    }) => areModulesAvailable(chunkGroup, originChunkGroupInfo.resultingAvailableModules))) {\n      continue;\n    } // 2. Foreach edge\n\n\n    for (let i = 0; i < connections.length; i++) {\n      const {\n        chunkGroup,\n        originChunkGroupInfo\n      } = connections[i]; // 3. Connect block with chunk\n\n      GraphHelpers.connectDependenciesBlockAndChunkGroup(block, chunkGroup); // 4. Connect chunk with parent\n\n      GraphHelpers.connectChunkGroupParentAndChild(originChunkGroupInfo.chunkGroup, chunkGroup);\n    }\n  }\n};\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\n\n\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n  for (const chunkGroup of allCreatedChunkGroups) {\n    if (chunkGroup.getNumberOfParents() === 0) {\n      for (const chunk of chunkGroup.chunks) {\n        const idx = compilation.chunks.indexOf(chunk);\n        if (idx >= 0) compilation.chunks.splice(idx, 1);\n        chunk.remove(\"unconnected\");\n      }\n\n      chunkGroup.remove(\"unconnected\");\n    }\n  }\n};\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups chunk groups which are processed\n * @returns {void}\n */\n\n\nconst buildChunkGraph = (compilation, inputChunkGroups) => {\n  // SHARED STATE\n\n  /** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */\n  const blockConnections = new Map();\n  /** @type {Set<ChunkGroup>} */\n\n  const allCreatedChunkGroups = new Set();\n  /** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n\n  const chunkGroupInfoMap = new Map();\n  /** @type {Set<DependenciesBlock>} */\n\n  const blocksWithNestedBlocks = new Set(); // PART ONE\n\n  visitModules(compilation, inputChunkGroups, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups); // PART TWO\n\n  connectChunkGroups(blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap); // Cleaup work\n\n  cleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n};\n\nmodule.exports = buildChunkGraph;","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/webpack/lib/buildChunkGraph.js"],"names":["AsyncDependencyToInitialChunkError","require","GraphHelpers","bySetSize","a","b","size","extraceBlockInfoMap","compilation","blockInfoMap","Map","iteratorDependency","d","ref","getDependencyReference","currentModule","refModule","module","weak","blockInfoModules","add","iteratorBlockPrepare","blockInfoBlocks","push","blockQueue","block","modules","length","pop","Set","variables","variable","dep","dependencies","blocks","blockInfo","set","visitModules","inputChunkGroups","chunkGroupInfoMap","blockConnections","blocksWithNestedBlocks","allCreatedChunkGroups","logger","getLogger","namedChunkGroups","time","chunkGroupCounters","chunkGroup","index","index2","nextFreeModuleIndex","nextFreeModuleIndex2","blockChunkGroups","ADD_AND_ENTER_MODULE","ENTER_MODULE","PROCESS_BLOCK","LEAVE_MODULE","reduceChunkGroupToQueueItem","queue","chunk","chunks","entryModule","action","minAvailableModules","minAvailableModulesOwned","availableModulesToBeMerged","skippedItems","resultingAvailableModules","undefined","children","reduce","reverse","queueConnect","outdatedChunkGroupInfo","queueDelayed","timeEnd","chunkGroupInfo","iteratorBlock","c","get","chunkName","isInitial","errors","loc","addChunkInGroup","groupOptions","request","addOptions","addOrigin","originChunkGroupInfo","connectList","queueItem","has","addModule","addChunk","getModuleIndex","setModuleIndex","skipBuffer","queueBuffer","containsModule","i","getModuleIndex2","setModuleIndex2","targets","info","m","modulesIterable","target","clear","cachedMinAvailableModules","sort","changed","availableModules","delete","newSet","iterator","Symbol","it","next","done","value","tempQueue","connectChunkGroups","areModulesAvailable","connections","every","connectDependenciesBlockAndChunkGroup","connectChunkGroupParentAndChild","cleanupUnconnectedGroups","getNumberOfParents","idx","indexOf","splice","remove","buildChunkGraph","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\nconst GraphHelpers = require(\"./GraphHelpers\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {Set<Module>} minAvailableModules current minimal set of modules available at this point\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\n * @property {Set<Module>[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {QueueItem[]} skippedItems queue items that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<Module>} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroup>} children set of children chunk groups, that will be revisited when availableModules shrink\n */\n\n/**\n * @typedef {Object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\n/**\n * @template T\n * @param {Set<T>} a first set\n * @param {Set<T>} b second set\n * @returns {number} cmp\n */\nconst bySetSize = (a, b) => {\n\treturn b.size - a.size;\n};\n\n/**\n * Extracts simplified info from the modules and their dependencies\n * @param {Compilation} compilation the compilation\n * @returns {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} the mapping block to modules and inner blocks\n */\nconst extraceBlockInfoMap = compilation => {\n\t/** @type {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} */\n\tconst blockInfoMap = new Map();\n\n\t/**\n\t * @param {Dependency} d dependency to iterate over\n\t * @returns {void}\n\t */\n\tconst iteratorDependency = d => {\n\t\t// We skip Dependencies without Reference\n\t\tconst ref = compilation.getDependencyReference(currentModule, d);\n\t\tif (!ref) {\n\t\t\treturn;\n\t\t}\n\t\t// We skip Dependencies without Module pointer\n\t\tconst refModule = ref.module;\n\t\tif (!refModule) {\n\t\t\treturn;\n\t\t}\n\t\t// We skip weak Dependencies\n\t\tif (ref.weak) {\n\t\t\treturn;\n\t\t}\n\n\t\tblockInfoModules.add(refModule);\n\t};\n\n\t/**\n\t * @param {AsyncDependenciesBlock} b blocks to prepare\n\t * @returns {void}\n\t */\n\tconst iteratorBlockPrepare = b => {\n\t\tblockInfoBlocks.push(b);\n\t\tblockQueue.push(b);\n\t};\n\n\t/** @type {Module} */\n\tlet currentModule;\n\t/** @type {DependenciesBlock} */\n\tlet block;\n\t/** @type {DependenciesBlock[]} */\n\tlet blockQueue;\n\t/** @type {Set<Module>} */\n\tlet blockInfoModules;\n\t/** @type {AsyncDependenciesBlock[]} */\n\tlet blockInfoBlocks;\n\n\tfor (const module of compilation.modules) {\n\t\tblockQueue = [module];\n\t\tcurrentModule = module;\n\t\twhile (blockQueue.length > 0) {\n\t\t\tblock = blockQueue.pop();\n\t\t\tblockInfoModules = new Set();\n\t\t\tblockInfoBlocks = [];\n\n\t\t\tif (block.variables) {\n\t\t\t\tfor (const variable of block.variables) {\n\t\t\t\t\tfor (const dep of variable.dependencies) iteratorDependency(dep);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (block.dependencies) {\n\t\t\t\tfor (const dep of block.dependencies) iteratorDependency(dep);\n\t\t\t}\n\n\t\t\tif (block.blocks) {\n\t\t\t\tfor (const b of block.blocks) iteratorBlockPrepare(b);\n\t\t\t}\n\n\t\t\tconst blockInfo = {\n\t\t\t\tmodules: blockInfoModules,\n\t\t\t\tblocks: blockInfoBlocks\n\t\t\t};\n\t\t\tblockInfoMap.set(block, blockInfo);\n\t\t}\n\t}\n\n\treturn blockInfoMap;\n};\n\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups input groups\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\n */\nconst visitModules = (\n\tcompilation,\n\tinputChunkGroups,\n\tchunkGroupInfoMap,\n\tblockConnections,\n\tblocksWithNestedBlocks,\n\tallCreatedChunkGroups\n) => {\n\tconst logger = compilation.getLogger(\"webpack.buildChunkGraph.visitModules\");\n\tconst { namedChunkGroups } = compilation;\n\n\tlogger.time(\"prepare\");\n\tconst blockInfoMap = extraceBlockInfoMap(compilation);\n\n\t/** @type {Map<ChunkGroup, { index: number, index2: number }>} */\n\tconst chunkGroupCounters = new Map();\n\tfor (const chunkGroup of inputChunkGroups) {\n\t\tchunkGroupCounters.set(chunkGroup, {\n\t\t\tindex: 0,\n\t\t\tindex2: 0\n\t\t});\n\t}\n\n\tlet nextFreeModuleIndex = 0;\n\tlet nextFreeModuleIndex2 = 0;\n\n\t/** @type {Map<DependenciesBlock, ChunkGroup>} */\n\tconst blockChunkGroups = new Map();\n\n\tconst ADD_AND_ENTER_MODULE = 0;\n\tconst ENTER_MODULE = 1;\n\tconst PROCESS_BLOCK = 2;\n\tconst LEAVE_MODULE = 3;\n\n\t/**\n\t * @param {QueueItem[]} queue the queue array (will be mutated)\n\t * @param {ChunkGroup} chunkGroup chunk group\n\t * @returns {QueueItem[]} the queue array again\n\t */\n\tconst reduceChunkGroupToQueueItem = (queue, chunkGroup) => {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tconst module = chunk.entryModule;\n\t\t\tqueue.push({\n\t\t\t\taction: ENTER_MODULE,\n\t\t\t\tblock: module,\n\t\t\t\tmodule,\n\t\t\t\tchunk,\n\t\t\t\tchunkGroup\n\t\t\t});\n\t\t}\n\t\tchunkGroupInfoMap.set(chunkGroup, {\n\t\t\tchunkGroup,\n\t\t\tminAvailableModules: new Set(),\n\t\t\tminAvailableModulesOwned: true,\n\t\t\tavailableModulesToBeMerged: [],\n\t\t\tskippedItems: [],\n\t\t\tresultingAvailableModules: undefined,\n\t\t\tchildren: undefined\n\t\t});\n\t\treturn queue;\n\t};\n\n\t// Start with the provided modules/chunks\n\t/** @type {QueueItem[]} */\n\tlet queue = inputChunkGroups\n\t\t.reduce(reduceChunkGroupToQueueItem, [])\n\t\t.reverse();\n\t/** @type {Map<ChunkGroup, Set<ChunkGroup>>} */\n\tconst queueConnect = new Map();\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst outdatedChunkGroupInfo = new Set();\n\t/** @type {QueueItem[]} */\n\tlet queueDelayed = [];\n\n\tlogger.timeEnd(\"prepare\");\n\n\t/** @type {Module} */\n\tlet module;\n\t/** @type {Chunk} */\n\tlet chunk;\n\t/** @type {ChunkGroup} */\n\tlet chunkGroup;\n\t/** @type {ChunkGroupInfo} */\n\tlet chunkGroupInfo;\n\t/** @type {DependenciesBlock} */\n\tlet block;\n\t/** @type {Set<Module>} */\n\tlet minAvailableModules;\n\t/** @type {QueueItem[]} */\n\tlet skippedItems;\n\n\t// For each async Block in graph\n\t/**\n\t * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n\t * @returns {void}\n\t */\n\tconst iteratorBlock = b => {\n\t\t// 1. We create a chunk for this Block\n\t\t// but only once (blockChunkGroups map)\n\t\tlet c = blockChunkGroups.get(b);\n\t\tif (c === undefined) {\n\t\t\tc = namedChunkGroups.get(b.chunkName);\n\t\t\tif (c && c.isInitial()) {\n\t\t\t\tcompilation.errors.push(\n\t\t\t\t\tnew AsyncDependencyToInitialChunkError(b.chunkName, module, b.loc)\n\t\t\t\t);\n\t\t\t\tc = chunkGroup;\n\t\t\t} else {\n\t\t\t\tc = compilation.addChunkInGroup(\n\t\t\t\t\tb.groupOptions || b.chunkName,\n\t\t\t\t\tmodule,\n\t\t\t\t\tb.loc,\n\t\t\t\t\tb.request\n\t\t\t\t);\n\t\t\t\tchunkGroupCounters.set(c, { index: 0, index2: 0 });\n\t\t\t\tblockChunkGroups.set(b, c);\n\t\t\t\tallCreatedChunkGroups.add(c);\n\t\t\t}\n\t\t\tblockConnections.set(b, []);\n\t\t} else {\n\t\t\t// TODO webpack 5 remove addOptions check\n\t\t\tif (c.addOptions) c.addOptions(b.groupOptions);\n\t\t\tc.addOrigin(module, b.loc, b.request);\n\t\t}\n\n\t\t// 2. We store the connection for the block\n\t\t// to connect it later if needed\n\t\tblockConnections.get(b).push({\n\t\t\toriginChunkGroupInfo: chunkGroupInfo,\n\t\t\tchunkGroup: c\n\t\t});\n\n\t\t// 3. We create/update the chunk group info\n\t\tlet connectList = queueConnect.get(chunkGroup);\n\t\tif (connectList === undefined) {\n\t\t\tconnectList = new Set();\n\t\t\tqueueConnect.set(chunkGroup, connectList);\n\t\t}\n\t\tconnectList.add(c);\n\n\t\t// 4. We enqueue the DependenciesBlock for traversal\n\t\tqueueDelayed.push({\n\t\t\taction: PROCESS_BLOCK,\n\t\t\tblock: b,\n\t\t\tmodule: module,\n\t\t\tchunk: c.chunks[0],\n\t\t\tchunkGroup: c\n\t\t});\n\t};\n\n\t// Iterative traversal of the Module graph\n\t// Recursive would be simpler to write but could result in Stack Overflows\n\twhile (queue.length) {\n\t\tlogger.time(\"visiting\");\n\t\twhile (queue.length) {\n\t\t\tconst queueItem = queue.pop();\n\t\t\tmodule = queueItem.module;\n\t\t\tblock = queueItem.block;\n\t\t\tchunk = queueItem.chunk;\n\t\t\tif (chunkGroup !== queueItem.chunkGroup) {\n\t\t\t\tchunkGroup = queueItem.chunkGroup;\n\t\t\t\tchunkGroupInfo = chunkGroupInfoMap.get(chunkGroup);\n\t\t\t\tminAvailableModules = chunkGroupInfo.minAvailableModules;\n\t\t\t\tskippedItems = chunkGroupInfo.skippedItems;\n\t\t\t}\n\n\t\t\tswitch (queueItem.action) {\n\t\t\t\tcase ADD_AND_ENTER_MODULE: {\n\t\t\t\t\tif (minAvailableModules.has(module)) {\n\t\t\t\t\t\t// already in parent chunks\n\t\t\t\t\t\t// skip it for now, but enqueue for rechecking when minAvailableModules shrinks\n\t\t\t\t\t\tskippedItems.push(queueItem);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// We connect Module and Chunk when not already done\n\t\t\t\t\tif (chunk.addModule(module)) {\n\t\t\t\t\t\tmodule.addChunk(chunk);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// already connected, skip it\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase ENTER_MODULE: {\n\t\t\t\t\tif (chunkGroup !== undefined) {\n\t\t\t\t\t\tconst index = chunkGroup.getModuleIndex(module);\n\t\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\t\tchunkGroup.setModuleIndex(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\tchunkGroupCounters.get(chunkGroup).index++\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (module.index === null) {\n\t\t\t\t\t\tmodule.index = nextFreeModuleIndex++;\n\t\t\t\t\t}\n\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\taction: LEAVE_MODULE,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tchunk,\n\t\t\t\t\t\tchunkGroup\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase PROCESS_BLOCK: {\n\t\t\t\t\t// get prepared block info\n\t\t\t\t\tconst blockInfo = blockInfoMap.get(block);\n\n\t\t\t\t\t// Buffer items because order need to be reverse to get indicies correct\n\t\t\t\t\tconst skipBuffer = [];\n\t\t\t\t\tconst queueBuffer = [];\n\t\t\t\t\t// Traverse all referenced modules\n\t\t\t\t\tfor (const refModule of blockInfo.modules) {\n\t\t\t\t\t\tif (chunk.containsModule(refModule)) {\n\t\t\t\t\t\t\t// skip early if already connected\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (minAvailableModules.has(refModule)) {\n\t\t\t\t\t\t\t// already in parent chunks, skip it for now\n\t\t\t\t\t\t\tskipBuffer.push({\n\t\t\t\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\t\t\t\tblock: refModule,\n\t\t\t\t\t\t\t\tmodule: refModule,\n\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\tchunkGroup\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// enqueue the add and enter to enter in the correct order\n\t\t\t\t\t\t// this is relevant with circular dependencies\n\t\t\t\t\t\tqueueBuffer.push({\n\t\t\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\t\t\tblock: refModule,\n\t\t\t\t\t\t\tmodule: refModule,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tchunkGroup\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t// Add buffered items in reversed order\n\t\t\t\t\tfor (let i = skipBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tskippedItems.push(skipBuffer[i]);\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = queueBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tqueue.push(queueBuffer[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Traverse all Blocks\n\t\t\t\t\tfor (const block of blockInfo.blocks) iteratorBlock(block);\n\n\t\t\t\t\tif (blockInfo.blocks.length > 0 && module !== block) {\n\t\t\t\t\t\tblocksWithNestedBlocks.add(block);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase LEAVE_MODULE: {\n\t\t\t\t\tif (chunkGroup !== undefined) {\n\t\t\t\t\t\tconst index = chunkGroup.getModuleIndex2(module);\n\t\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\t\tchunkGroup.setModuleIndex2(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\tchunkGroupCounters.get(chunkGroup).index2++\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (module.index2 === null) {\n\t\t\t\t\t\tmodule.index2 = nextFreeModuleIndex2++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlogger.timeEnd(\"visiting\");\n\n\t\twhile (queueConnect.size > 0) {\n\t\t\tlogger.time(\"calculating available modules\");\n\n\t\t\t// Figure out new parents for chunk groups\n\t\t\t// to get new available modules for these children\n\t\t\tfor (const [chunkGroup, targets] of queueConnect) {\n\t\t\t\tconst info = chunkGroupInfoMap.get(chunkGroup);\n\t\t\t\tlet minAvailableModules = info.minAvailableModules;\n\n\t\t\t\t// 1. Create a new Set of available modules at this points\n\t\t\t\tconst resultingAvailableModules = new Set(minAvailableModules);\n\t\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\t\tfor (const m of chunk.modulesIterable) {\n\t\t\t\t\t\tresultingAvailableModules.add(m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinfo.resultingAvailableModules = resultingAvailableModules;\n\t\t\t\tif (info.children === undefined) {\n\t\t\t\t\tinfo.children = targets;\n\t\t\t\t} else {\n\t\t\t\t\tfor (const target of targets) {\n\t\t\t\t\t\tinfo.children.add(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 2. Update chunk group info\n\t\t\t\tfor (const target of targets) {\n\t\t\t\t\tlet chunkGroupInfo = chunkGroupInfoMap.get(target);\n\t\t\t\t\tif (chunkGroupInfo === undefined) {\n\t\t\t\t\t\tchunkGroupInfo = {\n\t\t\t\t\t\t\tchunkGroup: target,\n\t\t\t\t\t\t\tminAvailableModules: undefined,\n\t\t\t\t\t\t\tminAvailableModulesOwned: undefined,\n\t\t\t\t\t\t\tavailableModulesToBeMerged: [],\n\t\t\t\t\t\t\tskippedItems: [],\n\t\t\t\t\t\t\tresultingAvailableModules: undefined,\n\t\t\t\t\t\t\tchildren: undefined\n\t\t\t\t\t\t};\n\t\t\t\t\t\tchunkGroupInfoMap.set(target, chunkGroupInfo);\n\t\t\t\t\t}\n\t\t\t\t\tchunkGroupInfo.availableModulesToBeMerged.push(\n\t\t\t\t\t\tresultingAvailableModules\n\t\t\t\t\t);\n\t\t\t\t\toutdatedChunkGroupInfo.add(chunkGroupInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueueConnect.clear();\n\t\t\tlogger.timeEnd(\"calculating available modules\");\n\n\t\t\tif (outdatedChunkGroupInfo.size > 0) {\n\t\t\t\tlogger.time(\"merging available modules\");\n\t\t\t\t// Execute the merge\n\t\t\t\tfor (const info of outdatedChunkGroupInfo) {\n\t\t\t\t\tconst availableModulesToBeMerged = info.availableModulesToBeMerged;\n\t\t\t\t\tlet cachedMinAvailableModules = info.minAvailableModules;\n\n\t\t\t\t\t// 1. Get minimal available modules\n\t\t\t\t\t// It doesn't make sense to traverse a chunk again with more available modules.\n\t\t\t\t\t// This step calculates the minimal available modules and skips traversal when\n\t\t\t\t\t// the list didn't shrink.\n\t\t\t\t\tif (availableModulesToBeMerged.length > 1) {\n\t\t\t\t\t\tavailableModulesToBeMerged.sort(bySetSize);\n\t\t\t\t\t}\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\tfor (const availableModules of availableModulesToBeMerged) {\n\t\t\t\t\t\tif (cachedMinAvailableModules === undefined) {\n\t\t\t\t\t\t\tcachedMinAvailableModules = availableModules;\n\t\t\t\t\t\t\tinfo.minAvailableModules = cachedMinAvailableModules;\n\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = false;\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (info.minAvailableModulesOwned) {\n\t\t\t\t\t\t\t\t// We own it and can modify it\n\t\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\t\t\tif (!availableModules.has(m)) {\n\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.delete(m);\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\t\t\tif (!availableModules.has(m)) {\n\t\t\t\t\t\t\t\t\t\t// cachedMinAvailableModules need to be modified\n\t\t\t\t\t\t\t\t\t\t// but we don't own it\n\t\t\t\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\t\t\t\t\t\t\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\t\t\t\t\t\t\tconst newSet = new Set();\n\t\t\t\t\t\t\t\t\t\tconst iterator = cachedMinAvailableModules[\n\t\t\t\t\t\t\t\t\t\t\tSymbol.iterator\n\t\t\t\t\t\t\t\t\t\t]();\n\t\t\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\n\t\t\t\t\t\t\t\t\t\tlet it;\n\t\t\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\t\t\tif (module === m) break;\n\t\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\t\t\tif (availableModules.has(module)) {\n\t\t\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\n\t\t\t\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\n\t\t\t\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\n\n\t\t\t\t\t\t\t\t\t\t// Update the cache from the first queue\n\t\t\t\t\t\t\t\t\t\t// if the chunkGroup is currently cached\n\t\t\t\t\t\t\t\t\t\tif (chunkGroup === info.chunkGroup) {\n\t\t\t\t\t\t\t\t\t\t\tminAvailableModules = cachedMinAvailableModules;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tavailableModulesToBeMerged.length = 0;\n\t\t\t\t\tif (!changed) continue;\n\n\t\t\t\t\t// 2. Reconsider skipped items\n\t\t\t\t\tfor (const queueItem of info.skippedItems) {\n\t\t\t\t\t\tqueue.push(queueItem);\n\t\t\t\t\t}\n\t\t\t\t\tinfo.skippedItems.length = 0;\n\n\t\t\t\t\t// 3. Reconsider children chunk groups\n\t\t\t\t\tif (info.children !== undefined) {\n\t\t\t\t\t\tconst chunkGroup = info.chunkGroup;\n\t\t\t\t\t\tfor (const c of info.children) {\n\t\t\t\t\t\t\tlet connectList = queueConnect.get(chunkGroup);\n\t\t\t\t\t\t\tif (connectList === undefined) {\n\t\t\t\t\t\t\t\tconnectList = new Set();\n\t\t\t\t\t\t\t\tqueueConnect.set(chunkGroup, connectList);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconnectList.add(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toutdatedChunkGroupInfo.clear();\n\t\t\t\tlogger.timeEnd(\"merging available modules\");\n\t\t\t}\n\t\t}\n\n\t\t// Run queueDelayed when all items of the queue are processed\n\t\t// This is important to get the global indicing correct\n\t\t// Async blocks should be processed after all sync blocks are processed\n\t\tif (queue.length === 0) {\n\t\t\tconst tempQueue = queue;\n\t\t\tqueue = queueDelayed.reverse();\n\t\t\tqueueDelayed = tempQueue;\n\t\t}\n\t}\n};\n\n/**\n *\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n */\nconst connectChunkGroups = (\n\tblocksWithNestedBlocks,\n\tblockConnections,\n\tchunkGroupInfoMap\n) => {\n\t/**\n\t * Helper function to check if all modules of a chunk are available\n\t *\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n\t * @param {Set<Module>} availableModules the comparitor set\n\t * @returns {boolean} return true if all modules of a chunk are available\n\t */\n\tconst areModulesAvailable = (chunkGroup, availableModules) => {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tfor (const module of chunk.modulesIterable) {\n\t\t\t\tif (!availableModules.has(module)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t// For each edge in the basic chunk graph\n\tfor (const [block, connections] of blockConnections) {\n\t\t// 1. Check if connection is needed\n\t\t// When none of the dependencies need to be connected\n\t\t// we can skip all of them\n\t\t// It's not possible to filter each item so it doesn't create inconsistent\n\t\t// connections and modules can only create one version\n\t\t// TODO maybe decide this per runtime\n\t\tif (\n\t\t\t// TODO is this needed?\n\t\t\t!blocksWithNestedBlocks.has(block) &&\n\t\t\tconnections.every(({ chunkGroup, originChunkGroupInfo }) =>\n\t\t\t\tareModulesAvailable(\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\toriginChunkGroupInfo.resultingAvailableModules\n\t\t\t\t)\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// 2. Foreach edge\n\t\tfor (let i = 0; i < connections.length; i++) {\n\t\t\tconst { chunkGroup, originChunkGroupInfo } = connections[i];\n\n\t\t\t// 3. Connect block with chunk\n\t\t\tGraphHelpers.connectDependenciesBlockAndChunkGroup(block, chunkGroup);\n\n\t\t\t// 4. Connect chunk with parent\n\t\t\tGraphHelpers.connectChunkGroupParentAndChild(\n\t\t\t\toriginChunkGroupInfo.chunkGroup,\n\t\t\t\tchunkGroup\n\t\t\t);\n\t\t}\n\t}\n};\n\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n\tfor (const chunkGroup of allCreatedChunkGroups) {\n\t\tif (chunkGroup.getNumberOfParents() === 0) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tconst idx = compilation.chunks.indexOf(chunk);\n\t\t\t\tif (idx >= 0) compilation.chunks.splice(idx, 1);\n\t\t\t\tchunk.remove(\"unconnected\");\n\t\t\t}\n\t\t\tchunkGroup.remove(\"unconnected\");\n\t\t}\n\t}\n};\n\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups chunk groups which are processed\n * @returns {void}\n */\nconst buildChunkGraph = (compilation, inputChunkGroups) => {\n\t// SHARED STATE\n\n\t/** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */\n\tconst blockConnections = new Map();\n\n\t/** @type {Set<ChunkGroup>} */\n\tconst allCreatedChunkGroups = new Set();\n\n\t/** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n\tconst chunkGroupInfoMap = new Map();\n\n\t/** @type {Set<DependenciesBlock>} */\n\tconst blocksWithNestedBlocks = new Set();\n\n\t// PART ONE\n\n\tvisitModules(\n\t\tcompilation,\n\t\tinputChunkGroups,\n\t\tchunkGroupInfoMap,\n\t\tblockConnections,\n\t\tblocksWithNestedBlocks,\n\t\tallCreatedChunkGroups\n\t);\n\n\t// PART TWO\n\n\tconnectChunkGroups(\n\t\tblocksWithNestedBlocks,\n\t\tblockConnections,\n\t\tchunkGroupInfoMap\n\t);\n\n\t// Cleaup work\n\n\tcleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n};\n\nmodule.exports = buildChunkGraph;\n"]},"metadata":{},"sourceType":"script"}