{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst networks_1 = require('../networks');\n\nconst bscript = require('../script');\n\nconst lazy = require('./lazy');\n\nconst typef = require('typeforce');\n\nconst OPS = bscript.OPS;\n\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n} // output: OP_RETURN ...\n\n\nfunction p2data(a, opts) {\n  if (!a.data && !a.output) throw new TypeError('Not enough data');\n  opts = Object.assign({\n    validate: true\n  }, opts || {});\n  typef({\n    network: typef.maybe(typef.Object),\n    output: typef.maybe(typef.Buffer),\n    data: typef.maybe(typef.arrayOf(typef.Buffer))\n  }, a);\n  const network = a.network || networks_1.bitcoin;\n  const o = {\n    name: 'embed',\n    network\n  };\n  lazy.prop(o, 'output', () => {\n    if (!a.data) return;\n    return bscript.compile([OPS.OP_RETURN].concat(a.data));\n  });\n  lazy.prop(o, 'data', () => {\n    if (!a.output) return;\n    return bscript.decompile(a.output).slice(1);\n  }); // extended validation\n\n  if (opts.validate) {\n    if (a.output) {\n      const chunks = bscript.decompile(a.output);\n      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');\n      if (!chunks.slice(1).every(typef.Buffer)) throw new TypeError('Output is invalid');\n      if (a.data && !stacksEqual(a.data, o.data)) throw new TypeError('Data mismatch');\n    }\n  }\n\n  return Object.assign(o, a);\n}\n\nexports.p2data = p2data;","map":{"version":3,"sources":["/Users/wiki/code/filecoin/private.storage/node_modules/bitcoinjs-lib/src/payments/embed.js"],"names":["Object","defineProperty","exports","value","networks_1","require","bscript","lazy","typef","OPS","stacksEqual","a","b","length","every","x","i","equals","p2data","opts","data","output","TypeError","assign","validate","network","maybe","Buffer","arrayOf","bitcoin","o","name","prop","compile","OP_RETURN","concat","decompile","slice","chunks"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\n// output: OP_RETURN ...\nfunction p2data(a, opts) {\n  if (!a.data && !a.output) throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      output: typef.maybe(typef.Buffer),\n      data: typef.maybe(typef.arrayOf(typef.Buffer)),\n    },\n    a,\n  );\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'embed', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.data) return;\n    return bscript.compile([OPS.OP_RETURN].concat(a.data));\n  });\n  lazy.prop(o, 'data', () => {\n    if (!a.output) return;\n    return bscript.decompile(a.output).slice(1);\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      const chunks = bscript.decompile(a.output);\n      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');\n      if (!chunks.slice(1).every(typef.Buffer))\n        throw new TypeError('Output is invalid');\n      if (a.data && !stacksEqual(a.data, o.data))\n        throw new TypeError('Data mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2data = p2data;\n"]},"metadata":{},"sourceType":"script"}